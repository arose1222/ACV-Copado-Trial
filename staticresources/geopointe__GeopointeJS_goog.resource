!function(e){var n={};function t(a){if(n[a])return n[a].exports;var o=n[a]={i:a,l:!1,exports:{}};return e[a].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=e,t.c=n,t.d=function(e,n,a){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:a})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(t.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(a,o,function(n){return e[n]}.bind(null,o));return a},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=1)}([function(e,n){e.exports=function(e){function n(e){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",e)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(e):"undefined"!=typeof eval?eval.call(null,e):n("EvalError: No eval function available")}catch(e){n(e)}}},function(e,n,t){e.exports=t(2)},function(e,n,t){t(0)(t(3))},function(e,n){e.exports="function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar gp_map; // holds the Map object\n\nvar gp_bestFitMaxZoom; // max zoom for bestFit. global var b/c we need it in a listener\n\nvar gp_forceBestFitMaxZoom = false; // whether the listener should use bestFitMaxZoom or not\n\nvar googAutoCompleteService = new google.maps.places.AutocompleteService();\nvar placesService; // For markers\n\nvar gp_markers; // all the map markers as an associative array\n\nvar gp_masterMarker; // The Master Record's Marker - GMarker\n\nvar gp_searchMarker;\nvar gp_recordSearchMarker;\nvar gp_bounds; // holds the LatLngBounds object so we can center and zoom properly - GLatLngBounds\n\nvar gp_infoWindow; // a single info window object used on the map\n\nvar gp_tooltip; // a floating tooltip for the markers\n\nvar gp_cirOverlays; // all the Circle overlay as an associative array\n\nvar gp_layers = {}; // object that contains url as key, and google layer object as value\n\nvar gp_sameLocationMarkers = []; // Layers\n\nvar gp_traffic;\nvar gp_trafficState = false; // For Drawing\n\nvar gp_drawingManager; // master drawing manager object\n\nvar gp_shapeDragInProgress = false; //For Heatmaps\n\nvar gp_heatmaps = {}; //Object that contains heatmaps with key as the POIC unique Id\n\nvar gp_remapHidden = [];\nvar gp_dragMarker;\nvar gp_isFullScreen = false;\nvar gp_isWeekViewCalendarShowing = false; //Info about the jQuery Tabs\n\nvar gp_JQTabs = {\n  mapDataSets: 0,\n  search: 1,\n  layers: 2,\n  manualEntry: 3,\n  currentRoute: 4,\n  mySettings: 5\n}; // Legend metrics aggregation by type\n\ngp_supportedAggrFieldTypes = ['CURRENCY', 'DOUBLE', 'INTEGER', 'PERCENT'];\nvar GP_POLYLINE_STROKE = 5;\nvar gp_isLongPress = false;\nvar gp_isMouseUp = false;\nvar gp_isDrawingMode = false;\n\nfunction __MAPPING_STUFF__() {} // re-init the global objects\n\n\nfunction gp_initJSObjects() {\n  if (typeof gp_markers == 'undefined') {\n    gp_markers = new Object();\n  }\n\n  if (typeof gp_bounds == 'undefined') {\n    gp_bounds = new google.maps.LatLngBounds();\n  }\n\n  if (typeof gp_infoWindow == 'undefined') {\n    gp_infoWindow = new google.maps.InfoWindow({\n      maxWidth: 550,\n      disableAutoPan: true\n    });\n    gp_infoWindow.originalOpen = gp_infoWindow.open;\n\n    gp_infoWindow.open = function () {\n      if (gp_mapMode === 'search' || gp_mapMode === 'thematicEdit' || !gp_mapMode) gp_infoWindow.originalOpen.apply(gp_infoWindow, arguments);\n    }; // Close edit window when infowindow closes\n\n\n    gp_infoWindow.addListener('closeclick', function () {\n      gp_inlineEdit.close();\n    }); // Close edit window when infowindow moves\n\n    gp_infoWindow.addListener('position_changed', function () {\n      gp_inlineEdit.close();\n    });\n    google.maps.event.addListener(gp_infoWindow, 'domready', function () {\n      jQuery('#gp_demoTabs').tabs();\n      jQuery('#gp_demoTabs').show(); //Find the shapeColor input field\n\n      var $colorInput = jQuery('.gp_shapeColorInput');\n\n      if ($colorInput.length > 0) {\n        //Only proceed if infowindow has a color input for a shape\n        //Get the shape object from the polygonObjects object so we can default the\n        var shapeId = $colorInput.attr('data-shapeId');\n        var polygon = polygonObjects[shapeId]; //Set starting color value and opacity on the input field\n\n        $colorInput.val('polyline' == polygon.gpProperties.gpType ? polygon.strokeColor : polygon.fillColor);\n        $colorInput.attr('data-opacity', 'polyline' == polygon.gpProperties.gpType ? polygon.strokeOpacity : polygon.fillOpacity); //Apply original colors, they can change when a users hovers\n\n        if (polygon.gpProperties.originalOpacity) {\n          $colorInput.attr('data-opacity', polygon.gpProperties.originalOpacity);\n        }\n\n        if (polygon.gpProperties.originalColor) {\n          $colorInput.val(polygon.gpProperties.originalColor);\n        } //Create color selector for the selected shape\n\n\n        jQuery('.gp_shapeColorInput').minicolors({\n          inline: true,\n          opacity: true,\n          theme: 'geopointe',\n          change: function change(hex, opacity) {\n            //Get overlay Id\n            var overlayId = jQuery(this).attr('data-shapeId');\n            var groupLayerId = jQuery(this).attr('data-groupLayerId'); //If there is a groupLayerId update all the layers with this id\n\n            if (groupLayerId && groupLayerId != 'undefined' && groupLayerId != '') {\n              for (key in polygonObjects) {\n                if (polygonObjects[key].gpProperties.groupLayerId == groupLayerId) {\n                  if ('polyline' == polygonObjects[key].gpProperties.gpType) {\n                    polygonObjects[key].setOptions({\n                      strokeColor: hex,\n                      strokeOpacity: opacity\n                    });\n                  } else {\n                    polygonObjects[key].setOptions({\n                      fillColor: hex,\n                      fillOpacity: opacity\n                    });\n                  }\n\n                  polygonObjects[key].gpProperties.originalColor = hex;\n                  polygonObjects[key].gpProperties.originalOpacity = opacity;\n                }\n              }\n            } else {\n              //update this single shape\n              //Set the color and opacity of the shap on the map\n              if ('polyline' == polygonObjects[overlayId].gpProperties.gpType) {\n                polygonObjects[overlayId].setOptions({\n                  strokeColor: hex,\n                  strokeOpacity: opacity\n                });\n              } else {\n                polygonObjects[overlayId].setOptions({\n                  fillColor: hex,\n                  fillOpacity: opacity\n                });\n              }\n\n              polygonObjects[overlayId].gpProperties.originalColor = hex;\n              polygonObjects[overlayId].gpProperties.originalOpacity = opacity;\n            }\n          }\n        });\n      }\n\n      const payload = {\n        action: 'panToInfoWindow',\n        data: {\n          selector: '.gm-style-iw',\n          backupLatLng: {\n            lat: gp_infoWindow.position.lat(),\n            lng: gp_infoWindow.position.lng()\n          }\n        }\n      };\n      asyncGpEmitter('InfoWindowService', payload);\n    });\n  }\n\n  if (typeof gp_tooltip == 'undefined') {\n    var ttOptions = {\n      content: '',\n      boxClass: 'gp_tooltip',\n      closeBoxURL: '',\n      isHidden: true\n    };\n    gp_tooltip = new InfoBox(ttOptions); // using the infoBox add-in\n  }\n\n  if (typeof gp_cirOverlays == 'undefined') {\n    gp_cirOverlays = new Object();\n  }\n} //Clears the global variables out\n\n\nfunction gp_cleanMapObjects() {\n  for (var i in gp_markers) {\n    gp_markers[i].setMap(null);\n  }\n\n  gp_infoWindow.close();\n  gp_tooltip.hide();\n\n  for (var i in gp_cirOverlays) {\n    gp_cirOverlays[i].setMap(null);\n  } //Clear heat maps\n\n\n  for (var i in gp_heatmaps) {\n    gp_heatmaps[i].setMap(null);\n  } //Remove shape fields\n\n\n  for (key in polygonObjects) {\n    //Don't remove shapes associated with center pin marker\n    if (polygonObjects[key].gpProperties.usageType == 'Shape Field' && gp_centerPOI.recordId && gp_centerPOI.recordId == polygonObjects[key].gpProperties.relatedRecordId) {//don't remove this shape\n    } else if (polygonObjects[key].gpProperties.usageType == 'Shape Field') {\n      polygonObjects[key].setMap(null);\n      delete polygonObjects[key];\n    }\n  }\n\n  gp_bounds = new google.maps.LatLngBounds();\n  gp_markers = new Object();\n  gp_cirOverlays = new Object();\n} // Handles a Map Constructor\n\n\nfunction gp_mapConstructor(jsAction) {\n  var thisMC = jsAction.mapConstructor; // Fix up the thisMC object as needed\n\n  thisMC.startingZoom = 2;\n  thisMC.startingLat = 12;\n  thisMC.startingLng = -30;\n\n  if (gp_userSettings && gp_userSettings.settings__c && !jsAction.mapConstructor.centerAddress) {\n    if (typeof gp_userSettings.settings__c[gp_orgSettings.fieldPrefix + 'Starting_Zoom__c'] != 'undefined') thisMC.startingZoom = gp_userSettings.settings__c[gp_orgSettings.fieldPrefix + 'Starting_Zoom__c'];\n    if (typeof gp_userSettings.settings__c[gp_orgSettings.fieldPrefix + 'Starting_Lat__c'] != 'undefined') thisMC.startingLat = gp_userSettings.settings__c[gp_orgSettings.fieldPrefix + 'Starting_Lat__c'];\n    if (typeof gp_userSettings.settings__c[gp_orgSettings.fieldPrefix + 'Starting_Lng__c'] != 'undefined') thisMC.startingLng = gp_userSettings.settings__c[gp_orgSettings.fieldPrefix + 'Starting_Lng__c'];\n  }\n\n  thisMC.width = document.getElementById('mapWrapper').clientWidth;\n\n  if (thisMC.height == '') {\n    thisMC.height = 600;\n  }\n\n  if (thisMC.centerLat == null || thisMC.centerLat == '') {\n    thisMC.centerLat = thisMC.startingLat;\n  }\n\n  if (thisMC.centerLng == null || thisMC.centerLng == '') {\n    thisMC.centerLng = thisMC.startingLng;\n  }\n\n  if (thisMC.centerZoom == null || thisMC.centerZoom == '') {\n    thisMC.centerZoom = thisMC.startingZoom;\n  } // New Map Object\n\n\n  if (thisMC.newMap) {\n    gp_map = null;\n    document.getElementById('mapDIV').innerHTML = '';\n    gp_bounds = new google.maps.LatLngBounds(); // Build list of custom style ids and maps\n\n    var mapStyleIds = [];\n    gp_mapStyles.forEach(function (mapStyle) {\n      var style;\n\n      try {\n        style = JSON.parse(mapStyle[nameSpacePrefix + 'Style_JSON__c']);\n      } catch (err) {\n        console.log(err);\n        return;\n      }\n\n      mapStyleIds.push(mapStyle.Id);\n      mapStyle.map = new google.maps.StyledMapType(style, {\n        name: mapStyle.Name\n      });\n    }); //Determine map type\n\n    var savedMapTypeId = gp_userSettings.settings__c[gp_orgSettings.fieldPrefix + 'Map_Type__c'];\n    var googleMapTypeId = google.maps.MapTypeId.ROADMAP;\n\n    if (savedMapTypeId == 'map' || savedMapTypeId == 'OSM' || savedMapTypeId == 'roadmap') {\n      googleMapTypeId = google.maps.MapTypeId.ROADMAP;\n    } else if (savedMapTypeId == 'terrain') {\n      googleMapTypeId = google.maps.MapTypeId.TERRAIN;\n    } else if (savedMapTypeId == 'sat' || savedMapTypeId == 'satellite') {\n      jQuery('.mapControlTabInner').addClass('mapControlDarkShadow');\n      jQuery('.mapControlContent').addClass('mapControlContentDarkShadow');\n      gp_events.emit('changeSettingsHelpIconColor', 'white');\n      googleMapTypeId = google.maps.MapTypeId.SATELLITE;\n    } else if (savedMapTypeId == 'hyb' || savedMapTypeId == 'hybrid') {\n      jQuery('.mapControlTabInner').addClass('mapControlDarkShadow');\n      jQuery('.mapControlContent').addClass('mapControlContentDarkShadow');\n      gp_events.emit('changeSettingsHelpIconColor', 'white');\n      googleMapTypeId = google.maps.MapTypeId.HYBRID;\n    } else if (mapStyleIds.some(function (id) {\n      return id === savedMapTypeId;\n    })) {\n      googleMapTypeId = savedMapTypeId;\n    } else {\n      googleMapTypeId = google.maps.MapTypeId.ROADMAP;\n    } // Set map initial options\n\n\n    var useScrollWheelZoom = gp_userSettings.settings__c[gp_orgSettings.fieldPrefix + 'Use_Scrollwheel_Zoom__c'];\n\n    if (typeof getURLparams().inlineMap != 'undefined') {\n      useScrollWheelZoom = false;\n    }\n\n    var myOptions = {\n      zoom: thisMC.startingZoom,\n      center: new google.maps.LatLng(thisMC.startingLat, thisMC.startingLng),\n      draggableCursor: 'default',\n      gestureHandling: 'greedy',\n      mapTypeId: googleMapTypeId,\n      mapTypeControlOptions: {\n        style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,\n        position: google.maps.ControlPosition.TOP_RIGHT,\n        mapTypeIds: [google.maps.MapTypeId.ROADMAP, google.maps.MapTypeId.SATELLITE, google.maps.MapTypeId.TERRAIN, google.maps.MapTypeId.HYBRID].concat(mapStyleIds)\n      },\n      panControlOptions: {\n        position: google.maps.ControlPosition.RIGHT_TOP\n      },\n      zoomControlOptions: {\n        position: google.maps.ControlPosition.RIGHT_BOTTOM\n      },\n      streetViewControlOptions: {\n        position: google.maps.ControlPosition.RIGHT_BOTTOM\n      },\n      fullscreenControlOptions: {\n        position: google.maps.ControlPosition.TOP_RIGHT\n      },\n      fullscreenControl: false,\n      clickableIcons: false,\n      scaleControl: true,\n      scrollwheel: useScrollWheelZoom,\n      overviewMapControl: true,\n      backgroundColor: 'none'\n    }; // init the map\n\n    gp_map = new google.maps.Map(document.getElementById('mapDIV'), myOptions); //Show the map controls\n\n    jQuery('#mapControlsWrapper').removeClass('mapControlsWrapperInit'); //Remove the splash background\n\n    var initLoad = google.maps.event.addListenerOnce(gp_map, 'idle', function () {\n      jQuery('#mapDIV').removeClass('mapDIVloading');\n      google.maps.event.removeListener(initLoad);\n    });\n    gp_mapStyles.forEach(function (mapStyle, i) {\n      gp_map.mapTypes.set(mapStyleIds[i], mapStyle.map);\n    }); // gp_map.setMapTypeId('map_style');\n    //Init places services\n\n    placesService = new google.maps.places.PlacesService(gp_map); // OSM Tiles\n\n    gp_map.mapTypes.set('OSM', new google.maps.ImageMapType({\n      getTileUrl: function getTileUrl(coord, zoom) {\n        return gp_DOMPurify.sanitize('http://tile.openstreetmap.org/' + zoom + '/' + coord.x + '/' + coord.y + '.png');\n      },\n      tileSize: new google.maps.Size(256, 256),\n      name: 'Open Street Map',\n      maxZoom: 18\n    })); // Add layers\n\n    gp_traffic = new google.maps.TrafficLayer(); //Add drawing control\n\n    gp_drawingManager = new google.maps.drawing.DrawingManager({\n      drawingMode: google.maps.drawing.OverlayType.MARKER,\n      drawingControl: false,\n      drawingControlOptions: {\n        position: google.maps.ControlPosition.TOP_CENTER,\n        drawingModes: [google.maps.drawing.OverlayType.POLYGON, google.maps.drawing.OverlayType.POLYLINE, google.maps.drawing.OverlayType.RECTANGLE, google.maps.drawing.OverlayType.CIRCLE, google.maps.drawing.OverlayType.POLYLINE]\n      },\n      markerOptions: {\n        icon: 'http://www.example.com/icon.png'\n      },\n      polygonOptions: {\n        fillColor: '#EFFF79',\n        fillOpacity: 0.2,\n        strokeWeight: 1.5,\n        clickable: true,\n        zIndex: 1,\n        editable: true,\n        draggable: false\n      },\n      polylineOptions: {\n        strokeColor: '#B0C040',\n        strokeOpacity: 0.8,\n        strokeWeight: GP_POLYLINE_STROKE,\n        clickable: true,\n        zIndex: 1,\n        editable: true,\n        draggable: false\n      },\n      rectangleOptions: {\n        fillColor: '#EFFF79',\n        fillOpacity: 0.2,\n        strokeWeight: 1.5,\n        clickable: true,\n        zIndex: 1,\n        editable: true,\n        draggable: false\n      },\n      circleOptions: {\n        fillColor: '#EFFF79',\n        fillOpacity: 0.2,\n        strokeWeight: 1.5,\n        clickable: true,\n        zIndex: 1,\n        editable: true,\n        draggable: false\n      }\n    }); //Add event listener when a polygon is added to the map after drawing is complete\n\n    google.maps.event.addListener(gp_drawingManager, 'overlaycomplete', function (e) {\n      gp_shapeAddedToMap(e.overlay, e.type); //Update the list of layers on the map\n\n      angular.element('#ngApp').scope().$broadcast('layersChanged', {\n        doApply: true\n      });\n      gp_isDrawingMode = false;\n    }); // Event listener on zoom change to correct the zoom if needed\n\n    google.maps.event.addListener(gp_map, 'zoom_changed', function () {\n      zoomChangeBoundsListener = google.maps.event.addListener(gp_map, 'bounds_changed', function (event) {\n        if (this.getZoom() > gp_bestFitMaxZoom && gp_forceBestFitMaxZoom) {\n          this.setZoom(gp_bestFitMaxZoom);\n          gp_forceBestFitMaxZoom = false;\n        }\n\n        google.maps.event.removeListener(zoomChangeBoundsListener);\n      });\n    }); //Event listener for right click\n\n    google.maps.event.addListener(gp_map, 'rightclick', function (e) {\n      gp_openRigthClickMenu(e); //Open the right click menu\n    }); // Long press support for tablet running desktop mode\n\n    gp_isMouseUp = false;\n    gp_isLongPress = false;\n    gp_addLongPressListeners(gp_map); //Event listener for left click to hide right click menu\n\n    google.maps.event.addListener(gp_map, 'click', function (e) {\n      if (gp_isLongPress) return;\n\n      if (gp_mapMode == 'measureDistance') {\n        gp_rulerTool.addPinToRuler(e); // map.distance.js\n      } else {\n        gp_map.set('disableDoubleClickZoom', false); //Enable double click zoom again\n        //Hide the context menu.\n\n        jQuery('#mapContextMenu').hide();\n        gp_closeInfoWindow(false); // close info window\n      }\n    }); //Event listener for bounds change to hide right click menu\n\n    google.maps.event.addListener(gp_map, 'bounds_changed', function (e) {\n      //Hide the context menu.\n      jQuery('#mapContextMenu').hide();\n    }); //Event listner for map type change\n\n    google.maps.event.addListener(gp_map, 'maptypeid_changed', function (e) {\n      //Update shadow boxes map controls\n      var mapType = gp_map.getMapTypeId();\n\n      if (mapType == 'sat' || mapType == 'satellite' || mapType == 'hyb' || mapType == 'hybrid') {\n        jQuery('.mapControlTabInner').addClass('mapControlDarkShadow');\n        jQuery('.mapControlContent').addClass('mapControlContentDarkShadow');\n        gp_events.emit('changeSettingsHelpIconColor', 'white');\n      } else {\n        jQuery('.mapControlTabInner').removeClass('mapControlDarkShadow');\n        jQuery('.mapControlContent').removeClass('mapControlContentDarkShadow');\n        gp_events.emit('changeSettingsHelpIconColor', 'black');\n      } //Update the map type on user custom settings\n\n\n      var object = {};\n      object[nameSpacePrefix + 'Map_Type__c'] = gp_map.getMapTypeId();\n      Visualforce.remoting.Manager.invokeAction(gpRemoteAction, 'Map_Controller.updateUserSettings', {\n        userSetting: JSON.stringify(object)\n      }, function (result, event) {//Nothing to do here\n      }, {\n        escape: true,\n        timeout: 120000\n      }); //Trigger map resize event to re-align map pan/zoom controls\n\n      google.maps.event.trigger(gp_map, 'resize');\n    }); //Add event listener to show/hide map controls on enter and exit of street view\n\n    var thePanorama = gp_map.getStreetView();\n    google.maps.event.addListener(thePanorama, 'visible_changed', function () {\n      if (thePanorama.getVisible()) {\n        //Hide the map control tabs\n        jQuery('.mapControlsWrapper').hide();\n        gp_events.emit('geopointeMapUtilitiesService', {\n          action: 'hideMapUtilities',\n          data: {\n            hideAll: true\n          }\n        });\n      } else {\n        jQuery('.mapControlsWrapper').show();\n        gp_events.emit('geopointeMapUtilitiesService', {\n          action: 'showMapUtilities',\n          data: {\n            showAll: true\n          }\n        });\n      }\n    }); //Event lisnter for zoom change\n\n    google.maps.event.addListener(gp_map, 'zoom_changed', function (e) {\n      //Hide info window if it is for a cluster as clusters will be changed on zoom\n      if (gp_infoWindow.markerId == 'cluster') {\n        gp_closeInfoWindow(false);\n      }\n    }); //Event listener for user drag\n\n    google.maps.event.addListener(gp_map, 'dragend', function (e) {\n      //User has moved the map, centerpoint address should change\n      gp_mapManualMove();\n    }); //Create jquery event listner for map control panel so that if user moves map gp_centerPointKeepAddress is set to false, this is brittle has google may change markup\n\n    jQuery('#mapDIV').on('click', 'div [title*=\"Pan\"]', function () {\n      gp_mapManualMove();\n    }); // Key Drag Zoom\n\n    gp_map.enableKeyDragZoom({\n      key: 'shift',\n      boxStyle: {\n        border: 'medium dashed red',\n        opacity: 0.8\n      },\n      paneStyle: {\n        backgroundColor: 'transparent',\n        opacity: 0.0\n      },\n      visualEnabled: false,\n      visualPosition: google.maps.ControlPosition.RIGHT_TOP,\n      visualPositionOffset: new google.maps.Size(0, 10),\n      visualPositionIndex: null,\n      visualSprite: 'https://maps.gstatic.com/mapfiles/ftr/controls/dragzoom_btn.png',\n      visualSize: new google.maps.Size(20, 20),\n      visualTips: {\n        off: 'Turn on',\n        on: 'Turn off'\n      },\n      visualClass: 'gpDragZoom'\n    }); //Event listner to call mapManualMove if someone use the shift drag zoom functionality\n\n    var dz = gp_map.getDragZoomObject();\n    google.maps.event.addListener(dz, 'dragend', function (bnds) {\n      gp_mapManualMove();\n    }); // Add fullscreen component to map control panel\n\n    const fullscreenControlDiv = document.createElement('div');\n    const fullscreenCSS = {\n      margin: '10px 10px 10px 0px',\n      cursor: 'pointer',\n      position: 'relative',\n      height: '40px',\n      width: '40px',\n      'background-color': 'white'\n    };\n    Object.assign(fullscreenControlDiv.style, fullscreenCSS);\n    fullscreenControlDiv.id = 'fullscreenControllerContainer';\n    fullscreenControlDiv.className = 'fullscreen-control-wrapper';\n    fullscreenControlDiv.index = 0;\n    gp_map.controls[google.maps.ControlPosition.TOP_RIGHT].push(fullscreenControlDiv);\n    window.gp_events.emit('mountComponents', [{\n      name: 'fullscreenController',\n      selector: '#fullscreenControllerContainer',\n      data: fullscreenControlDiv\n    }]); // Add my location component to map control panel\n\n    if (navigator.geolocation != null) {\n      const mlControllerDiv = document.createElement('div');\n      const mlControllerCSS = {\n        margin: '0px 10px 0px 0px',\n        cursor: 'pointer',\n        position: 'relative',\n        height: '40px',\n        width: '40px',\n        'background-color': 'white',\n        color: '#666666',\n        'text-align': 'center',\n        'font-size': '16px',\n        'line-height': '26px'\n      };\n      Object.assign(mlControllerDiv.style, mlControllerCSS);\n      mlControllerDiv.title = 'Center the map on your current location';\n      mlControllerDiv.id = 'myLocationControllerContainer';\n      mlControllerDiv.className = 'locationArrowWrapper';\n      mlControllerDiv.index = 2;\n      gp_map.controls[google.maps.ControlPosition.RIGHT_TOP].push(mlControllerDiv);\n      window.gp_events.emit('mountComponents', [{\n        name: 'myLocationController',\n        selector: '#myLocationControllerContainer',\n        data: mlControllerDiv\n      }]);\n    } // Add drawing control component to map control panel\n\n\n    const drawingControlsDiv = document.createElement('div');\n    drawingControlsDiv.className = 'drawingControls';\n    drawingControlsDiv.id = 'drawingController';\n    drawingControlsDiv.index = 3;\n    gp_map.controls[google.maps.ControlPosition.RIGHT_TOP].push(drawingControlsDiv);\n    window.gp_events.emit('mountComponents', [{\n      name: 'drawingController',\n      selector: '#drawingController',\n      data: drawingControlsDiv\n    }]);\n    asyncGpEmitter('MixPanelService', {\n      action: 'trackMapLoad'\n    });\n  }\n\n  var urlParams = getURLparams();\n\n  if (!urlParams.center) {\n    // Set Center\n    if (thisMC.setCenter && !urlParams.routeid) {\n      gp_map.setCenter(new google.maps.LatLng(thisMC.centerLat, thisMC.centerLng));\n      gp_map.setZoom(thisMC.centerZoom);\n    } // GeoLocation\n\n\n    if (gp_userSettings.settings__c[nameSpacePrefix + 'Use_Geolocation__c'] && thisMC.entireDataSetAutoRun != true) {\n      if (navigator.geolocation != null) {\n        if (thisMC.centerByGeoLocation) {\n          gp_setCurrentPositionMarker(function (ctrPt) {\n            if (!urlParams.routeid) {\n              gp_map.setCenter(ctrPt);\n              gp_map.setZoom(11);\n            }\n          });\n        }\n      }\n    }\n  } //After map is created set the max height of the route table, my locations table, and layers table\n\n\n  setRouteTabHeights();\n  setDataSetTabMaxHeight();\n  setLayersTableMaxHeight();\n  setSearchTabMaxHeight();\n  setCalendarTabMaxHeight();\n} // helper for View on Google Maps\n\n\nfunction poiGoogleQueryLink(poi) {\n  let googleQueryLink = \"http://maps.google.com/?q=\".concat(poi.street ? \"\".concat(encodeURIComponent(poi.street || '') + ',' + encodeURIComponent(poi.city || '') + ',' + encodeURIComponent(poi.state || '') + ' ' + encodeURIComponent(poi.postalCode || '') + ' ' + encodeURIComponent(poi.countryISO || '')) : \"\".concat(parseFloat(poi.lat).toFixed(6) + ',' + parseFloat(poi.lng).toFixed(6)));\n  return googleQueryLink;\n} // build address (if possible) and map-action HTML from latLng for infoWindow\n\n\nfunction gp_showCurrentLocationInfoWindow() {\n  const payload = {\n    action: 'showCurrentLocationInfoWindow',\n    data: {}\n  };\n  asyncGpEmitter('InfoWindowService', payload);\n}\n\nfunction gp_poiCollections(jsAction) {\n  var _poiCollections$, _poiCollections$$qo, _poiCollections$$qo$t;\n\n  //Update the gp_dataSetSearches object\n  gp_updateDataSearchesObject(jsAction);\n  gp_bounds = new google.maps.LatLngBounds();\n  const {\n    poiCollections,\n    searchType,\n    searchNearbyDriveCalc\n  } = jsAction; // Quick loop through the POI Collections to determine if we should bestFit and/or remove shapes at the end\n\n  gp_bestFitMaxZoom = 3;\n  let toBestFit = false; // assume we are not doing bestFit\n\n  let isAutoRefresh = false;\n  let toRemoveAllShapes = poiCollections.length === 0 ? false : true; // Don't touch the points if there are no poiCollection else sassume we are removing them\n\n  poiCollections.forEach(poiCollection => {\n    const {\n      removeAllShapes,\n      bestFit,\n      searchContext,\n      bestFitMaxZoom\n    } = poiCollection; // Determine if we are removing shapes\n\n    if (!removeAllShapes) toRemoveAllShapes = false; // Determine if we are doing Best Fit\n\n    if (bestFit) toBestFit = true;\n    if (searchContext && searchContext.options && searchContext.options.isAutoRefresh) isAutoRefresh = true; // Figure max bestFitMaxZoom\n\n    if (gp_bestFitMaxZoom < bestFitMaxZoom) gp_bestFitMaxZoom = bestFitMaxZoom;\n  }); // Removing markers and add back the center one if one exists\n\n  if (toRemoveAllShapes) {\n    // Remove shapes and clear the global vars\n    gp_cleanMapObjects(); // Destroy the jQuery Data Tables\n\n    gp_destroyDataTables('gp_dataTables'); //Reset object that keeps track of selected records\n\n    gp_selectedRecords = {}; // Add the center one back\n\n    if (gp_masterMarker != null) {\n      gp_masterMarker.setMap(gp_map); // Add back onto the map\n\n      gp_bounds.extend(gp_masterMarker.getPosition()); // Extend the bounds object so we can do bestFit later\n      // Add them using the uniqueId as an Index so we can interact with them outside the map\n\n      if (gp_masterMarker.uniqueID != null) {\n        gp_markers[gp_masterMarker.uniqueID] = gp_masterMarker;\n      }\n    }\n  } // Loop through each poiCollection\n\n\n  poiCollections.forEach(poiCollection => {\n    poiCollection.searchType = searchType;\n    poiCollection.sfdcObject = ''; // Check if we have in POIs in the collection\n\n    const containsPOIs = Array.isArray(poiCollection.POIs) && poiCollection.POIs.length ? true : false; // Determine whether we should create the table\n\n    let createTable = poiCollection.collectionName !== gp_centerPOICollectionName;\n    let tableCols; //Don't create a table if there are no pois\n\n    if (!containsPOIs) {\n      createTable = false;\n    }\n\n    if (createTable) {\n      jQuery('#gp_dataTablesNoData').hide(); // Hide the No Data message\n\n      gp_newDataTableStructure('gp_dataTables', poiCollection); // Add new jQuery Data Table structure\n\n      tableCols = gp_defineDataTableColumns(poiCollection); // Prepare the columns array for use in creating the data table\n    } // Loop over data and add POIS / rows to table\n\n\n    const tableData = [];\n\n    if (containsPOIs) {\n      poiCollection.POIs.forEach((poi, index) => {\n        let poiObject = {};\n\n        try {\n          poiObject = gp_finishPOIObject(poi); //TODO perf 2500ms\n\n          poiObject.poicCollectionName = poiCollection.collectionName;\n          poiCollection.sfdcObject = poiObject.sfdcObject;\n          poiObject.markerIndex = index + 1; // Archive off the centerPOI\n\n          if (poiObject.uniqueId == gp_centerPOICollectionName) {\n            gp_centerPOI = poiObject;\n            gp_radialSearchCenter = {\n              lat: gp_centerPOI.lat,\n              lng: gp_centerPOI.lng,\n              recordId: gp_centerPOI.recordId\n            };\n          }\n\n          gp_handlePOI(poiCollection, poiObject); // Add a row of data to the data table array\n\n          if (createTable) {\n            tableData.push(gp_defineDataTableRow(poiCollection, poiObject));\n          }\n\n          poiObject.tableData.rowIndex = index;\n          poiObject.tableData.tableCols = tableCols;\n          poiObject = null;\n        } catch (exc) {\n          let poiErrMsg = '';\n\n          if (poiObject) {\n            const {\n              title,\n              sObject\n            } = poiObject;\n            poiErrMsg = \"Error on record \".concat(title ? \"'\".concat(title, \"'\") : sObject ? \"ID \".concat(sObject.id) : '').concat(exc.message ? \": \".concat(exc.message) : '');\n          }\n\n          throw new Error(gp_DOMPurify.sanitize(poiErrMsg));\n        }\n      }); // }\n    } // create circle overlay\n\n\n    if (poiCollection.searchType == 'nearbyRadial' && typeof poiCollection.searchNearbyRange != 'undefined' && typeof poiCollection.searchNearbyLat != 'undefined' && typeof poiCollection.searchNearbyLng != 'undefined' && jsAction.searchNearbyShowOverlay) {\n      let radius = gp_milesToMeters(poiCollection.searchNearbyRange);\n\n      if (poiCollection.distanceUnits == 'kilometers' || poiCollection.distanceUnits == 'km' || poiCollection.distanceUnits == 'k') {\n        radius = poiCollection.searchNearbyRange * 1000;\n      }\n\n      const cirOptions = {\n        clickable: false,\n        //Disable clicks so right click event on map below opens context menu\n        strokeColor: '#B00303',\n        //'#B00303'; '#1797c0';\n        strokeOpacity: 0.75,\n        strokeWeight: 2,\n        fillColor: '#EFFF79',\n        //'#EFFF79'; '#1797c0';\n        fillOpacity: 0.0,\n        map: gp_map,\n        center: new google.maps.LatLng(poiCollection.searchNearbyLat, poiCollection.searchNearbyLng),\n        radius\n      };\n      const circle = new google.maps.Circle(cirOptions);\n      gp_cirOverlays[\"\".concat(poiCollection.collectionName, \"_overlay\")] = circle;\n      gp_bounds.union(circle.getBounds());\n    } // Initialize the Data Table\n\n\n    if (createTable) {\n      //Delay the creation of the table slightly, TODO WHY?!?!\n      setTimeout(() => {\n        //value is the POI collection in the larger jQuery loop, need to use this due do the way var are stored and used in timeout functions\n        gp_initDataTable(poiCollection, tableCols, tableData); // Calculate Drive Times\n\n        if (searchNearbyDriveCalc) {\n          gp_showDriveDistanceColumn(poiCollection.collectionName, poiCollection.distanceUnits); //gp_calcDriveTimes(value.collectionName, value.distanceUnits);\n        } //Add same location markers, need to do this after table is created as this is the data source\n\n\n        gp_createSameLocationMarkers();\n        google.maps.event.trigger(gp_map, 'resize');\n      }, 50);\n    }\n  }); // end of loop through each poiCollection\n  //Show the markers on the map, do this in seperate javascript thread with timeout as it is browser intensive\n\n  setTimeout(() => {\n    //Restoring a data set search is the same as adding it so we can use this method of initial add after search is performed\n    poiCollections.forEach(_ref => {\n      let {\n        collectionName\n      } = _ref;\n      return collectionName ? gp_restoreDataSetSearchOnMap(collectionName, true) : null;\n    });\n  }, 50); //If there are shapes on the map make sure they are included in the bounds calculation so the map zoom contains entire shape\n\n  Object.values(polygonObjects).forEach(polygonObject => {\n    const bounds = polygonObject.getBounds();\n    gp_bounds.extend(new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng()));\n    gp_bounds.extend(new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng()));\n  });\n\n  if (((_poiCollections$ = poiCollections[0]) === null || _poiCollections$ === void 0 ? void 0 : (_poiCollections$$qo = _poiCollections$.qo) === null || _poiCollections$$qo === void 0 ? void 0 : (_poiCollections$$qo$t = _poiCollections$$qo.theNewDs) === null || _poiCollections$$qo$t === void 0 ? void 0 : _poiCollections$$qo$t.scorecardMetric) != null) {\n    var _poiCollections$2;\n\n    /* Emitting to the Angular 2+ component factory to build the metric component and sending over the required data\n       this runs on a hideLayers toggle so we must prevent the component from rebuilding aswell.\n    */\n    if (!((_poiCollections$2 = poiCollections[0]) !== null && _poiCollections$2 !== void 0 && _poiCollections$2.isScorecardHidden)) {\n      gp_events.emit('mountComponents', [{\n        name: 'levelElevenMapMetricLayer',\n        selector: '#levelElevenMapMetricLayer',\n        data: gp_dataSetSearches\n      }]);\n      gp_events.emit('scorecardLayerChange', {\n        action: 'showLayerBasedOnFilter',\n        data: {\n          layer: poiCollections\n        }\n      });\n    }\n  } // Best Fit\n\n\n  if (toBestFit && !isAutoRefresh) {\n    gp_forceBestFitMaxZoom = true;\n    gp_centerZoom();\n  } //Build the list actions\n\n\n  buildListActions(); //map.actions.js\n} //Take an object as input and process the POI onto the map\n\n\nfunction gp_handlePOI(poiCollection, poi) {\n  if (!poi.isBlankLat && !poi.isBlankLng) {\n    //If there is salesforceObject property, move to sObject\n    if (poi.salesforceObject) {\n      poi.sObject = makeObjectKeysLowerCase(poi.salesforceObject);\n    } // Make Lat Lon Object\n\n\n    const g_latlon = new google.maps.LatLng(poi.latDisplay, poi.lngDisplay); // Extend the bounds object so we can do bestFit later\n\n    gp_bounds.extend(g_latlon); // Build the InfoContentHTML\n\n    const tmpInfoContentHTML = \"<div class=\\\"poiActions\\\"></div>\";\n    let hoverText = gp_escapeHtml(poi.title);\n\n    if (poi.title2 != '') {\n      hoverText = \"<strong>\".concat(gp_escapeHtml(poi.title), \"</strong><br/>\").concat(gp_escapeHtml(poi.title2));\n    } // provide a marker value for records lacking label-by value\n\n\n    if ('label' == poi.markerType && !poi.labelByFieldText) {\n      poi.labelByFieldText = 'No Value';\n    }\n\n    const image = {\n      type: poi.markerType\n    }; // SECURITY: gp_createMarker must be called with sanitized html (3rd parameter). tmpInfoContentHTML was sanitized during its construction above\n\n    const g_marker = gp_createMarker(g_latlon, hoverText, tmpInfoContentHTML, image, poi.uniqueId, null, poi.labelByFieldText); //TODO perf 300ms\n    //Set the collectionName property on the marker object so we can keep track of what markers belong to each data set search\n\n    g_marker.collectionName = poi.poicCollectionName;\n    g_marker.sObject = poi.sObject;\n    g_marker.recordId = poi.recordId;\n    g_marker.recordTypeId = poi.recordTypeId;\n    g_marker.gp_title = poi.title;\n    g_marker.gp_title2 = poi.title2;\n    g_marker.gp_distanceInfo = poi.distanceInfo;\n    g_marker.gp_additionalFields = poi.additionalFields;\n    g_marker.gp_sfdcObject = poi.sfdcObject;\n    g_marker.gp_geocodeQuality = poi.geocodeQuality;\n    g_marker.gp_tableData = poi.tableData = poi.tableData || {};\n    g_marker.markerIndex = poi.markerIndex;\n    g_marker.markerType = poi.markerType;\n    g_marker.poiReferenceObject = _.cloneDeep(poi); //Set flat to determin if labels are displayed\n\n    if (poi.labelByFieldText) {\n      gp_dataSetSearches[poi.poicCollectionName].markerLabelsVisible = true;\n    } // Add them to the main object using the uniqueId as an Index so we can interact with them outside the map\n\n\n    if (poi.uniqueId != '') {\n      gp_markers[poi.uniqueId] = g_marker;\n    } // Save off the centerPOI marker\n\n\n    if (poi.poicCollectionName == gp_centerPOICollectionName) {\n      gp_masterMarker = g_marker;\n    } //If this poi has shapes associated with it add those to the map\n\n\n    const shapes = poiCollection.shapeMap[poi.recordId];\n\n    if (Array.isArray(shapes)) {\n      //Record could have more that one shape so loop through and add to map\n      shapes.forEach(shape => {\n        //Create a new polygon overlay\n        let shapeOverlay;\n        const shapeOptions = {\n          fillColor: shape.color,\n          fillOpacity: shape.opacity,\n          strokeWeight: 1.5,\n          clickable: true,\n          zIndex: 2,\n          editable: false,\n          draggable: false\n        };\n        const isPolyline = shape.type && shape.type.toLowerCase() == 'polyline';\n        const isPolygon = shape.type && shape.type.toLowerCase() == 'polygon';\n        const isCircle = shape.type && shape.type.toLowerCase() == 'circle';\n        const isGeoshape = shape.type && shape.type.toLowerCase() == 'multipolygon';\n\n        if (isPolygon || isPolyline) {\n          //Decode the lat lng string\n          let latLngs = [];\n          let coordArrays = null;\n\n          if (shape.coordinates && shape.coordinates.search(/^\\s*\\[\\s*\\[\\s*\\[/) == 0) {\n            //Stored in GeoJSON format\n            coordArrays = JSON.parse(shape.coordinates); // first array of lng lats is the outer ring of the main shape\n\n            coordArrays[0].forEach(_ref2 => {\n              let [lng, lat] = _ref2;\n              return latLngs.push(new google.maps.LatLng(lat, lng));\n            });\n          } else {\n            latLngs = google.maps.geometry.encoding.decodePath(shape.coordinates);\n          }\n\n          if (isPolyline) {\n            shapeOptions.path = latLngs; // polyline has only one\n\n            shapeOptions.strokeColor = shape.color;\n            shapeOptions.strokeOpacity = shape.opacity;\n            shapeOptions.strokeWeight = GP_POLYLINE_STROKE;\n          } else {\n            shapeOptions.paths = latLngs; // polygon may have several\n          }\n\n          shapeOverlay = isPolyline ? new google.maps.Polyline(shapeOptions) : new google.maps.Polygon(shapeOptions);\n          shapeOverlay.gpProperties = {};\n\n          if (Array.isArray(coordArrays) && coordArrays.length > 1) {\n            // if there were holes / extra pieces, set up to display them\n            shapeOverlay.gpProperties.innerRings = {};\n            shapeOverlay.gpProperties.outerRingsToInnerRings = {\n              0: []\n            };\n            const paths = [latLngs];\n            coordArrays.forEach((innerRingArray, index) => {\n              // Skip the first index since we already set it up above\n              if (index === 0) return;\n              const innerLatLngs = [];\n              innerRingArray.forEach(_ref3 => {\n                let [lng, lat] = _ref3;\n                return innerLatLngs.push(new google.maps.LatLng(lat, lng));\n              });\n              paths.push(innerLatLngs);\n              const pathIndex = pathIndex;\n              shapeOverlay.gpProperties.innerRings[pathIndex] = true;\n              shapeOverlay.gpProperties.outerRingsToInnerRings[index] = [pathIndex];\n            });\n            shapeOverlay.setPaths(paths);\n          }\n        } else if (isCircle) {\n          //Determing radius in meters\n          let radius = JSON.parse(JSON.stringify(shape.radius)); //Copy radius by value, not reference\n\n          if (shape.units == 'm' || shape.units == 'miles' || shape.units == 'Miles') {\n            radius = shape.radius * 1.60934;\n          }\n\n          radius = radius * 1000; //convert to meters\n\n          shapeOptions.radius = radius; //If lat/lng was defined on the Shape__c object use that, other wise use lat/lng from record\n\n          if (shape.centerLat && shape.centerLng) {\n            shapeOptions.center = new google.maps.LatLng(shape.centerLat, shape.centerLng);\n          } else {\n            shapeOptions.center = new google.maps.LatLng(poi.lat, poi.lng);\n          } //Create a new circle overlay\n\n\n          shapeOverlay = new google.maps.Circle(shapeOptions);\n          shapeOverlay.gpProperties = {};\n          shapeOverlay.gpProperties.centerLabel = shape.centerLabel;\n          shapeOverlay.gpProperties.range = shape.radius;\n        } else if (isGeoshape) {\n          //This are currently only geoshape fields\n          const suppressToastAndZoom = true;\n          gp_addShapeIdToMap(shape.sfdcId, result => {\n            //Loop through all the polygons on the map and update the properties\n            if (result) {\n              Object.values(polygonObjects).forEach(shapeOverlay => {\n                if (!shapeOverlay.gpProperties || shapeOverlay.gpProperties.groupLayerId != result.groupLayerId) {\n                  return;\n                }\n\n                updateShapeOverlayGPProperties(shapeOverlay, poiCollection, poi, shape);\n              });\n            }\n          }, suppressToastAndZoom);\n        } //Set the saved properties on the overlay shape object, shape was added synchronously for polygon and circl\n\n\n        if (isPolygon || isPolyline || isCircle) {\n          updateShapeOverlayGPProperties(shapeOverlay, poiCollection, poi, shape); //Add the shape to map\n\n          shapeOverlay.setMap(gp_map);\n          var shapeBounds = shapeOverlay.getBounds();\n          gp_bounds.extend(shapeBounds.getNorthEast());\n          gp_bounds.extend(shapeBounds.getSouthWest()); //Call polygon added to map method, make sure it is added to polygon Objects array\n\n          gp_shapeAddedToMap(shapeOverlay, shape.type.toLowerCase());\n        }\n      });\n    }\n\n    function updateShapeOverlayGPProperties(shapeOverlay) {\n      let poiCollection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let poi = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      let shape = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      if (shapeOverlay && shapeOverlay.gpProperties) {\n        shapeOverlay.gpProperties.sfdcId = shape.sfdcId;\n        shapeOverlay.gpProperties.sfdcName = shape.name;\n        shapeOverlay.gpProperties.sfdcDescription = shape.description ? shape.description : '';\n        shapeOverlay.gpProperties.relatedRecordName = poi.title;\n        shapeOverlay.gpProperties.relatedRecordId = poi.recordId;\n        shapeOverlay.gpProperties.usageType = 'Shape Field';\n        shapeOverlay.gpProperties.gpCollectionName = poiCollection.collectionName;\n        shapeOverlay.gpProperties.relatedRecordFieldName = shape.relatedRecordFieldName;\n        shapeOverlay.gpProperties.relatedRecordFieldLabel = shape.relatedRecordFieldLabel;\n        shapeOverlay.gpProperties.readOnly = shape.readOnly;\n        shapeOverlay.gpProperties.units = shape.units;\n        shapeOverlay.gpProperties.recordLat = poi.lat;\n        shapeOverlay.gpProperties.recordLng = poi.lng;\n        shapeOverlay.gpProperties.gpPoiId = poi.uniqueId;\n        shapeOverlay.gpProperties.usedInAssignments = shape.usedInAssignments;\n      }\n    }\n  }\n\n  return null;\n} //Creates and returns a map marker\n// SECURITY: htmlPreSanitized must be sanitized before being passed to this function\n\n\nfunction gp_createMarker(latlng, title, htmlPreSanitized, image, uid, place, maplabel) {\n  // Create traditional marker\n  const marker = new google.maps.Marker({\n    position: latlng,\n    flat: true,\n    type: image.type\n  }); // Add custom properties to it\n\n  marker.tooltip = \"<div class=\\\"gp_tooltip nowrap\\\" notranslate>\".concat(DOMPurify.sanitize(title), \"</div>\");\n  marker.tooltipDetail = '';\n\n  if (htmlPreSanitized) {\n    marker.tooltipDetail = htmlPreSanitized.substring(0, htmlPreSanitized.indexOf('<div class=\"poiActions\">'));\n  }\n\n  marker.infoWindowHTML = htmlPreSanitized;\n  marker.uniqueID = uid; // Marker Click Event\n\n  if (!place) {\n    google.maps.event.addListener(marker, 'click', () => {\n      const {\n        uniqueID\n      } = marker; //If we are in record selection mode perform special handling from record clicks\n\n      if (gp_inRecordSelectionMode && uniqueID != 'gp_mapCenterPoi' && uniqueID != 'centerPOI') {\n        gp_toggleRecordSelection(uniqueID);\n      } else {\n        gp_closeInfoWindow(false);\n        gp_openPoiInfoMarker(uniqueID);\n      }\n\n      gp_tooltip.hide();\n    });\n  } else {\n    google.maps.event.addListener(marker, 'click', () => gp_placesInfoWindowHandler(place));\n  } // Marker Mouseover Event\n\n\n  google.maps.event.addListener(marker, 'mouseover', () => {\n    const {\n      uniqueID,\n      type,\n      sObject,\n      tooltip,\n      poi,\n      dataLayer,\n      position\n    } = marker;\n    const ttOptions = {\n      content: '',\n      boxClass: 'gp_tooltip_parent',\n      closeBoxURL: '',\n      isHidden: true\n    };\n    gp_tooltip.setOptions(ttOptions); // reset to avoid cross-contamination of styles with gm_infoWindow\n\n    if (gp_inRecordSelectionMode) {\n      const newInfoWindowIds = ['gp_mapCenterPoi', 'gp_mapSearchPoi', 'gp_currentLocation', 'gp_recordSearchPoi'];\n\n      if (sObject || newInfoWindowIds.includes(uniqueID) || type === 'Location') {\n        let payload;\n\n        if (uniqueID === 'gp_currentLocation') {\n          payload = {\n            action: 'showCurrentLocationInfoWindow',\n            data: {}\n          };\n        } else {\n          payload = {\n            action: 'openPoiInfoMarker',\n            data: {\n              markerID: uniqueID,\n              sameLocationMarker: false,\n              fromShape: '',\n              buildActions: false\n            }\n          };\n        }\n\n        asyncGpEmitter('InfoWindowService', payload);\n      } else {\n        gp_tooltip.setContent(angular.element('#modalListDirective').injector().get('dataLayerSearchService').buildInfoWindowHtml(poi, dataLayer));\n      }\n    } else {\n      gp_tooltip.pixelOffset_.height = 'label' === type || 'gp_currentLocation' === uniqueID ? 16 : 0; // don't let tooltip overlap label-only marker\n\n      gp_tooltip.setContent(tooltip);\n    } // pull any slightly off-map marker into bounds so that\n    // tooltip.open() doesn't make a radical grab to center\n\n\n    gp_map.getBounds().extend(position);\n    gp_tooltip.show();\n    gp_tooltip.open(gp_map, marker);\n  }); // Marker Mouseout Event\n\n  google.maps.event.addListener(marker, 'mouseout', () => {\n    if (gp_inRecordSelectionMode) {\n      const payload = {\n        action: 'closeInfoWindow',\n        data: {}\n      };\n      asyncGpEmitter('InfoWindowService', payload);\n    }\n\n    gp_tooltip.hide();\n  }); // if label text defined, create that graphic\n\n  if (maplabel) {\n    const mkrLabel = new MapLabel({\n      fontSize: 14,\n      strokeWeight: 5,\n      position: latlng,\n      text: maplabel,\n      zIndex: 102 // above polygons, below everything else\n\n    });\n    marker.mapLabel = mkrLabel;\n  }\n\n  return marker;\n}\n/**\n * Updates the marker's colors and the legend information\n * @param {String} collectionName string with the dataSet collectionName\n * @param {Object} colorMarkersOptions Options object that can show all markers or only color certain markers\n * @param {Boolean} colorMarkersOptions.showAllMarkers - oolean that will show all the markers even if hidden.\n * @param {String[]} colorMarkersOptions.markersToUpdate - array with marker id's to update\n */\n\n\nfunction gp_colorMarkers(collectionName, colorMarkersOptions) {\n  if (!collectionName) {\n    throw new Error('Invalid marker information');\n  }\n\n  const dataSet = gp_dataSetSearches[collectionName];\n  if (!dataSet) return;\n  const dataSetController = angular.element('.dataSetController');\n  const dataSetControllerScope = dataSetController.scope();\n  const dataSetControllerInjector = dataSetController.injector();\n  const dataLayerSearchService = dataSetControllerInjector.get('dataLayerSearchService');\n  const mapLegendService = dataSetControllerInjector.get('mapLegendService');\n  const {\n    currentMarkerMetaData: markerMetaData\n  } = dataSet;\n  const {\n    searchType,\n    qo,\n    name: dataSetName\n  } = dataSet;\n  let markersToUpdate = null;\n  let showMarkers = false;\n  let mapLegendIndex = -1;\n  if (colorMarkersOptions !== null && colorMarkersOptions !== void 0 && colorMarkersOptions.showAllMarkers) showMarkers = colorMarkersOptions.showAllMarkers;\n  if (colorMarkersOptions !== null && colorMarkersOptions !== void 0 && colorMarkersOptions.markersToUpdate) markersToUpdate = colorMarkersOptions.markersToUpdate; // MarkerMetaData object will be null for markers added from url params. For those we want to get the mapIconUrl directory from the poi in the collection\n\n  if (markerMetaData && !markerMetaData.color) {\n    markerMetaData.color = '003BFF'; // supply default dark blue in case stale-data clearance has wiped it\n  }\n\n  if ((markerMetaData === null || markerMetaData === void 0 ? void 0 : markerMetaData.color.indexOf('#')) == 0) {\n    markerMetaData.color = markerMetaData.color.substring(1, markerMetaData.color.length);\n  } // check if we are updating all the markers or just certain ones\n\n\n  if (!Array.isArray(markersToUpdate) && markerMetaData) {\n    // Get the current map Legend index\n    mapLegendIndex = mapLegendService.getLegendIndex(collectionName); // remove the legend if it exists and create a new one with the markerMetaData\n\n    mapLegendService.removeLegendGroup(collectionName);\n    dataSetControllerScope.createNewDataSetLegend(collectionName, {\n      name: dataSetName,\n      markerMetaData,\n      type: dataSet.searchType\n    }); // remove marker rule colors from dynamic color palette\n\n    if (markerMetaData) dataSetControllerScope.removeRulesFromPalette(markerMetaData.markerRules);\n  } // if this is an idArray search (i.e. search type is empty), check whether associated\n  // primary Map Object has a Default Icon defined, and if so, use it\n\n\n  let mapObjDefaultIconUrl = '';\n\n  if (!searchType && qo.moNew) {\n    const mo = qo.moNew;\n\n    if (mo.DefaultMarkerColor || mo.DefaultMarkerIcon || mo.DefaultMarkerText) {\n      mapObjDefaultIconUrl = gp_composeMarkerUrl(mo.DefaultMarkerColor, mo.DefaultMarkerIcon, mo.DefaultMarkerText);\n    }\n  }\n\n  let iconImgUrl = '';\n  const dataTable = jQuery(\"#\".concat(collectionName)).dataTable();\n  const dataTableSettings = dataTable.fnSettings(); // The dataTable might not exist for markers set from the `id` and `idArray` url params\n\n  if (dataTableSettings && markerMetaData) {\n    dataTableSettings.gp_mapIconColor = markerMetaData.color;\n  }\n\n  const markers = Object.values(gp_markers).filter(marker => {\n    if (marker.collectionName === collectionName) {\n      // Filter out any marker that is not in the update list if passed\n      if (Array.isArray(markersToUpdate) && !markersToUpdate.includes(marker.uniqueID)) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  }).map((marker, index) => {\n    var _markerColorInfo$mapI, _markerColorInfo$mapI2;\n\n    const markerColorInfo = gp_getMarkerColorInformation(marker, markerMetaData, collectionName, dataSetControllerScope, dataSetControllerInjector, dataLayerSearchService);\n    if (index === 0) iconImgUrl = DOMPurify.sanitize(markerColorInfo.mapIconURL).replace(/amp;/g, ''); //Set center pin icon if necesssary\n\n    if (markerColorInfo.mapIconURL == 'centerPin') {\n      markerColorInfo.mapIconURL = gpImg.center_pin2;\n    } else if (mapObjDefaultIconUrl) {\n      markerColorInfo.mapIconURL = mapObjDefaultIconUrl;\n    } //Extract the color from the URL and set this on the poi after the plus, https://api.geopointe.io/v1/markers/pin-l+F3D904.png\n\n\n    if (markerColorInfo !== null && markerColorInfo !== void 0 && (_markerColorInfo$mapI = markerColorInfo.mapIconURL) !== null && _markerColorInfo$mapI !== void 0 && _markerColorInfo$mapI.startsWith('http') && markerColorInfo !== null && markerColorInfo !== void 0 && (_markerColorInfo$mapI2 = markerColorInfo.mapIconURL) !== null && _markerColorInfo$mapI2 !== void 0 && _markerColorInfo$mapI2.startsWith(GEOPOINTE_API)) {\n      const mapIconPlusIndex = markerColorInfo.mapIconURL.indexOf('+');\n      markerColorInfo.mapIconColor = markerColorInfo.mapIconURL.substring(mapIconPlusIndex + 1, mapIconPlusIndex + 7);\n    } //If this is a center pin marker make it slightly larger than the rest\n\n\n    if (markerColorInfo.mapIconURL == gpImg.center_pin2) {\n      let useIconUrl = gpImg.center_pin2;\n      let upscaleWidth = 29; // we enlarge the center marker, and if we're using a custom image we need to square it up\n\n      let upscaleHeight = 48;\n\n      if (gp_dataSetSearches.centerPOI) {\n        if (gp_dataSetSearches.centerPOI.qo.moNew && (gp_dataSetSearches.centerPOI.qo.moNew.DefaultMarkerColor || gp_dataSetSearches.centerPOI.qo.moNew.DefaultMarkerIcon || gp_dataSetSearches.centerPOI.qo.moNew.DefaultMarkerText)) {\n          useIconUrl = gp_composeMarkerUrl(gp_dataSetSearches.centerPOI.qo.moNew.DefaultMarkerColor, gp_dataSetSearches.centerPOI.qo.moNew.DefaultMarkerIcon, gp_dataSetSearches.centerPOI.qo.moNew.DefaultMarkerText);\n\n          if (gp_dataSetSearches.centerPOI.qo.moNew.DefaultMarkerIcon.startsWith('http') && !gp_dataSetSearches.centerPOI.qo.moNew.DefaultMarkerIcon.startsWith(GEOPOINTE_API)) {\n            upscaleWidth = upscaleHeight = 48;\n          }\n        }\n      }\n\n      marker.setIcon({\n        url: useIconUrl,\n        scaledSize: new google.maps.Size(upscaleWidth, upscaleHeight),\n        anchor: new google.maps.Point(~~(0.5 * upscaleWidth), ~~(0.8 * upscaleHeight)),\n        type: markerColorInfo.markerType\n      });\n    } // If this is currentLocation, fix it up centered\n    else if (markerColorInfo.mapIconURL == gpImg.currentLocation) {\n        marker.setIcon({\n          url: gpImg.currentLocation,\n          scaledSize: new google.maps.Size(25, 25),\n          // This marker is 25 pixels wide by 40 pixels tall.\n          anchor: new google.maps.Point(12, 12),\n          type: markerColorInfo.markerType\n        });\n      } else {\n        let imgWidth = 20;\n        let imgHeight = 32;\n        let imgFloat = -2;\n\n        if (!markerColorInfo.mapIconURL.startsWith(GEOPOINTE_API)) {\n          // Custom icons are considered to be square, vs. the taller standard pin icons.\n          // Also, std. pins have a 'shadow' at the bottom which touches the label,\n          // while custom icons look too crowded if they touch where the shadow would.\n          imgWidth = 32;\n          imgHeight = 32;\n          imgFloat = 3;\n        }\n\n        marker.setIcon({\n          url: markerColorInfo.mapIconURL,\n          anchor: new google.maps.Point(11.5, imgHeight + imgFloat),\n          // The anchor for this image is just above the base of the image.\n          scaledSize: new google.maps.Size(imgWidth + 3, imgHeight + 3),\n          // All markers are 20 pixels wide. Include margin\n          type: markerColorInfo.markerType\n        });\n      }\n\n    if (showMarkers) {\n      marker.hiddenByLegend = false;\n      gp_showMarker(marker, collectionName, true);\n    }\n\n    return _objectSpread(_objectSpread({}, marker), {}, {\n      markerColorInfo\n    });\n  }).reduce((obj, marker) => {\n    const {\n      uniqueID\n    } = marker;\n    obj[uniqueID] = marker;\n    return obj;\n  }, {});\n\n  if ('centerPin' != iconImgUrl && iconImgUrl.indexOf(GEOPOINTE_API) == -1) {\n    // set up failover image in case custom icon URL doesn't load\n    const bindUpdate = function bindUpdate(colName, dsName, imgUrl, fallbackColor) {\n      // this function creates a closure which preserves passed-in loop variables after loop has exited\n      return function () {\n        jQuery.extend(toastr.options, {\n          timeOut: 60000\n        });\n        toastr.error(DOMPurify.sanitize(\"Custom marker image on Dataset '\".concat(dsName, \"' failed to load from URL: \").concat(imgUrl, \" <br /> Using default markers.\")));\n        Object.values(gp_markers).forEach(marker => {\n          if (marker.collectionName == colName) {\n            marker.icon.url = DOMPurify.sanitize(\"\".concat(GEOPOINTE_API, \"/v1/markers/pin-l+\").concat(fallbackColor, \".png\"));\n            marker.icon.scaledSize.height += 12;\n            marker.icon.anchor.y += 12;\n          }\n        });\n        gp_restoreDataSetSearchOnMap(colName);\n      };\n    };\n\n    const testImg = new Image();\n    testImg.onerror = bindUpdate(collectionName, dataSetName, iconImgUrl, markerMetaData.color); // set .src last, after setting up error listener\n\n    testImg.src = iconImgUrl;\n  } // The dataTable might not exist for markers set from the `id` and `idArray` url params\n\n\n  if (dataTableSettings) {\n    const markerColorId = guid();\n    setTimeout(() => {\n      dataTable.fnGetData().forEach((row, index) => {\n        const [rowMarkerId] = row;\n        const marker = markers[rowMarkerId];\n\n        if (marker) {\n          const {\n            markerColorInfo\n          } = marker;\n          dataTable.fnUpdate(markerColorInfo.mapIconURL, index, gp_ColumnInfo.mapIconURLDataTable, false, false);\n          dataTable.fnUpdate(markerColorInfo.mapIconURL, index, gp_ColumnInfo.mapIconURL, false, false);\n          dataTable.fnUpdate(markerColorInfo.mapIconColor, index, gp_ColumnInfo.mapIconColor, false, false); // In order to actually update the marker in the dataTable we need to update the actions column as well. We created a fake dynamic string with guid() and set it here\n\n          dataTable.fnUpdate(markerColorId, index, gp_ColumnInfo.actions, false, false);\n        }\n      });\n      buildChart(collectionName, false);\n    }, 400);\n  } // If the legend was in a certain position before, set it back to that location;\n\n\n  if (markerMetaData && mapLegendIndex !== -1) {\n    mapLegendService.setLegendIndex(collectionName, mapLegendIndex);\n  } // Update the legend layers after we update the dataset controller scope, this will apply the changes in the legend\n\n\n  setTimeout(() => {\n    dataSetControllerScope.$apply();\n  }, 1);\n  angular.element('#ngApp').scope().$broadcast('layersChanged', {\n    doApply: true\n  }); // Only calculate the records if the user is adding a dataSet\n\n  if (markerMetaData && !dataSetController.openingMSE) {\n    calcRecordsInShapes();\n  }\n}\n\nfunction gp_getMarkerColorInformation(marker, markerMetaData, collectionName, dataSetController, dataSetControllerInjector, dataLayerSearchService) {\n  // If there is no markerMetaData then get the markerColor information from the marker itself\n  if (!markerMetaData) {\n    const {\n      poiReferenceObject: poi\n    } = marker;\n    const {\n      mapIconURL,\n      mapIconText,\n      mapIconColor\n    } = poi;\n    return {\n      mapIconURL,\n      mapIconText,\n      mapIconColor\n    };\n  } else {\n    let {\n      color,\n      colorByField,\n      multiRuleFields,\n      markerType\n    } = markerMetaData;\n    const {\n      sObject,\n      mapObjectIsExternalObject,\n      poiReferenceObject: poi\n    } = marker;\n    const mapIconColor = color;\n    let mapIconURL = getMapIconURL(color);\n    let colorByFieldValue = null;\n    let multiRuleFieldValues = null;\n\n    if (colorByField && colorByField.field) {\n      let fieldName = colorByField.field;\n\n      if (gp_orgSettings.multiCurrency && gp_isConvertibleCurrField(colorByField, mapObjectIsExternalObject)) {\n        fieldName = gp_convCurrAlias(fieldName);\n      }\n\n      colorByFieldValue = getDescendantProp(sObject, fieldName); // deleted call to dataSetController.getColorByDateValue, doesn't work if it's there, and i don't think it ever\n      // got called since it was checking options.colorByType but the type is actually stored in options.colorByFieldType\n    } else if (multiRuleFields && multiRuleFields.length > 0) {\n      multiRuleFieldValues = multiRuleFields.map(f => {\n        if (gp_orgSettings.multiCurrency && gp_isConvertibleCurrField(f, mapObjectIsExternalObject)) return gp_convCurrAlias(f.field);else return f.field;\n      }).map(getDescendantProp.bind(null, sObject));\n    }\n\n    if (markerType !== 'label') {\n      if (markerMetaData.multiRuleFields && markerMetaData.multiRuleFields.length > 0) {\n        poi.multiRuleFieldValues = multiRuleFieldValues; // don't dump the DSC.tempColorPalette (we used to), to allow dynamically-assigned colors like single-rule\n\n        const multiRule = markerMetaData.multiRuleFields.reduce((rule, field, index) => {\n          const multiRuleFieldValue = multiRuleFieldValues[index];\n          const {\n            markerIndicator\n          } = field;\n          poi.colorByFieldValue = multiRuleFieldValue;\n          const relatedRule = dataSetController.getMarkerRule(collectionName, poi, field);\n          if (relatedRule.isOther) relatedRule.value = 'Other';\n          rule[markerIndicator] = relatedRule[markerIndicator];\n          if (markerIndicator === 'icon') rule.text = relatedRule.text;\n          rule.value += \"\".concat(dataSetController.getRuleValue(relatedRule, field, multiRuleFieldValue), \" / \");\n          return rule;\n        }, {\n          value: ''\n        });\n        multiRule.value = multiRule.value.slice(0, multiRule.value.length - 3);\n        mapIconURL = dataLayerSearchService.resolveMarkerUrl(multiRule);\n        dataSetControllerInjector.get('mapLegendService').add({\n          poi,\n          value: multiRule.value,\n          url: mapIconURL\n        });\n      } else {\n        poi.colorByFieldValue = colorByFieldValue;\n        let markerNumber = null;\n\n        if (gp_userSettings.settings__c[nameSpacePrefix + 'Number_Map_Pins__c'] == true) {\n          markerNumber = marker.markerIndex;\n        }\n\n        mapIconURL = dataLayerSearchService.resolveMarkerUrl(dataSetController.getMarkerRule(collectionName, poi, null, markerNumber));\n      }\n    }\n\n    return {\n      mapIconColor,\n      colorByFieldValue,\n      multiRuleFieldValues,\n      color,\n      markerType,\n      mapIconURL\n    };\n  }\n}\n\nfunction gp_createSameLocationMarkers() {\n  //Wipe out existing same location markers\n  for (var i = 0; i < gp_sameLocationMarkers.length; i++) {\n    const marker = gp_sameLocationMarkers[i];\n    if (marker) marker.setMap(null);\n  }\n\n  gp_sameLocationMarkers = [];\n  var sameLocations = {}; //Loop through all of the data\n\n  var allTables = jQuery('.dataTable'); // Loop through each table\n\n  for (var i = 0, iLen = allTables.length; i < iLen; i++) {\n    // Get the Table Data\n    var aoData = jQuery(allTables[i]).dataTable().fnGetData();\n    var columnInfo = jQuery(allTables[i]).data('columnInfo');\n    var collectionName = jQuery(allTables[i]).attr('id'); //Only proceed if these markers are visible on the map\n\n    if (gp_dataSetSearches[collectionName] && gp_dataSetSearches[collectionName].markersVisible != false && gp_dataSetSearches[collectionName].markerType == 'marker') {\n      //Loop through the rows\n      for (var j = 0; j < aoData.length; j++) {\n        var row = aoData[j];\n        var marker = gp_markers[row[gp_ColumnInfo.uniqueId]];\n        if (!marker) continue; //If marker is hidden by the legend skip it\n\n        if (marker && marker.hiddenByLegend == true) {\n          continue;\n        } //Get that lat and combine them with a x\n\n\n        var latLng = row[gp_ColumnInfo.latitudeDisplay] + 'x' + row[gp_ColumnInfo.longitudeDisplay]; //Maker sure there is a key value for this lat long in same locations object\n\n        if (typeof sameLocations[latLng] == 'undefined') {\n          sameLocations[latLng] = [];\n        } //Increment the count of records at this location\n\n\n        sameLocations[latLng].push(marker);\n      } // END OF Rows Loop\n\n    }\n  } // END OF tables loop\n\n\n  _.forEach(gp_markers, function (dataLayerMarker) {\n    // If not a data layer marker, skip\n    if (!dataLayerMarker.poi) return; // If marker is hidden by the legend skip it\n\n    if (dataLayerMarker.hiddenByLegend === true || dataLayerMarker.visible === false) return; // If clustering is turned on for this layer, skip\n\n    if (gp_layers[dataLayerMarker.collectionName].displayType === 'cluster') return; // Get that lat and combine them with a x\n\n    var markerLatLng = dataLayerMarker.poi.geocode.coordinates[1] + 'x' + dataLayerMarker.poi.geocode.coordinates[0]; // Maker sure there is a key value for this lat long in same locations object\n\n    if (typeof sameLocations[markerLatLng] === 'undefined') {\n      sameLocations[markerLatLng] = [];\n    } // Increment the count of records at this location\n\n\n    sameLocations[markerLatLng].push(dataLayerMarker);\n  }); //Loop through the same locations object\n\n\n  var hidingSLMs = gp_userSettings.settings__c[nameSpacePrefix + 'Same_Location_Markers__c'] == 'on';\n\n  for (key in sameLocations) {\n    // hide markers/labels at this sameLocation, IF we're replacing with a SLM\n    var hideThisKey = hidingSLMs && sameLocations[key].length > 1;\n\n    for (var mx = 0; mx < sameLocations[key].length; mx++) {\n      sameLocations[key][mx].setMap(hideThisKey ? null : gp_map);\n    } //If there was more than one location at same spot create a special marker\n\n\n    if (sameLocations[key].length > 1) {\n      //Parse out the lat long\n      var latLng = key.split('x'); // Create a new marker at this location that carries 'N markers at this location' tooltip.\n      // If SLM=='on' marker is a visible circle with a Number\n\n      var marker = gp_createSameLocationMarker(latLng[0], latLng[1], sameLocations[key].length); //Set gp properties\n\n      marker.gpLat = latLng[0];\n      marker.gpLng = latLng[1];\n      marker.gpRecordCount = sameLocations[key].length;\n      marker.type = 'cluster';\n      gp_sameLocationMarkers.push(marker);\n    }\n  } //Hide the info window if it is open for sameLocationMarkers\n\n\n  if (gp_infoWindow && gp_infoWindow.content && gp_infoWindow.content.indexOf('sameLocationInfoWindowWrapper') > -1) {\n    gp_closeInfoWindow(false);\n  }\n}\n\nfunction gp_createSameLocationMarker(lat, lng, count) {\n  var imgUrl = GEOPOINTE_API + '/v1/markers/circle-l+007AA5.png?text=' + count; //If org setting is default off use the transparent img\n\n  if (gp_orgSettings.settings.sameLocationMarkers == 'Default Off') {\n    imgUrl = gpImg.onepxtransparent;\n  } //If user as overriden the same location marker option use this\n\n\n  if (typeof gp_userSettings.settings__c[nameSpacePrefix + 'Same_Location_Markers__c'] != 'undefined') {\n    if (gp_userSettings.settings__c[nameSpacePrefix + 'Same_Location_Markers__c'] == 'on') {\n      imgUrl = GEOPOINTE_API + '/v1/markers/circle-l+007AA5.png?text=' + count;\n    } else {\n      imgUrl = gpImg.onepxtransparent;\n    }\n  }\n\n  var marker = new google.maps.Marker({\n    position: new google.maps.LatLng(lat, lng),\n    map: gp_map,\n    icon: {\n      scaledSize: new google.maps.Size(33, 33),\n      size: new google.maps.Size(33, 33),\n      url: imgUrl\n    },\n    zIndex: 100000 //make sure this is always on top of the markers\n\n  });\n  marker.tooltip = '<div class=\"gp_tooltip nowrap\"><var>' + gp_DOMPurify.sanitize(count) + '</var> records at this location</div>';\n  google.maps.event.addListener(marker, 'mouseover', function () {\n    gp_tooltip.setContent(marker.tooltip); // pull any slightly off-map marker into bounds so that\n    // tooltip.open() doesn't make a radical grab to center\n\n    gp_map.getBounds().extend(marker.position);\n    gp_tooltip.show();\n    gp_tooltip.open(gp_map, marker);\n  }); // Marker Mouseout Event\n\n  google.maps.event.addListener(marker, 'mouseout', function () {\n    gp_tooltip.hide();\n  }); //Create event listener for click\n\n  google.maps.event.addListener(marker, 'click', function (e) {\n    gp_closeInfoWindow(false);\n    gp_showSameLocationMarkerInfoWindow(marker);\n  });\n  return marker;\n}\n\nfunction gp_showSameLocationMarkerInfoWindow(marker) {\n  //Calculate max height of infowindow\n  var maxHeight = jQuery('#mapDIV').height() * 0.7; // SECURITY: because the html string includes javascript, we will sanitize variables as we construct the string\n\n  var infoWindowHTMLSanitized = '<div class=\"sameLocationInfoWindowWrapper\" style=\"max-height: ' + maxHeight + 'px\"><table cellspacing=\"0\" cellpadding=\"0\" width=\"100%\" class=\"sameLocationInfoWindowTable\"><tbody>'; //Loop through all of the data\n\n  var allTables = jQuery('.dataTable'); // Loop through each table\n\n  for (var i = 0, iLen = allTables.length; i < iLen; i++) {\n    // Get the Table Data\n    var aoData = jQuery(allTables[i]).dataTable().fnGetData();\n    var columnInfo = jQuery(allTables[i]).data('columnInfo');\n    var collectionName = jQuery(allTables[i]).attr('id'); //Only proceed if markers are on the map for this dataset\n\n    var foundSameLocation = 0;\n\n    if (gp_dataSetSearches[collectionName].markersVisible != false) {\n      //Loop through the rows\n      for (var j = 0; j < aoData.length; j++) {\n        var row = aoData[j];\n        var titleTop = '-3px;';\n\n        if (row[gp_ColumnInfo.title2]) {\n          titleTop = '-1px';\n        }\n\n        var mapMarker = gp_markers[row[columnInfo.uniqueId]]; //If marker is hidden by the legend skip it\n\n        if (!mapMarker || (mapMarker === null || mapMarker === void 0 ? void 0 : mapMarker.hiddenByLegend) == true) {\n          continue;\n        } //If record has same lat lng of marker, add it to info window\n\n\n        if (marker.gpLat == row[gp_ColumnInfo.latitudeDisplay] && marker.gpLng == row[gp_ColumnInfo.longitudeDisplay]) {\n          const uniqueIdSanitized = gp_DOMPurify.sanitize(row[gp_ColumnInfo.uniqueId]);\n          infoWindowHTMLSanitized += '<tr>' + '<td width=\"17px\">' + '<a href=\"#\"  onclick=\"if(gp_inRecordSelectionMode && \\'' + uniqueIdSanitized + \"' != 'gp_mapCenterPoi' && '\" + uniqueIdSanitized + \"' != 'centerPOI') \" + \"{ gp_toggleRecordSelection('\" + uniqueIdSanitized + \"'); }\" + \"else{gp_openPoiInfoMarker('\" + uniqueIdSanitized + '\\',false); return false;}\">';\n\n          if ('label' == marker.type) {\n            infoWindowHTMLSanitized += '<img src=\"' + gp_DOMPurify.sanitize(GEOPOINTE_API + '/v1/markers/pin-m+' + dsController.baseColorPalette[0]) + '.png\" height=\"32px\"/>';\n          } else {\n            infoWindowHTMLSanitized += '<img src=\"' + gp_DOMPurify.sanitize(row[gp_ColumnInfo.mapIconURL]) + '\" height=\"32px\" ' + 'style=\"height: 32px !important;\" ' + 'onerror=\"this.onerror=null;this.src=\\'' + gp_DOMPurify.sanitize(gp_dataSetSearches[collectionName].icon) + '\\'\"/>';\n          }\n\n          infoWindowHTMLSanitized += '</a></td>' + '<td>' + '<div class=\"sameLocationDetail\" style=\"top: ' + titleTop + '\">' + '<div><a href=\"#\" onclick=\"gp_openPoiInfoMarker(\\'' + uniqueIdSanitized + '\\',false); return false;\">' + gp_DOMPurify.sanitize(row[gp_ColumnInfo.title]) + '</a></div>' + '<div class=\"title2\">' + gp_DOMPurify.sanitize(row[gp_ColumnInfo.title2]) + '</div>' + '</div>' + '</td>' + '</tr>';\n        }\n      } // END OF Rows Loop\n\n    }\n  } // END OF tables loop\n\n\n  _.forEach(gp_markers, function (dataLayerMarker, key) {\n    // If not a data layer marker, skip\n    if (!dataLayerMarker.poi) return; // If marker is hidden by the legend skip it\n\n    if (dataLayerMarker.hiddenByLegend === true || dataLayerMarker.visible === false) return; // If clustering is turned on for this layer, skip\n\n    if (gp_layers[dataLayerMarker.collectionName].displayType === 'cluster') return; // If record doesn't have same lat lng of same location marker, skip\n\n    if (marker.gpLat !== String(dataLayerMarker.poi.geocode.coordinates[1]) || marker.gpLng !== String(dataLayerMarker.poi.geocode.coordinates[0])) return;\n    const keySanitized = gp_DOMPurify.sanitize(key);\n    infoWindowHTMLSanitized += '<tr>' + '<td width=\"17px\">' + '<a href=\"#\"  onclick=\"if(gp_inRecordSelectionMode && \\'' + keySanitized + \"' != 'gp_mapCenterPoi' && '\" + keySanitized + \"' != 'centerPOI') \" + \"{ gp_toggleRecordSelection('\" + keySanitized + \"'); }\" + \"else{gp_openPoiInfoMarker('\" + keySanitized + '\\',false); return false;}\">';\n\n    if (dataLayerMarker.type === 'label') {\n      infoWindowHTMLSanitized += '<img src=\"' + gp_DOMPurify.sanitize(GEOPOINTE_API + '/v1/markers/pin-l+' + angular.element('#dataLayerDirective').injector().get('dataLayerService').dataLayerDefaults[dataLayerMarker.dataType].defaultColorRule.color) + '.png\" height=\"32px\"/>';\n    } else {\n      infoWindowHTMLSanitized += '<img src=\"' + gp_DOMPurify.sanitize(dataLayerMarker.markerUrl) + '\" height=\"32px\" />';\n    }\n\n    infoWindowHTMLSanitized += '</a></td>' + '<td>' + '<div class=\"sameLocationDetail\" style=\"top: ' + gp_DOMPurify.sanitize(titleTop) + '\">' + '<div><a href=\"#\" onclick=\"google.maps.event.trigger(gp_markers[\\'' + keySanitized + \"'], 'click'); return false;\\\">\" + gp_DOMPurify.sanitize(dataLayerMarker.name) + '</a></div>' + '</div>' + '</td>' + '</tr>';\n  }); //Close the table\n\n\n  infoWindowHTMLSanitized += '</tbody></table></div>'; //Set properties of info window and show it\n\n  gp_infoWindow.setOptions({\n    pixelOffset: {\n      height: -28,\n      width: 0\n    }\n  });\n  gp_infoWindow.setContent(infoWindowHTMLSanitized);\n  gp_infoWindow.setPosition(new google.maps.LatLng(marker.gpLat, marker.gpLng));\n  gp_infoWindow.open(gp_map);\n} //Toggle record selection, add checkmark to map, update checkbox in table\n\n\nfunction gp_toggleRecordSelection(uniqueId, collectionName) {\n  // track selection count in collection, if name passed in\n  var dsSearch = null;\n\n  if (collectionName) {\n    dsSearch = gp_dataSetSearches[collectionName];\n\n    if (dsSearch) {\n      if (dsSearch.selectCount == undefined) {\n        dsSearch.selectCount = 0;\n      }\n    }\n  } //Set apply to picklist to selected records\n\n\n  jQuery('#applyActionTo').val('selectedRecords'); //Check to see if the record is already selected\n\n  if (!gp_selectedRecords[uniqueId]) {\n    gp_selectedRecords[uniqueId] = true; //Set z index of the maker pin 1 below the check box icon\n\n    gp_markers[uniqueId].setZIndex(199999);\n    gp_markers[uniqueId].selectedMarker = new google.maps.Marker({\n      position: gp_markers[uniqueId].getPosition(),\n      map: gp_map,\n      icon: {\n        anchor: new google.maps.Point(0, 17),\n        scaledSize: new google.maps.Size(18, 18),\n        size: new google.maps.Size(18, 18),\n        url: redCheckIconURL\n      },\n      flat: false,\n      zIndex: 200000\n    });\n    if (dsSearch) ++dsSearch.selectCount;\n  } else {\n    //Set selected flag as false for the record\n    gp_selectedRecords[uniqueId] = false; //Remove the selected marker from the map\n\n    gp_markers[uniqueId].selectedMarker.setMap(null);\n    gp_markers[uniqueId].selectedMarker = null;\n\n    if (dsSearch) {\n      --dsSearch.selectCount;\n      if (dsSearch.selectCount < 0) dsSearch.selectCount = 0;\n    }\n  }\n\n  if (collectionName) {\n    var displaySelectCount = jQuery('#selectAllHelper' + collectionName + ' th:first .displaySelectCount');\n\n    if (displaySelectCount) {\n      displaySelectCount.html(gp_DOMPurify.sanitize('Selected ' + dsSearch.selectCount + ' of ' + dsSearch.numOfRecords + ' records. '));\n    }\n\n    var selectAllLink = jQuery('#selectAllHelper' + collectionName + ' a');\n    selectAllLink.text(dsSearch.selectCount < dsSearch.numOfRecords ? 'Select All' : 'Clear Selection');\n  }\n\n  updateDataTableSelectedProp(uniqueId);\n}\n\nfunction gp_removeCenterMarker() {\n  // Removing the center poi if it exists on the map\n  if (gp_masterMarker != null) {\n    gp_removeMarkerMap(gp_masterMarker.uniqueID);\n    gp_masterMarker = null;\n    jQuery('#centerContextTitleOutput').html('Center of the Map');\n    setDataSetTabMaxHeight();\n  }\n} //Resizes the map to be the width of the div\n\n\nfunction gp_resetMapWidth() {\n  google.maps.event.trigger(gp_map, 'resize'); // Reset legend max width\n\n  setLegendMaxHeight();\n}\n\nfunction gp_setMaxDataTableWidth() {\n  var navBar = jQuery('.zen #tabContainer'); //sfdc header, same width as visualforce content\n\n  if (navBar && navBar.length > 0) {\n    jQuery('.dataTableScrollWrapper').width(navBar.width());\n  } else {\n    jQuery('.dataTableScrollWrapper').width(jQuery(window).width());\n  }\n}\n\nfunction gp_setMapHeight(height) {\n  const mapDivElement = document.querySelector('#mapDIV');\n  const mapWrapper = document.querySelector('#mapWrapper');\n  mapWrapper.classList.remove('mapWrapperInit');\n\n  if (height == 'auto') {\n    height = getAutoMapHeight();\n  }\n\n  mapDivElement.style.height = \"\".concat(height, \"px\");\n  mapDivElement.style.width = '100%';\n  var drawingControls = document.querySelector('.drawingControls');\n\n  if (drawingControls) {\n    if (height < 575) {\n      document.querySelector('.drawingControls').style.display = 'none';\n    } else if (!gp_mapMode || gp_mapMode === 'search') {\n      document.querySelector('.drawingControls').style.display = '';\n    }\n  }\n\n  if (gp_map) google.maps.event.trigger(gp_map, 'resize');\n  setRouteTabHeights();\n  setDataSetTabMaxHeight();\n  setLayersTableMaxHeight();\n  setSearchTabMaxHeight();\n  setCalendarTabMaxHeight();\n} //Called from a link inside a POI to zoom down to that location\n\n\nfunction gp_zoomToStreet(lat, lon, zoom) {\n  gp_map.setCenter(new google.maps.LatLng(lat, lon));\n  gp_map.setZoom(zoom);\n}\n\nfunction gp_getZoomLevel() {\n  return gp_map.getZoom();\n}\n\nfunction gp_centerZoomMyPosition() {\n  //Dreamforce demo org\n  if (gp_userSettings.userInfo.orgId == '00Do0000000bwHyEAI') {\n    gp_map.setCenter(new google.maps.LatLng(37.784188, -122.401519));\n    gp_map.setZoom(14);\n  } else if (navigator.geolocation != null) {\n    navigator.geolocation.getCurrentPosition(function (position) {\n      gp_map.setCenter(new google.maps.LatLng(position.coords.latitude, position.coords.longitude));\n      gp_map.setZoom(14);\n    }, function () {\n      jQuery.extend(toastr.options, {\n        timeOut: 60000\n      });\n      toastr.error(gp_DOMPurify.sanitize(gp_translations.Your_browser_failed_to_determine_your_current_location));\n    });\n  } else {\n    jQuery.extend(toastr.options, {\n      timeOut: 60000\n    });\n    toastr.error(gp_DOMPurify.sanitize(gp_translations.Your_browser_does_not_support_determination_of_your_current_location));\n  }\n}\n\nfunction gp_centerRightClick() {\n  // Recenter map\n  gp_map.panTo(new google.maps.LatLng(rightClickLatLng.lat, rightClickLatLng.lng));\n  const payload = {\n    action: 'trackRightClick',\n    data: {\n      action: 'Center'\n    }\n  };\n  asyncGpEmitter('MixPanelService', payload);\n}\n\nfunction gp_bestFitRightClick() {\n  gp_centerZoom();\n  const payload = {\n    action: 'trackRightClick',\n    data: {\n      action: 'Show All Mapped Points'\n    }\n  };\n  asyncGpEmitter('MixPanelService', payload);\n}\n\nfunction gp_streetViewRightClick() {\n  gp_enableStreetView(rightClickLatLng.lat, rightClickLatLng.lng);\n  const payload = {\n    action: 'trackRightClick',\n    data: {\n      action: 'Street View'\n    }\n  };\n  asyncGpEmitter('MixPanelService', payload);\n}\n\nfunction gp_centerZoomRightClick() {\n  gp_centerRightClick(); //Based on current zoom level zoom in.\n\n  var zoom = gp_getZoomLevel();\n  var newZoom = 14; //Default\n\n  if (zoom == 0) {\n    newZoom = 3;\n  } else if (zoom == 1) {\n    newZoom = 5;\n  } else if (zoom == 2) {\n    newZoom = 6;\n  } else if (zoom == 3) {\n    newZoom = 7;\n  } else if (zoom == 4) {\n    newZoom = 7;\n  } else if (zoom == 5) {\n    newZoom = 9;\n  } else if (zoom == 6) {\n    newZoom = 11;\n  } else if (zoom == 7) {\n    newZoom = 11;\n  } else if (zoom == 8) {\n    newZoom = 12;\n  } else if (zoom == 9) {\n    newZoom = 13;\n  } else if (zoom == 10) {\n    newZoom = 14;\n  } else if (zoom == 11) {\n    newZoom = 15;\n  } else if (zoom == 12) {\n    newZoom = 15;\n  } else if (zoom == 13) {\n    newZoom = 16;\n  } else if (zoom == 14) {\n    newZoom = 16;\n  } else if (zoom == 15) {\n    newZoom = 18;\n  } else if (zoom == 16) {\n    newZoom = 18;\n  } else if (zoom == 17) {\n    newZoom = 19;\n  } else if (zoom == 18) {\n    newZoom = 20;\n  } else if (zoom == 19) {\n    newZoom = 20;\n  } else if (zoom == 20) {\n    newZoom = 21;\n  } else if (zoom == 21) {\n    newZoom = 21;\n  }\n\n  gp_map.setZoom(newZoom);\n  const payload = {\n    action: 'trackRightClick',\n    data: {\n      action: 'Center and Zoom'\n    }\n  };\n  asyncGpEmitter('MixPanelService', payload);\n}\n\nfunction gp_openRigthClickMenu(e) {\n  // if the map mode is not search, don't open (could be in measureDistance, addShape)\n  if (gp_mapMode !== undefined && gp_mapMode !== 'search') {\n    return;\n  }\n\n  gp_map.set('disableDoubleClickZoom', true); //disable double click zoom becuase of FF zoom out bug\n  //Find the pixel position in the map\n\n  const overlay = new google.maps.OverlayView();\n\n  overlay.draw = function () {};\n\n  overlay.setMap(gp_map);\n  const projection = overlay.getProjection();\n  const pixel = projection.fromLatLngToContainerPixel(e.latLng); //Create on object with coordinates and mouse position\n\n  const clickInfo = {\n    lat: e.latLng.lat(),\n    lng: e.latLng.lng(),\n    x: pixel.x,\n    y: pixel.y\n  }; //Save the lat lng of the click in rightClickLatLng var so other methods have access\n\n  rightClickLatLng = clickInfo; //Create a \"POI\" object we can send to the buildPOIActions method\n\n  const thisPOI = {\n    lat: clickInfo.lat,\n    lng: clickInfo.lng\n  }; //First populate the custom map actions\n  // SECURITY: buildPOIActions returns a sanitized string\n\n  const actionsHTML = buildPOIActions(null, thisPOI, 'map');\n  jQuery('#mapContextMenu .menuMapActions').html(actionsHTML); //Select the menu and store in variable\n\n  const $mapMenu = jQuery('#mapContextMenu');\n  const $mapWrapper = jQuery('#mapWrapper'); //Determine coordinates of mouse click inside the mapDiv\n\n  let x = clickInfo.x + 1; //+1 so normal right click menu does not open\n\n  let y = clickInfo.y; //Collision detection stuff to make sure menu is not off the edge of the screen\n\n  if (y + $mapMenu.outerHeight() > $mapWrapper.height()) {\n    y = y - $mapMenu.outerHeight();\n  }\n\n  if (x + $mapMenu.outerWidth() > $mapWrapper.width()) {\n    x = x - $mapMenu.outerWidth() - 1; //-1 so normal right click menu does not open\n  } //Show the menu\n\n\n  $mapMenu.css({\n    display: 'block',\n    top: y,\n    left: x\n  });\n}\n\nfunction gp_clearCenter() {\n  // Removing the center poi if it exists on the map\n  if (gp_masterMarker != null) {\n    gp_removeMarkerMap(gp_masterMarker.uniqueID);\n    gp_masterMarker = null;\n  }\n\n  jQuery('#centerContextTitleOutput').html('Center of the Map');\n  setDataSetTabMaxHeight(); //Wipe out the old center point poi\n\n  gp_centerPOI = {};\n  gp_centerPointKeepAddress = false; //Clear search center\n\n  gp_radialSearchCenter = {\n    lat: null,\n    lng: null,\n    recordId: null\n  };\n}\n\nfunction gp_setCenter() {\n  //Recenter map\n  gp_map.panTo(new google.maps.LatLng(rightClickLatLng.lat, rightClickLatLng.lng)); //Set the right click repositioned flag to true so original centerPOI is not used\n\n  rightClickRepositionOccured = true;\n  gp_clearCenter(); //Set search center\n\n  gp_radialSearchCenter = {\n    lat: rightClickLatLng.lat,\n    lng: rightClickLatLng.lng,\n    recordId: null\n  };\n}\n\nfunction gp_searchRadialRemoteRightClick() {\n  //Recenter map\n  gp_map.panTo(new google.maps.LatLng(rightClickLatLng.lat, rightClickLatLng.lng)); //Set the right click repositioned flag to true so original centerPOI is not used\n\n  rightClickRepositionOccured = true; //Wipe out the old center point poi\n\n  gp_centerPOI = {};\n  gp_centerPointKeepAddress = false; //Set search center\n\n  gp_radialSearchCenter = {\n    lat: rightClickLatLng.lat,\n    lng: rightClickLatLng.lng,\n    recordId: null\n  }; //Do radial search\n\n  gp_searchRadialRemote();\n  const payload = {\n    action: 'trackRightClick',\n    data: {\n      action: 'Radial Search'\n    }\n  };\n  asyncGpEmitter('MixPanelService', payload);\n}\n\nfunction gp_measureDistanceRightClick() {\n  gp_rulerTool.startMeasureDistance(rightClickLatLng.lat, rightClickLatLng.lng);\n  const payload = {\n    action: 'trackRightClick',\n    data: {\n      action: 'Measure Distance'\n    }\n  };\n  asyncGpEmitter('MixPanelService', payload);\n} //Return an object with center info\n\n\nfunction gp_getCenterObject() {\n  var r = new Object();\n  r.center = gp_map.getCenter();\n  r.lat = r.center.lat();\n  r.lng = r.center.lng();\n  return r;\n} //Return an object with bounds\n\n\nfunction gp_getBoundsObject() {\n  var r = new Object();\n  r.bounds = gp_map.getBounds();\n  if (!r.bounds) return null;\n  r.minLat = r.bounds.getSouthWest().lat();\n  r.maxLat = r.bounds.getNorthEast().lat();\n  r.minLng = r.bounds.getSouthWest().lng();\n  r.maxLng = r.bounds.getNorthEast().lng();\n  return r;\n} //A Best Fit function for Google Maps - depends upon the gp_bounds object being populated\n\n\nfunction gp_centerZoom() {\n  if (gp_bounds.getCenter().lat() != 0 && gp_bounds.getCenter().lng() != -180) {\n    // Center\n    gp_map.setCenter(gp_bounds.getCenter()); // Zoom\n\n    gp_map.fitBounds(gp_bounds); // an event listener will reset the zoom if its in too far\n  }\n} // Open the Info Window\n// fromShape: optional, passed in when POI window is opened from a shape window's record list,\n// so a back-link to the shape window can be created in the record window\n\n\nfunction gp_openPoiInfoMarker(markerID, sameLocationMarker, fromShape) {\n  const marker = gp_markers[markerID];\n\n  if (markerID === 'gp_currentLocation') {\n    const payload = {\n      action: 'showCurrentLocationInfoWindow',\n      data: {}\n    };\n    asyncGpEmitter('InfoWindowService', payload);\n  } else if (sameLocationMarker) {\n    gp_infoWindow.setOptions({\n      pixelOffset: {\n        height: -28,\n        width: 0\n      }\n    }); // SECURITY: marker.infoWindowHTML was sanitized during construction\n\n    gp_infoWindow.setContent(marker.infoWindowHTML);\n    gp_infoWindow.setPosition(marker.getPosition());\n    gp_infoWindow.open(gp_map);\n    gp_infoWindow.markerId = marker.uniqueID;\n    gp_infoWindow.tabsDIV = null;\n    gp_infoWindow.groupLayerId = null;\n  } else {\n    const payload = {\n      action: 'openPoiInfoMarker',\n      data: {\n        markerID: markerID,\n        sameLocationMarker: sameLocationMarker,\n        fromShape: fromShape,\n        buildActions: true\n      }\n    };\n    asyncGpEmitter('InfoWindowService', payload);\n  }\n}\n\nfunction gp_getSObjectFieldValue(sObject, path) {\n  return path.split('.').reduce(function (sObject, field) {\n    if (!sObject || sObject[field] === undefined || sObject[field] === null) return '';else return sObject[field];\n  }, sObject);\n}\n\nfunction gp_setSObjectFieldValue(sObject, path, value) {\n  var path = path.split('.');\n  var lastField = path.pop();\n  var sObject = path.reduce(function (sObject, field) {\n    if (sObject[field] === '' || sObject[field] === undefined || sObject[field] === null) sObject[field] = {};\n    return sObject[field];\n  }, sObject);\n  sObject[lastField] = value;\n} // Remove the marker from the map\n\n\nfunction gp_removeMarkerMap(markerID) {\n  if (typeof markerID === 'object') {\n    if (markerID.type === 'Location') return angular.element('.dataSetController').scope().locationsService.clearLayer(markerID);\n  }\n\n  const marker = gp_markers[markerID];\n  if (!marker) return;\n\n  if (gp_dataSetSearches[marker.collectionName] && gp_dataSetSearches[marker.collectionName].markerClusterer) {\n    gp_dataSetSearches[marker.collectionName].markerClusterer.removeMarker(marker);\n  } // Remove marker from map\n\n\n  gp_markers[markerID].setMap(null); // Close info window if applicable\n\n  if (markerID == gp_infoWindow.markerId) {\n    gp_closeInfoWindow();\n  } // Remove from the gp_markers object\n\n\n  delete gp_markers[markerID]; //Recalc the samelocation markers\n\n  gp_createSameLocationMarkers();\n} //Given a data set search collection name, remove those markers from the map\n\n\nfunction gp_removeDataSetSearchFromMap(collectionName, forHeatMap) {\n  //Loop through markers collection and remove those from map for the specified collection\n  for (key in gp_markers) {\n    if (gp_markers[key].collectionName == collectionName) {\n      gp_markers[key].setMap(null);\n      if (!forHeatMap) gp_markers[key].visible = false;\n\n      if (collectionName === gp_infoWindow.clusterId) {\n        gp_closeInfoWindow();\n      } // Close info window if applicable\n\n\n      if (gp_markers[key].uniqueID == gp_infoWindow.markerId) {\n        gp_closeInfoWindow();\n      }\n    }\n  } //Remove any circles on the map related to this search\n\n\n  for (key in gp_cirOverlays) {\n    if (key == collectionName + '_overlay') {\n      gp_cirOverlays[key].setMap(null);\n    }\n  } //Remove shape fields\n\n\n  for (key in polygonObjects) {\n    if (polygonObjects[key].gpProperties.gpCollectionName == collectionName) {\n      if (polygonObjects[key].mapLabel) polygonObjects[key].mapLabel.setMap(null);\n      if (polygonObjects[key].bufferPolygon) polygonObjects[key].bufferPolygon.setMap(null);\n      polygonObjects[key].setMap(null);\n    }\n  } //Set markers visible flag to false for this search\n\n\n  if (gp_dataSetSearches[collectionName]) {\n    gp_dataSetSearches[collectionName].markersVisible = false;\n  } //Remove any marker clusters\n\n\n  gp_dataSetSearches[collectionName].markerClusterer.clearMarkers(); //Rebuild the same location markers\n\n  gp_createSameLocationMarkers();\n}\n\nfunction gp_removeDataSetSearchTab(collectionName) {\n  //Remove markers from gp_markers object\n  for (key in gp_markers) {\n    if (gp_markers[key].collectionName == collectionName) {\n      // Remove any associated record-selection checkmark\n      if (gp_selectedRecords[key] && gp_markers[key].selectedMarker) {\n        delete gp_selectedRecords[key];\n      }\n\n      if (gp_markers[key].uniqueID === gp_infoWindow.markerId) {\n        gp_closeInfoWindow(false);\n      }\n\n      gp_markers[key].setMap(null);\n      delete gp_markers[key];\n    }\n  } //Remove circle from gp_cirOverlays object\n\n\n  for (key in gp_cirOverlays) {\n    if (key == collectionName + '_overlay') {\n      gp_cirOverlays[key].setMap(null);\n      delete gp_cirOverlays[key];\n    }\n  } //Remove shape fields\n\n\n  for (key in polygonObjects) {\n    if (polygonObjects[key].gpProperties.gpCollectionName == collectionName) {\n      if (polygonObjects[key].mapLabel) polygonObjects[key].mapLabel.setMap(null);\n      if (polygonObjects[key].bufferPolygon) polygonObjects[key].bufferPolygon.setMap(null);\n      polygonObjects[key].setMap(null);\n      delete polygonObjects[key];\n    }\n  } //Remove the tab and content\n\n\n  jQuery(\".dataSetResultTableTab[data-collectionName='\" + collectionName + \"']\").remove();\n  jQuery('#tabs-' + collectionName).remove(); //Remove any cluster layers\n\n  var collectionSearch = gp_dataSetSearches[collectionName];\n\n  if (collectionSearch) {\n    if (collectionSearch.markerClusterer) collectionSearch.markerClusterer.clearMarkers(); //Remove from gp_dataSetSearches object\n\n    delete gp_dataSetSearches[collectionName];\n    collectionSearch = null;\n  } //Remove the legend\n\n\n  var mapLegendService = angular.element('.legendController').injector().get('mapLegendService');\n  mapLegendService.removeLegendGroup(collectionName); //Rebuild the same location markers\n\n  gp_createSameLocationMarkers(); //Update the layers list with new record counts\n\n  setTimeout(function () {\n    angular.element('#ngApp').scope().$broadcast('layersChanged', {\n      doApply: true\n    });\n  }, 0); //If there no more result or route tabs show the no data message\n\n  var $tabs = jQuery('.dataSetResultTableTab,#routeDirectionsTab');\n\n  if ($tabs.length == 0) {\n    jQuery('#gp_dataTablesNoData').show();\n    jQuery('#gp_dataTables').hide();\n  } else {\n    jQuery($tabs[0]).find('a').click();\n  }\n}\n\nfunction gp_restoreDataSetSearchOnMap(collectionName, restoreMarkers, skipColorRules) {\n  //If markers where visibile before data set was removed from map, add them back\n  const dataSetSearch = gp_dataSetSearches[collectionName];\n  if (!dataSetSearch) return;\n  let useCluster = dataSetSearch.numOfRecords > gp_userSettings.settings__c[nameSpacePrefix + 'Auto_Cluster_Query_Size__c'] ? true : false; //If market type for this data set is explicitly set to cluster, use it.\n\n  if (dataSetSearch.markerType == 'cluster') {\n    useCluster = true;\n  }\n\n  if (!skipColorRules) gp_colorMarkers(collectionName);\n\n  for (const key in gp_markers) {\n    const marker = gp_markers[key];\n    gp_showMarker(marker, collectionName, restoreMarkers);\n  } //Draw the cluster layer after all markers have been added\n\n\n  if (useCluster == true) {\n    dataSetSearch.markerType = 'cluster';\n    dataSetSearch.markerClusterer.repaint();\n  } //Add back any necessary circles\n\n\n  for (const key in gp_cirOverlays) {\n    if (key == collectionName + '_overlay') {\n      gp_cirOverlays[key].setMap(gp_map);\n\n      if (gp_cirOverlays[key].mapLabel) {\n        gp_cirOverlays[key].mapLabel.setMap(gp_cirOverlays[key].showLabel ? gp_map : null);\n      }\n    }\n  } //Add shape fields\n\n\n  for (const key in polygonObjects) {\n    if (polygonObjects[key].gpProperties.gpCollectionName == collectionName) {\n      polygonObjects[key].setMap(gp_map);\n\n      if (polygonObjects[key].mapLabel) {\n        polygonObjects[key].mapLabel.setMap(polygonObjects[key].gpProperties.showLabel ? gp_map : null);\n      }\n    }\n  } //Set markers visible flag to true for this search\n\n\n  if (gp_dataSetSearches[collectionName] && restoreMarkers) {\n    gp_dataSetSearches[collectionName].markersVisible = true;\n  } //Rebuild the same location markers\n\n\n  gp_createSameLocationMarkers();\n}\n\nfunction gp_showMarker(marker, collectionName, restoreMarkers) {\n  const dataSetSearch = gp_dataSetSearches[collectionName];\n  let useCluster = dataSetSearch.numOfRecords > gp_userSettings.settings__c[nameSpacePrefix + 'Auto_Cluster_Query_Size__c'] ? true : false; //If market type for this data set is explicitly set to cluster, use it.\n\n  if (dataSetSearch.markerType == 'cluster') {\n    useCluster = true;\n  }\n\n  if (marker.collectionName == collectionName) {\n    marker.visible = true;\n  }\n\n  if (marker.collectionName == collectionName && !marker.hiddenByLegend && restoreMarkers) {\n    if (useCluster) {\n      dataSetSearch.markerClusterer.addMarker(marker, true); //True is a noDraw option, we will do this once all markers have been added\n    }\n\n    if ('label' == marker.type) {\n      // MapLabel has no event listners, so we borrow those of Marker by spreading it over the text\n      const labelWidth = marker.mapLabel.text.length * 6; // good-enough estimate - if we had a text extent it would be better\n\n      marker.icon.anchor = {\n        x: labelWidth * 0.5,\n        y: 0\n      };\n      marker.icon.scaledSize = {\n        width: labelWidth,\n        height: marker.mapLabel.fontSize,\n        U: 'px',\n        V: 'px'\n      };\n      marker.icon.url = gpImg.onepxtransparent;\n    }\n\n    marker.setMap(gp_map);\n\n    if (marker.mapLabel && dataSetSearch.layerSettings && dataSetSearch.layerSettings.markerLabelsVisible == true) {\n      // mapPane will be behind polygons unless its Canvas is lifted\n      const panes = marker.mapLabel.getPanes();\n\n      if (panes && panes.mapPane) {\n        jQuery(panes.mapPane).css('z-index', marker.mapLabel.zIndex);\n      }\n\n      marker.mapLabel.setMap(gp_map); // oddly, Marker.prototype.setMap overload doesn't seem to cover this case\n    }\n  }\n} // Enable Street View\n\n\nfunction gp_enableStreetView(lat, lng) {\n  jQuery('#mapContextMenu').hide();\n  gp_map.getStreetView().setPosition(new google.maps.LatLng(lat, lng));\n  gp_map.getStreetView().setVisible(true);\n} //Toggles the Traffic Overlay\n\n\nfunction gp_toggleTraffic() {\n  try {\n    if (gp_trafficState) {\n      gp_traffic.setMap(null);\n      gp_trafficState = false;\n    } else {\n      gp_traffic.setMap(gp_map);\n      gp_trafficState = true;\n    }\n\n    const payload = {\n      action: 'trackLayerToggle',\n      data: {\n        layerType: 'Traffic',\n        layerStatus: gp_trafficState ? 'On' : 'Off'\n      }\n    };\n    asyncGpEmitter('MixPanelService', payload);\n    return false;\n  } catch (e) {\n    gp_alert('An error occurred. If this continues, please contact Geopointe support.');\n    console.log(e);\n    geopointeAjaxEnd();\n    return false;\n  }\n}\n\nfunction formatMultiLineAddress(address) {\n  var formatedAddress;\n\n  if (address.street) {\n    if (formatedAddress && formatedAddress.length > 0) formatedAddress += '<br/>';\n    formatedAddress = address.street;\n  }\n\n  if (address.city && address.state) {\n    if (formatedAddress && formatedAddress.length > 0) formatedAddress += '<br/>';\n    formatedAddress += address.city + ', ' + address.state;\n  } else if (address.city) {\n    if (formatedAddress && formatedAddress.length > 0) formatedAddress += '<br/>';\n    formatedAddress += address.city;\n  }\n\n  if (address.postalCode) {\n    formatedAddress += ' ' + address.postalCode;\n  }\n\n  if (address.country) {\n    if (formatedAddress && formatedAddress.length > 0) formatedAddress += '<br/>';\n    formatedAddress += address.country;\n  }\n\n  return formatedAddress;\n}\n/**\n *\n */\n\n\nfunction gp_updateRecordSearchMarker(searchRecordPOI, poiCollection, setCenter, addToMap) {\n  if (addToMap === undefined) addToMap = true;\n\n  if (setCenter) {\n    gp_map.panTo(new google.maps.LatLng(searchRecordPOI.lat, searchRecordPOI.lng));\n\n    if (gp_getZoomLevel() < 13) {\n      gp_map.setZoom(13);\n    }\n  }\n\n  searchRecordPOI.fullAddress = formatMultiLineAddress(searchRecordPOI);\n\n  if (gp_recordSearchMarker != null && gp_markers['gp_recordSearchPoi']) {\n    gp_removeMarkerMap(gp_recordSearchMarker.uniqueID);\n    gp_recordSearchMarker = null;\n  }\n\n  const recordLatLng = new google.maps.LatLng(searchRecordPOI.lat, searchRecordPOI.lng); //Update search center location\n\n  gp_radialSearchCenter = {\n    lat: searchRecordPOI.lat,\n    lng: searchRecordPOI.lng,\n    recordId: null\n  };\n  const image = {\n    url: searchPinURL,\n    type: 'RecordSearch',\n    scaledSize: new google.maps.Size(25, 40),\n    // This marker is 20 pixels wide by 32 pixels tall.\n    anchor: new google.maps.Point(13, 32) // The anchor for this image is the base of the flagpole at 0,32.\n\n  };\n  const gp_recSearchMark = gp_createMarker(recordLatLng, \"<b>\".concat(searchRecordPOI.singleLineAddress, \"</b>\"), undefined, image, 'gp_recordSearchPoi');\n  gp_recSearchMark.recordId = searchRecordPOI.sfdcId;\n  gp_markers[searchRecordPOI.uniqueId] = gp_recSearchMark;\n  gp_recordSearchMarker = gp_recSearchMark;\n\n  if (addToMap) {\n    gp_recSearchMark.setMap(gp_map);\n  }\n}\n\nfunction gp_updateSearchMarker(address, isGotoMyLocation) {\n  var _gp_searchMarker, _gp_searchMarker$icon;\n\n  //1 Center the map on result\n  gp_map.panTo(new google.maps.LatLng(address.lat, address.lng));\n\n  if (gp_getZoomLevel() < 13) {\n    gp_map.setZoom(13);\n  } //2 Remove existing center map marker if it exists\n\n\n  if (gp_searchMarker != null && gp_markers['gp_mapSearchPoi']) {\n    gp_removeMarkerMap(gp_searchMarker.uniqueID);\n    gp_searchMarker = null;\n  } //3 Add new center map marker\n\n\n  const g_latlon = new google.maps.LatLng(address.lat, address.lng); //Update search center location\n\n  gp_radialSearchCenter = {\n    lat: address.lat,\n    lng: address.lng,\n    recordId: null\n  };\n  jQuery('#centerContextTitleOutput').html('<span notranslate>' + gp_DOMPurify.sanitize(address.fullAddress) + '</span>');\n  setDataSetTabMaxHeight();\n  const thisPOI = {\n    name: address.name,\n    title: address.name,\n    recordId: '',\n    street: address.street,\n    city: address.city,\n    postalCode: address.postalCode,\n    state: address.state,\n    country: address.country,\n    lat: address.lat,\n    lng: address.lng,\n    markerURL: (_gp_searchMarker = gp_searchMarker) === null || _gp_searchMarker === void 0 ? void 0 : (_gp_searchMarker$icon = _gp_searchMarker.icon) === null || _gp_searchMarker$icon === void 0 ? void 0 : _gp_searchMarker$icon.url,\n    placeId: address.placeId\n  };\n\n  if (gp_searchMarker && gp_searchMarker.icon) {\n    thisPOI.markerURL = gp_searchMarker.icon.url;\n  }\n\n  if (address.source == 'googlePlace') {\n    thisPOI.phone = address.phone;\n    thisPOI.website = address.website;\n  }\n\n  const image = {\n    url: searchPinURL,\n    scaledSize: new google.maps.Size(25, 40),\n    // This marker is 20 pixels wide by 32 pixels tall.\n    anchor: new google.maps.Point(13, 32) // The anchor for this image is the base of the flagpole at 0,32.\n\n  }; // SECURITY: gp_createMarker must be called with sanitized html (3rd parameter). tmpInfoContentHTML was sanitized during its construction above\n\n  const g_marker = gp_createMarker(g_latlon, '<b>' + address.singleLineAddress + '</b>', undefined, image, 'gp_mapSearchPoi');\n  gp_markers[g_marker.uniqueID] = g_marker;\n  gp_searchMarker = g_marker;\n  g_marker.setMap(gp_map);\n} //--------DRAWING AND POLYGON/SHAPE SEARCH METHODS----------\n\n\nvar polygonObjects = {}; //keeps track of polygons on the map\n// Defaults to Rectangle mode\n\nfunction gp_enterDrawMode(mode) {\n  if (!gp_drawingManager) return; // Throw error instead?\n\n  gp_isDrawingMode = true; //Remove selected class from other drawtool buttons*/\n\n  jQuery('.drawToolOption').removeClass('gp-btn-selected'); //Enable drawing mode\n\n  gp_drawingManager.setMap(gp_map);\n\n  if (mode == 'polygon') {\n    //Add the selected class to the polygon drawtool\n    jQuery('.drawPolygon').addClass('gp-btn-selected');\n    gp_drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);\n  } else if (mode == 'polyline') {\n    //Add the selected class to the polyline drawtool\n    jQuery('.drawPolyline').addClass('gp-btn-selected');\n    gp_drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYLINE);\n  } else if (mode == 'circle') {\n    //Add the selected class to the circle drawtool\n    jQuery('.drawCircle').addClass('gp-btn-selected');\n    gp_drawingManager.setDrawingMode(google.maps.drawing.OverlayType.CIRCLE);\n  } else {\n    // default to rectangle\n    //Add the selected class to the rectangle drawtool\n    jQuery('.drawRect').addClass('gp-btn-selected');\n    gp_drawingManager.setDrawingMode(google.maps.drawing.OverlayType.RECTANGLE);\n  }\n}\n\nfunction gp_exitDrawMode() {\n  jQuery('.drawToolOption').removeClass('gp-btn-selected');\n  jQuery('.drawHand').addClass('gp-btn-selected');\n\n  if (gp_drawingManager) {\n    gp_drawingManager.setDrawingMode(null);\n  }\n}\n\nfunction setPolylineBufferPolygon(polyline) {\n  let buffPoly = polyline.bufferPolygon;\n  const dlss = angular.element('#dataLayerDirective').injector().get('dataLayerSearchService');\n  const turfLine = dlss.convertShapeToTurfFeature(polyline);\n  const useUnits = _.includes(['m', 'mi', 'miles'], polyline.gpProperties.nearbySearchDistanceUnits) ? 'miles' : 'kilometers';\n  const useRange = Number(polyline.gpProperties.range);\n  let nearLinePoly = null;\n\n  if (buffPoly) {\n    // dispose of any previous bufferPolygon, we're either going to replace it or be rid of it\n    buffPoly.setMap(null);\n  }\n\n  if (!useRange) {\n    // no range (0 or blank) means no buffer\n    delete polyline.bufferPolygon;\n  } else {\n    // Need to set a higher tolerance to calculate buffers with an extremely large amount of coordinates\n    // Every 100,000 coordinates the tolerance increases by 0.0001\n    const baseTolerance = 0.0001;\n    const maxTolerance = 0.001;\n    const toleranceIncreaseCutOff = 100000;\n    const coordinateCount = turfLine.geometry.coordinates.length;\n    const tolerance = (Math.floor(coordinateCount / toleranceIncreaseCutOff) + 1) * baseTolerance; // Cutting off at 1,000,000 coordinates as the tolerance needed begins to not be as accurate.\n\n    if (tolerance > maxTolerance) {\n      const toasterDetails = {\n        isSuccess: false,\n        message: 'The route is too long to create a buffer. Try decreasing the length of your route.'\n      };\n      gp_events.emit('toasterMessage', toasterDetails);\n      return null;\n    } // Simplify the buffer line before creating the buffer shape for better performance\n\n\n    const options = {\n      tolerance: tolerance,\n      highQuality: false\n    };\n    const simplifiedLine = turf.simplify(turfLine, options);\n    nearLinePoly = turf.buffer(simplifiedLine, useRange, {\n      units: useUnits\n    });\n    const bufferLatLngs = [];\n    nearLinePoly.geometry.coordinates.forEach(arr => {\n      arr.forEach(pt => {\n        bufferLatLngs.push({\n          lat: pt[1],\n          lng: pt[0]\n        });\n      });\n    });\n    buffPoly = new google.maps.Polygon({\n      paths: bufferLatLngs,\n      fillColor: polyline.strokeColor,\n      fillOpacity: polyline.strokeOpacity * 0.35,\n      strokeColor: polyline.strokeColor,\n      strokeOpacity: polyline.strokeOpacity * 0.5,\n      strokeWeight: 0.5\n    });\n    buffPoly.gpProperties = _objectSpread({}, polyline.gpProperties); // search area becomes an extension of its parent shape\n\n    buffPoly.gpProperties.gpType = 'polygon';\n    buffPoly.gpProperties.originalColor = buffPoly.fillColor;\n    buffPoly.gpProperties.originalOpacity = buffPoly.fillOpacity;\n    polyline.bufferPolygon = buffPoly;\n    buffPoly.setMap(gp_map);\n    buffPoly.gpProperties.bounds = buffPoly.getBounds();\n    buffPoly.clickable = true;\n    gp_addShapeWindowListener(buffPoly);\n    polyline.gpProperties.bounds = buffPoly.gpProperties.bounds; // make polyline listen to its entire buffer\n  }\n\n  angular.element('#ngApp').scope().$broadcast('layersChanged', {\n    doApply: true\n  });\n  return nearLinePoly;\n} // This can be called for a regular shape search (params.searchType=='shape'), or a nearbyShape search (params.searchType=='nearbyShape').\n// If nearbyShape, or if shape is a Line shape or Route polyline, params will also include range, nearbySearchUnits, nearbySearchDistanceUnits\n\n\nfunction doPolygonSearch(params, dataSet, isGroup, callback) {\n  //{overlayId: id of shape, groupLayerId: id group layer, jqThis: jQuery(this)}\n  callback = callback || function () {}; //If there are no polygons, tell user to add one.  do not do a search\n\n\n  if (params.overlayId === 'activeRoute') {\n    if (!gp_routes.activeRouteId) {\n      callback(true);\n      jQuery.extend(toastr.options, {\n        timeOut: 5000\n      });\n      toastr.warning('Please add a route to the map before performing a Route search.');\n      return;\n    }\n  } else {\n    // polygonObjects may contain unmapped objects if any Calendar route polylines\n    // have been hidden\n    var mappedPolys = _.filter(polygonObjects, 'map');\n\n    if (mappedPolys.length === 0) {\n      callback(true);\n      jQuery.extend(toastr.options, {\n        timeOut: 5000\n      });\n      toastr.warning('Please add a shape to the map before performing a Shape search.');\n      return;\n    } else if (null == params.overlayId) {\n      // if we're not searching from a specific shape, check whether the map\n      // contains ONLY line shapes, and NONE of them have search buffers\n      var warnNullSearch = true;\n\n      _.each(mappedPolys, function (poly) {\n        if (poly.gpProperties.gpType !== 'polyline' || poly.gpProperties.range) {\n          warnNullSearch = false;\n          return false; // abort _.each\n        }\n      });\n\n      if (warnNullSearch) {\n        callback(true);\n        jQuery.extend(toastr.options, {\n          timeOut: 5000\n        });\n        toastr.warning('Please set buffer size for a Line shape on the map before performing a Shape search.');\n        return;\n      }\n    }\n  } //Create options object\n\n\n  var options = {};\n  if (dataSet) options.dataSetObject = dataSet;\n  options.searchType = 'shape';\n  if (isGroup) options.autoLoad = true; // If nearbyShape, add additional options\n\n  if (params.searchType == 'nearbyShape') {\n    options.searchType = 'nearbyShape';\n    options.range = params.range;\n    options.radialCenterLat = params.radialCenterLat;\n    options.radialCenterLng = params.radialCenterLng;\n    options.nearbySearchUnits = params.nearbySearchUnits;\n    options.nearbySearchDistanceUnits = params.nearbySearchDistanceUnits;\n    options.nearbySearchTime = params.nearbySearchTime;\n    options.calcDriveDistance = true;\n  } //Loop through all of the objects on the map and build bound boxes for each shape\n\n\n  var shapeBoundBoxes = []; //If overlay id for a shape was defined only search this bound box\n\n  if ('activeRoute' === params.overlayId) {\n    // Search within distance of active route\n    options.searchType = 'shape';\n    options.groupLayerId = 'activeRoute';\n    options.range = params.range;\n    options.nearbySearchUnits = params.nearbySearchDistanceUnits;\n    options.nearbySearchDistanceUnits = params.nearbySearchDistanceUnits;\n    var routeLine = gp_routes.routes[gp_routes.activeRouteId].polyline;\n    routeLine.gpProperties.range = params.range;\n    routeLine.gpProperties.nearbySearchDistanceUnits = params.nearbySearchDistanceUnits;\n    setPolylineBufferPolygon(routeLine);\n    var bounds = routeLine.bufferPolygon.getBounds();\n    var boundBox = {\n      minLat: bounds.getSouthWest().lat(),\n      maxLat: bounds.getNorthEast().lat(),\n      minLng: bounds.getSouthWest().lng(),\n      maxLng: bounds.getNorthEast().lng()\n    };\n    shapeBoundBoxes.push(boundBox);\n  } else if (params.overlayId) {\n    var searchShape = polygonObjects[params.overlayId];\n    var bounds = searchShape.getBounds();\n\n    if (searchShape.gpProperties.gpType === 'polyline' && params.range) {\n      searchShape.gpProperties.range = params.range;\n      searchShape.gpProperties.nearbySearchDistanceUnits = params.nearbySearchDistanceUnits;\n      setPolylineBufferPolygon(searchShape);\n      bounds = searchShape.bufferPolygon.getBounds();\n    }\n\n    var boundBox = {\n      minLat: bounds.getSouthWest().lat(),\n      maxLat: bounds.getNorthEast().lat(),\n      minLng: bounds.getSouthWest().lng(),\n      maxLng: bounds.getNorthEast().lng()\n    };\n    shapeBoundBoxes.push(boundBox); //Set id of over lay that is being searched on the options object\n\n    options.groupLayerId = params.overlayId;\n  } else {\n    //Else is a groupLayer search, a Geo Shape search\n    //Create an object of groupLayerId to a bounding box, as one layer could be comprised of many parts but we only want one bbox\n    var groupLayerIdBbox = {}; //Create search bounds for all of the shapes\n\n    for (key in polygonObjects) {\n      var layer = polygonObjects[key];\n      var groupLayerId = layer.gpProperties.groupLayerId; //Only process layers with groupId that was provided, if it wasnt search all shapes\n\n      if (typeof params.groupLayerId == 'undefined' || params.groupLayerId == layer.gpProperties.groupLayerId) {\n        if (typeof groupLayerIdBbox[layer.gpProperties.groupLayerId] == 'undefined') {\n          groupLayerIdBbox[groupLayerId] = new google.maps.LatLngBounds();\n        } //Extend the bounding box for this layer\n\n\n        var useBounds = layer.getBounds();\n\n        if (layer.gpProperties && layer.gpProperties.gpType === 'polyline') {\n          if (layer.bufferPolygon) {\n            useBounds = layer.bufferPolygon.getBounds();\n          } else {\n            continue; // route/line without buffer doesn't contribute to shape search\n          }\n        }\n\n        groupLayerIdBbox[groupLayerId].extend(useBounds.getNorthEast());\n        groupLayerIdBbox[groupLayerId].extend(useBounds.getSouthWest());\n      }\n    } //Now for each layer that has a bounding box populate array of bboxes that will be used in search\n\n\n    for (key in groupLayerIdBbox) {\n      var bounds = groupLayerIdBbox[key];\n      var boundBox = {\n        minLat: bounds.getSouthWest().lat(),\n        maxLat: bounds.getNorthEast().lat(),\n        minLng: bounds.getSouthWest().lng(),\n        maxLng: bounds.getNorthEast().lng()\n      };\n      shapeBoundBoxes.push(boundBox);\n    } //Set group layer Id so we only check for pois in this group of shapes being searched\n\n\n    options.groupLayerId = params.groupLayerId;\n  } //Add bound boxes to options\n\n\n  options.shapeBoundBoxes = shapeBoundBoxes; //Show the data set section by 'clicking the back to search button'\n\n  jQuery('#drawCancel').click(); //Remove the center marker if it is not a record id.  if it is, set the options.recordId\n\n  if (gp_centerPOI.recordId) {\n    options.recordId = gp_centerPOI.recordId;\n  } else if (params.searchType !== 'nearbyShape') {\n    gp_removeCenterMarker();\n    gp_centerPOI = {};\n  }\n\n  if (dataSet.refreshInterval) {\n    options.refreshInterval = dataSet.refreshInterval;\n  } // check whether cacheing new search, or reloading from cache\n\n\n  if (dataSet && dataSet.searchContext) {\n    // dynamic filter values (if any) get loaded from dataSet cache whether we're reusing the searchContext or not\n    if (dataSet.searchContext.layerSettings) {\n      options.layerSettings = dataSet.searchContext.layerSettings;\n    }\n\n    if (dataSet.searchContext.reuse && dataSet.searchContext.options) {\n      for (opt in dataSet.searchContext.options) {\n        if (dataSet.searchContext.options.hasOwnProperty(opt)) {\n          options[opt] = dataSet.searchContext.options[opt];\n        }\n      }\n    } else {\n      dataSet.searchContext.options = {\n        refreshInterval: options.refreshInterval,\n        isAutoRefresh: options.isAutoRefresh,\n        groupLoad: options.groupLoad,\n        searchType: options.searchType\n      };\n\n      if (options.searchType == 'nearbyShape') {\n        dataSet.searchContext.options.range = options.range;\n        dataSet.searchContext.options.radialCenterLat = options.radialCenterLat;\n        dataSet.searchContext.options.radialCenterLng = options.radialCenterLng;\n        dataSet.searchContext.options.nearbySearchUnits = options.nearbySearchUnits;\n        dataSet.searchContext.options.nearbySearchDistanceUnits = options.nearbySearchDistanceUnits;\n        dataSet.searchContext.options.nearbySearchTime = options.nearbySearchTime;\n        dataSet.searchContext.options.calcDriveDistance = options.calcDriveDistance;\n      }\n    }\n  } //Do the search and pass in the options\n\n\n  gp_doSearch(options, callback);\n  dataSet.searchContext.reuse = false;\n}\n\nvar gp_polyEditListenerTimeout;\n\nfunction gp_polyEditListener(overlay) {\n  window.clearTimeout(gp_polyEditListenerTimeout);\n  gp_polyEditListenerTimeout = setTimeout(function (poly) {\n    return function () {\n      gp_updateBoundsOnOverlay(poly);\n      calcRecordsInShapes(); // if ('polyline' === poly.gpProperties.gpType && _.size(gp_dataSetSearches) < 1) {\n\n      if ('polyline' === poly.gpProperties.gpType) {\n        if (poly.bufferPolygon) {\n          // line has changed - replace any existing buffer\n          poly.bufferPolygon.setMap(null);\n          delete poly.bufferPolygon;\n        }\n\n        if (_.size(gp_dataSetSearches) < 1) {\n          setPolylineBufferPolygon(poly); // this doesn't happen when no search results are on the map\n        }\n      }\n\n      calcDistanceInPolyline(poly);\n      angular.element('#ngApp').scope().$broadcast('layersChanged', {\n        doApply: true\n      });\n    };\n  }(overlay), 250);\n}\n\nfunction gp_addShapeWindowListener(overlay) {\n  gp_addLongPressListeners(overlay);\n  if (overlay) overlay.layered = false; //Add event listener to the polygon overlay to open the infowindow popup bubble\n\n  google.maps.event.addListener(overlay, 'click', function (e) {\n    if (gp_isLongPress) return;\n\n    if (typeof e.vertex !== 'undefined' && overlay.getPath().length > 2) {\n      overlay.getPath().removeAt(e.vertex);\n      return;\n    } // close new version of info window, if any\n\n\n    const payload = {\n      action: 'closeInfoWindow',\n      data: {}\n    };\n    asyncGpEmitter('InfoWindowService', payload); // Get any active wmsLayer\n\n    const wmsLayers = Object.values(gp_layers).filter(layer => {\n      if ((layer === null || layer === void 0 ? void 0 : layer.type) === 'wmsLayer' && layer !== null && layer !== void 0 && layer.visible) {\n        return true;\n      }\n\n      return false;\n    }); // Get an array of shapes that contain the clicked point\n\n    const shapesWithPoint = filterPolygonObjectsContainingPoint(e.latLng);\n    const wmsLength = wmsLayers.length;\n    const pointShapes = shapesWithPoint.length > 1;\n    gp_infoWindow.markerId = null;\n    gp_infoWindow.groupLayerId = null;\n    gp_infoWindow.wmsLayerId = null;\n    gp_infoWindow.thematicLayerId = null;\n    if (this) this.layered = false;\n\n    if (wmsLength || pointShapes) {\n      /* If we are opening up a multi-layer info-window we are setting a layered prop to true, so we can\n         handle closing the respective multiShapeInfowindow for the multiple overlapping layers */\n      if (wmsLength) {\n        wmsLayers.forEach(wms => {\n          wms.layered = true;\n        });\n      }\n\n      if (pointShapes) {\n        shapesWithPoint.forEach(shape => {\n          shape.layered = true;\n        });\n      }\n\n      showMultiShapeInfoWindow(e, shapesWithPoint, wmsLayers);\n    } else {\n      showSingleShapeInfoWindow(e, overlay);\n    }\n  }); // relink: passed through to shapeWindow controller's init() to indicate\n  // whether shape window should redisplay record list.\n\n  window.showSingleShapeInfoWindow = function (e, shape, relink) {\n    /* We are passing the value of false to the layered prop from the shape coming in since it will not be in\n      a multiShapeInfoWindow. This prevents the shape from retaining a possible true value to the layered prop */\n    let content = null;\n\n    if (shape) {\n      shape.layered = false;\n      content = shape;\n    } else {\n      content = overlay;\n    } // If the map is in measure distance mode, add point to ruler  may want to refactor this?\n\n\n    if (gp_mapMode == 'measureDistance') {\n      gp_rulerTool.addPinToRuler(e);\n      return;\n    }\n\n    gp_infoWindow.setOptions({\n      pixelOffset: {\n        height: 0,\n        width: 0\n      }\n    });\n    gp_infoWindow.setContent('<div id=\"shapeInfoWindowWrapper\"><shape-info-window></shape-info-window></div>');\n    gp_infoWindow.setPosition(e.latLng);\n    gp_infoWindow.markerId = content.gpProperties.uniqueId;\n    gp_infoWindow.layered = false;\n    gp_infoWindow.groupLayerId = content.gpProperties.groupLayerId;\n    gp_infoWindow.open(gp_map);\n    jQuery('#shapeInfoWindowWrapper').parent().parent().parent().parent().parent().css('visibility', 'hidden');\n\n    _.defer(function () {\n      jQuery('#shapeInfoWindowWrapper').parent().parent().parent().parent().parent().css('visibility', 'hidden');\n      angular.element('#ngApp').scope().linkToAngular(angular.element('#shapeInfoWindowWrapper'));\n    });\n\n    var interval = setInterval(function () {\n      if (angular.element('#shapeInfoWindow').scope()) {\n        angular.element('#shapeInfoWindow').scope().init(content, relink);\n        angular.element('#shapeInfoWindow').scope().$digest();\n        gp_infoWindow.open(gp_map);\n        jQuery('#shapeInfoWindowWrapper').parent().parent().parent().parent().parent().css('visibility', 'visible');\n        clearInterval(interval);\n      }\n    });\n  };\n\n  function showMultiShapeInfoWindow(e, shapeArray, wmsLayers) {\n    gp_infoWindow.layered = true;\n    gp_infoWindow.groupLayerId = overlay.gpProperties.groupLayerId;\n    gp_infoWindow.setOptions({\n      pixelOffset: {\n        height: 0,\n        width: 0\n      }\n    });\n    gp_infoWindow.setContent('<div id=\"multiShapeInfoWindow\" class=\"slds\"><div style=\"font-weight: bold; font-size: 14px\">Layers</div></div>');\n    gp_infoWindow.setPosition(e.latLng);\n    gp_infoWindow.markerId = overlay.gpProperties.uniqueId;\n    gp_infoWindow.open(gp_map);\n\n    function getShapeName(shape) {\n      var useShapeType = shape.gpProperties.gpType;\n      if ('polyline' === useShapeType) useShapeType = 'line';\n      return gp_DOMPurify.sanitize(shape.gpProperties.geoShapeName || shape.gpProperties.sfdcName || 'Unnamed ' + useShapeType.charAt(0).toUpperCase() + useShapeType.slice(1));\n    } // Alphabetical sort\n\n\n    shapeArray.sort(function (a, b) {\n      return getShapeName(a).toLowerCase() > getShapeName(b).toLowerCase(); // Append the links for each shape\n    }).forEach(function (shape) {\n      jQuery('<i class=\"fa fa-square\" style=\"color: ' + gp_DOMPurify.sanitize('polyline' == shape.gpProperties.gpType ? shape.strokeColor : shape.fillColor) + '\"/> ' + '<a href=\"#\">' + gp_DOMPurify.sanitize(getShapeName(shape)) + '</a>' + '<br/>').appendTo('#multiShapeInfoWindow').click(function () {\n        showSingleShapeInfoWindow(e, shape);\n      });\n    });\n    wmsLayers.forEach(layer => {\n      jQuery(\"<i class=\\\"layerIcon thematicFolderListIcon\\\" />\\n\\t\\t\\t\\t <a href=\\\"#\\\">\".concat(gp_DOMPurify.sanitize(layer.name), \"</a>\\n\\t\\t\\t\\t <br/>\\n\\t\\t\\t\\t\")).appendTo('#multiShapeInfoWindow').click(() => {\n        gp_closeInfoWindow(false);\n        layer.$$clickHandler(e);\n      });\n    });\n  }\n\n  function filterPolygonObjectsContainingPoint(latLng) {\n    return _.filter(polygonObjects, function (shape) {\n      //Only proceed with complex point in poly check if point is within the bounds of the overlay\n      if (!shape.getMap()) {\n        return false;\n      } else if (shape.gpProperties.gpType !== 'polyline' && (typeof shape.gpProperties.bounds === 'undefined' || !shape.gpProperties.bounds.contains(latLng))) {\n        return false;\n      } else if (shape.gpProperties.gpType === 'circle') {\n        var distanceFromCenterKM = getGeoDistance(shape.getCenter().lat(), shape.getCenter().lng(), latLng.lat(), latLng.lng(), 'kilometers');\n        if (distanceFromCenterKM > shape.radius / 1000) return false;\n      } else if (shape.gpProperties.gpType === 'rectangle') {\n        if (!shape.getBounds().contains(latLng)) return false;\n      } else if (shape.gpProperties.gpType === 'polyline') {\n        // if we're in mouseover (i.e. color is darkened) or failing that if we're close to the polyline,\n        // or if a search-buffer polygon is defined which contains the point, return true\n        if ((!shape.gpProperties.originalColor || shape.strokeColor == shape.gpProperties.originalColor) && !google.maps.geometry.poly.isLocationOnEdge(latLng, shape, calcZoomTolerance()) && (!shape.bufferPolygon || !google.maps.geometry.poly.containsLocation(latLng, shape.bufferPolygon))) return false;\n      } else if (!google.maps.geometry.poly.containsLocation(latLng, shape)) {\n        return false;\n      }\n\n      return true;\n    });\n  } //http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors\n\n\n  function lightenDarkenHex(color, percent) {\n    var f = parseInt(color.slice(1), 16),\n        t = percent < 0 ? 0 : 255,\n        p = percent < 0 ? percent * -1 : percent,\n        R = f >> 16,\n        G = f >> 8 & 0x00ff,\n        B = f & 0x0000ff;\n    return '#' + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);\n  } //Event listen to change the color slightly on hover\n\n\n  google.maps.event.addListener(overlay, 'mouseover', function (e) {\n    if (undefined == overlay.gpProperties.originalOpacity) overlay.gpProperties.originalOpacity = parseFloat(overlay.fillOpacity || overlay.strokeOpacity); // polyline has no fill\n\n    if (undefined == overlay.gpProperties.originalColor) overlay.gpProperties.originalColor = 'polyline' == overlay.gpProperties.gpType ? overlay.strokeColor : overlay.fillColor; //Only set darker opacity if it is less or equal to 70\n\n    var newOpacity = parseFloat('polyline' == overlay.gpProperties.gpType ? overlay.strokeOpacity : overlay.fillOpacity);\n    if (newOpacity <= 0.7) newOpacity += 0.2;\n    var newColor = lightenDarkenHex('polyline' == overlay.gpProperties.gpType ? overlay.strokeColor : overlay.fillColor, -0.2);\n\n    if ('polyline' == overlay.gpProperties.gpType) {\n      overlay.setOptions({\n        strokeOpacity: newOpacity,\n        strokeColor: newColor\n      });\n\n      if (overlay.bufferPolygon && overlay.bufferPolygon.fillOpacity === overlay.bufferPolygon.gpProperties.originalOpacity) {\n        var newBuffOpacity = parseFloat(overlay.bufferPolygon.gpProperties.originalOpacity);\n        var newBuffColor = lightenDarkenHex(overlay.bufferPolygon.gpProperties.originalColor, -0.2);\n        if (newBuffOpacity <= 0.7) newBuffOpacity += 0.2;\n        overlay.bufferPolygon.setOptions({\n          fillOpacity: newBuffOpacity,\n          fillColor: newBuffColor\n        });\n      }\n    } else {\n      overlay.setOptions({\n        fillOpacity: newOpacity,\n        fillColor: newColor\n      });\n    }\n  });\n  google.maps.event.addListener(overlay, 'mouseout', function (e) {\n    //For all polygons that are part of this layer change the color back to orginal before hover\n    if ('polyline' == overlay.gpProperties.gpType) {\n      overlay.setOptions({\n        strokeOpacity: overlay.gpProperties.originalOpacity,\n        strokeColor: overlay.gpProperties.originalColor\n      });\n\n      if (overlay.bufferPolygon && overlay.bufferPolygon.fillOpacity !== overlay.bufferPolygon.gpProperties.originalOpacity) {\n        overlay.bufferPolygon.setOptions({\n          fillOpacity: overlay.bufferPolygon.gpProperties.originalOpacity,\n          fillColor: overlay.bufferPolygon.gpProperties.originalColor\n        });\n      }\n    } else {\n      overlay.setOptions({\n        fillOpacity: overlay.gpProperties.originalOpacity,\n        fillColor: overlay.gpProperties.originalColor\n      });\n    }\n  }); //Create a right click event listener on the shape to open the right click context menu\n\n  google.maps.event.addListener(overlay, 'rightclick', function (e) {\n    gp_openRigthClickMenu(e); //Open the right click menu\n  });\n}\n\nfunction isCalRouteId(id) {\n  // Calendar route id has the form 'YYYY-MM-DD'\n  return moment(id, 'YYYY-MM-DD', true).isValid() || moment(id, moment.ISO_8601).isValid();\n}\n\nfunction gp_shapeAddedToMap(overlay, type) {\n  //Exit draw mode\n  gp_exitDrawMode(); //Create a gpProperties object if it does not exist\n\n  if (typeof overlay.gpProperties == 'undefined') {\n    overlay.gpProperties = {};\n  } //Calculate and set the bounds for this\n\n\n  gp_updateBoundsOnOverlay(overlay); //Create a unique Id for this overlay, if needed (route/calendar polyline is special)\n\n  if (!overlay.gpProperties.uniqueId || 'activeRoute' !== overlay.gpProperties.uniqueId && !isCalRouteId(overlay.gpProperties.uniqueId)) {\n    overlay.gpProperties.uniqueId = guid();\n  } //Create a group layer Id if one does not alreay exist\n\n\n  if (typeof overlay.gpProperties.groupLayerId == 'undefined') {\n    overlay.gpProperties.groupLayerId = guid();\n  } //Set custom properties to empty string if they are null\n\n\n  if (!overlay.gpProperties.sfdcName) {\n    overlay.gpProperties.sfdcName = '';\n  }\n\n  if (!overlay.gpProperties.sfdcDescription) {\n    overlay.gpProperties.sfdcDescription = '';\n  } //Set type\n\n\n  overlay.gpProperties.gpType = type.toLowerCase(); //Specialy handling for shape fields\n\n  if (!overlay.gpProperties.usageType) {\n    overlay.gpProperties.usageType = 'Standard';\n\n    if (gp_mapMode == 'addShape') {\n      overlay.gpProperties.usageType = 'Shape Field'; //Set different color\n\n      var controller = angular.element('.shapeFieldTypeController').scope();\n      var color = controller.color;\n\n      if (color.indexOf('#') != 0) {\n        color = '#' + color;\n      }\n\n      if ('polyline' == overlay.gpProperties.gpType) {\n        overlay.setOptions({\n          clickable: false,\n          strokeColor: color,\n          strokeOpacity: controller.opacity\n        });\n      } else {\n        overlay.setOptions({\n          clickable: false,\n          fillColor: color,\n          fillOpacity: controller.opacity\n        });\n      } //Set overlay in controller\n\n\n      controller.overlay = overlay;\n    }\n  } // when adding (possibly restoring) a Route or Calendar Route to the map, check to see\n  // whether it already has a search buffer defined and if so, restore it\n\n\n  if (isCalRouteId(overlay.gpProperties.uniqueId) || 'activeRoute' === overlay.gpProperties.uniqueId) {\n    var oldSearchLine = polygonObjects[overlay.gpProperties.uniqueId];\n\n    if (oldSearchLine && !oldSearchLine.bufferPolygon && oldSearchLine.gpProperties && oldSearchLine.gpProperties.range) {\n      overlay.gpProperties.range = oldSearchLine.gpProperties.range;\n      overlay.gpProperties.nearbySearchDistanceUnits = oldSearchLine.gpProperties.nearbySearchDistanceUnits;\n      setPolylineBufferPolygon(overlay);\n    } else if (oldSearchLine && oldSearchLine.bufferPolygon) {\n      overlay.bufferPolygon = oldSearchLine.bufferPolygon;\n      overlay.bufferPolygon.setMap(gp_map);\n    } else if (!oldSearchLine && overlay.gpProperties.range && overlay.gpProperties.nearbySearchDistanceUnits) {\n      setPolylineBufferPolygon(overlay);\n    }\n  } //Add the polygon to the polygonObjects object to keep track of shapes on the map\n\n\n  polygonObjects[overlay.gpProperties.uniqueId] = overlay; //Update record count in shapes\n\n  calcRecordsInShapes();\n\n  if ('polyline' == overlay.gpProperties.gpType) {\n    if (google.maps.geometry) {\n      calcDistanceInPolyline(overlay);\n    } else {\n      // if polyline is first shape loaded, we may need to give google a chance to rev up\n      setTimeout(function (poly) {\n        return function () {\n          calcDistanceInPolyline(poly);\n        };\n      }(overlay), 500);\n    }\n  }\n\n  gp_addShapeWindowListener(overlay); // Event listener for when circle changes\n\n  if (overlay.gpProperties.gpType == 'circle') {\n    google.maps.event.addListener(overlay, 'radius_changed', function () {\n      gp_updateBoundsOnOverlay(overlay);\n      calcRecordsInShapes();\n    });\n    google.maps.event.addListener(overlay, 'center_changed', function () {\n      if (overlay.mapLabel) {\n        overlay.mapLabel.position = overlay.center;\n        overlay.mapLabel.setMap(overlay.gpProperties.showLabel ? gp_map : null);\n      }\n\n      gp_updateBoundsOnOverlay(overlay);\n      calcRecordsInShapes();\n    });\n  }\n\n  if (overlay.gpProperties.gpType == 'rectangle') {\n    google.maps.event.addListener(overlay, 'bounds_changed', function () {\n      if (overlay.mapLabel) {\n        overlay.mapLabel.position = overlay.bounds.getCenter();\n        overlay.mapLabel.setMap(overlay.gpProperties.showLabel ? gp_map : null);\n      }\n\n      gp_updateBoundsOnOverlay(overlay);\n      calcRecordsInShapes();\n    });\n  } //Event listeners for when polygon shape changes\n\n\n  google.maps.event.addListener(overlay, 'mousedown', function (e) {\n    if (overlay.gpProperties.gpType == 'polygon' || overlay.gpProperties.gpType == 'polyline') {\n      google.maps.event.addListener(overlay.getPath(), 'set_at', function () {\n        return gp_polyEditListener(overlay);\n      });\n      google.maps.event.addListener(overlay.getPath(), 'insert_at', function () {\n        return gp_polyEditListener(overlay);\n      });\n      google.maps.event.addListener(overlay.getPath(), 'remove_at', function () {\n        return gp_polyEditListener(overlay);\n      });\n    }\n  });\n}\n\nfunction gp_updateBoundsOnOverlay(overlay) {\n  if (!overlay) //getPaths() check makes sure it is a polygon and not a shape file server\n    return;\n\n  try {\n    if (overlay.bounds) {\n      overlay.gpProperties.bounds = overlay.bounds;\n    } else if (overlay.getBounds) {\n      overlay.gpProperties.bounds = overlay.getBounds();\n    } else {\n      var bounds = new google.maps.LatLngBounds();\n      var paths = overlay.getPaths();\n      var path;\n\n      for (var i = 0; i < paths.getLength(); i++) {\n        path = paths.getAt(i);\n\n        for (var ii = 0; ii < path.getLength(); ii++) {\n          bounds.extend(path.getAt(ii));\n        }\n      }\n\n      overlay.gpProperties.bounds = bounds;\n    }\n  } catch (e) {// Do something?\n  }\n}\n\nfunction showShapeActions(shapeId) {\n  //Get the shape\n  var shape = polygonObjects[shapeId];\n\n  if (!shape) {\n    // if no shape, then something's just been removed\n    gp_closeInfoWindow(false);\n    return;\n  }\n\n  var $shapeActionBtn = jQuery('#shapeActionsBtn');\n  var actionButtonOffset = $shapeActionBtn.offset(); //Only show delete button if record has sfdc id, TODO remove this, moved to edit modal\n\n  var deleteDisplaySanitized = 'none';\n\n  if (shape.gpProperties.sfdcId) {\n    deleteDisplaySanitized = '';\n  } //Determine if this is a multi part shape, ie one layer consisting of many sub shapes\n\n\n  var subShapeCount = 0;\n  var multiPartShape = false;\n\n  for (key in polygonObjects) {\n    if (shape.gpProperties.groupLayerId == polygonObjects[key].gpProperties.groupLayerId) {\n      subShapeCount++;\n    }\n\n    if (subShapeCount > 1) {\n      multiPartShape = true;\n      break;\n    }\n  } //Remove action menu element already exists\n\n\n  jQuery('.shapeActionMenu').remove();\n  var saveMethodSanitized = 'gp_saveShape';\n  if (shape.gpProperties.usageType == 'GeoShape') saveMethodSanitized = 'gp_editShape';\n  const uniqueIdSanitized = gp_DOMPurify.sanitize(shape.gpProperties.uniqueId);\n  var htmlString = '<div class=\"multiButtonContent shapeActionMenu\">';\n\n  if (multiPartShape) {\n    htmlString += '<div class=\"multiButtonOptionHeader\">' + gp_DOMPurify.sanitize(shape.gpProperties.sfdcName) + '</div>';\n  }\n\n  if (shape.gpProperties.usageType == 'GeoShape') {\n    htmlString += '<div class=\"multiButtonOption\" onclick=\"angular.element(\\'#ShapeSearchDataSetSelectorController\\').scope().openSelector({groupLayerId: \\'' + gp_DOMPurify.sanitize(shape.gpProperties.groupLayerId) + '\\'}); return false;\">' + '<span class=\"multiButtonOptionText\">' + gp_DOMPurify.sanitize(gp_translations.Search) + '</span>' + '</div>';\n    htmlString += '<div class=\"multiButtonOption\" onclick=\"gp_downloadShapeDetails(\\'' + shape.gpProperties.sfdcId + '\\')\">' + '<span class=\"multiButtonOptionText\">Download Shape Details</span>' + '</div>';\n  } else {\n    htmlString += '<div class=\"multiButtonOption\" onclick=\"angular.element(\\'#ShapeSearchDataSetSelectorController\\').scope().openSelector({overlayId: \\'' + uniqueIdSanitized + '\\'}); return false;\">' + '<span class=\"multiButtonOptionText\">' + gp_DOMPurify.sanitize(gp_translations.Search) + '</span>' + '</div>';\n  }\n\n  if ('polyline' == shape.gpProperties.gpType) {\n    htmlString += '<div class=\"multiButtonOption\" onclick=\"angular.element(\\'#ShapeSearchDataSetSelectorController\\').scope().openSetBufferSize(\\'' + uniqueIdSanitized + '\\'); return false;\">' + '<span class=\"multiButtonOptionText\">' + 'Set Buffer Size' + '</span>' + '</div>';\n\n    if (shape.gpProperties.range) {\n      htmlString += '<div class=\"multiButtonOption\" onclick=\"angular.element(\\'#ShapeSearchDataSetSelectorController\\').scope().clearBufferSize(\\'' + uniqueIdSanitized + '\\'); return false;\">' + '<span class=\"multiButtonOptionText\">' + 'Clear Buffer' + '</span>' + '</div>';\n    }\n  }\n\n  htmlString += '<div class=\"multiButtonOption\" onclick=\"gp_removeShape(\\'' + uniqueIdSanitized + '\\'); return false;\">' + '<span class=\"multiButtonOptionText\">' + gp_DOMPurify.sanitize(gp_translations.Remove) + '</span>' + '</div>'; // if this is a multipolygon with a standard usageType, don't allow edit in the menu actions\n\n  var isStandardMultiPolygon = shape.gpProperties.gpType === 'multipolygon' && shape.gpProperties.usageType === 'Standard';\n\n  if (shape.gpProperties.readOnly != true && uniqueIdSanitized != 'activeRoute' && !isStandardMultiPolygon && !isCalRouteId(uniqueIdSanitized)) {\n    htmlString += '<div class=\"multiButtonOption\" onclick=\"gp_editShape(\\'' + uniqueIdSanitized + '\\'); return false;\">' + '<span class=\"multiButtonOptionText\">' + gp_DOMPurify.sanitize(gp_translations.Edit) + '</span>' + '</div>';\n  }\n\n  if (shape.gpProperties.usageType != 'Shape Field') {\n    if (shape.gpProperties.usageType != 'GeoShape' && (isGeopointeAdmin || shape.gpProperties.folderId == angular.element('.dataSetController').scope().folderService.getPersonalFolder().id || !shape.gpProperties.sfdcId || shape.gpProperties.sfdcId && shape.gpProperties.accessLevel == 'edit')) {\n      htmlString += '<div class=\"multiButtonOption\" onclick=\"' + saveMethodSanitized + \"('\" + uniqueIdSanitized + '\\'); return false;\">' + '<span class=\"multiButtonOptionText\">' + gp_DOMPurify.sanitize(gp_translations.Save) + '</span>' + '</div>';\n    }\n\n    if (shape.gpProperties.usageType != 'GeoShape' && shape.gpProperties.sfdcId) {\n      htmlString += '<div class=\"multiButtonOption\" onclick=\"' + saveMethodSanitized + \"('\" + uniqueIdSanitized + '\\',true); return false;\">' + '<span class=\"multiButtonOptionText\">Save As</span>' + '</div>';\n    }\n    /*\t                    if(shape.gpProperties.sfdcId && shape.gpProperties.usageType != 'GeoShape' &&){\n    htmlString+=\t        \t'<div class=\"multiButtonOption\" onclick=\"window.open(\\'/p/share/CustomObjectSharingDetail?parentId='+shape.gpProperties.sfdcId+'\\'); return false;\">'+\n                              '<span class=\"multiButtonOptionText\">'+\n                                  'Sharing'+\n                              '</span>'+\n                          '</div>';\n                      }*/\n\n  }\n\n  if (shape.gpProperties.readOnly != true && shape.gpProperties.usageType != 'GeoShape' && (isGeopointeAdmin || shape.gpProperties.folderId == angular.element('.dataSetController').scope().folderService.getPersonalFolder().id || !shape.gpProperties.sfdcId || shape.gpProperties.sfdcId && shape.gpProperties.accessLevel == 'edit')) {\n    htmlString += '<div class=\"multiButtonOption\" onclick=\"gp_deleteShapeConfirm(\\'' + uniqueIdSanitized + '\\'); return false;\" style=\"display: ' + deleteDisplaySanitized + ';\" >' + '<span class=\"multiButtonOptionText\">' + gp_DOMPurify.sanitize(gp_translations.Delete) + '</span>' + '</div>';\n  } //Build html for custom list actions\n\n\n  var actionsHTML = getCustomShapeActionsHTML(shape, shape.gpProperties.groupLayerId); // SECURITY: getCustomShapeActionsHTML returns a sanitized string\n  //If there were custom actions add to list of options\n\n  if (actionsHTML != '') {\n    htmlString += '<hr/>' + actionsHTML;\n  } //If this was a multipart shape build actions specific to the sub shape that was selected\n\n\n  if (multiPartShape) {\n    htmlString += '<div class=\"multiButtonOptionHeader\">' + gp_DOMPurify.sanitize(shape.gpProperties.geoShapeName) + '</div>';\n    htmlString += '<div class=\"multiButtonOption\" onclick=\"angular.element(\\'#ShapeSearchDataSetSelectorController\\').scope().openSelector({overlayId: \\'' + uniqueIdSanitized + '\\'}); return false;\">' + '<span class=\"multiButtonOptionText\">' + gp_DOMPurify.sanitize(gp_translations.Search) + '</span>' + '</div>';\n    htmlString += '<div class=\"multiButtonOption\" onclick=\"gp_downloadShapeDetails(\\'' + uniqueIdSanitized + \"', 'uniqueId')\\\">\" + '<span class=\"multiButtonOptionText\">Download Shape Details</span>' + '</div>';\n\n    if (_.find(gp_layers, ['dataType', 'zoominfo'])) {\n      htmlString += \"<div class=\\\"multiButtonOption\\\" onclick=\\\"angular.element('#modalListDirective').scope().initFromOverlay('zoominfo', {overlayId: '\" + uniqueIdSanitized + \"'}, 'Companies'); return false;\\\">\" + '<span class=\"multiButtonOptionText\">' + 'Import Companies' + '</span>' + '</div>';\n    }\n\n    htmlString += '<div class=\"multiButtonOption\" onclick=\"gp_removeSubShape(\\'' + uniqueIdSanitized + '\\'); return false;\"\">' + '<span class=\"multiButtonOptionText\">' + gp_DOMPurify.sanitize(gp_translations.Remove) + '</span>' + '</div>';\n    var actionsHTML = getCustomShapeActionsHTML(shape, uniqueIdSanitized); // SECURITY: getCustomShapeActionsHTML returns a sanitized string\n    //If there were custom actions add to list of options\n\n    if (actionsHTML != '') {\n      htmlString += '<hr/>';\n      htmlString += actionsHTML;\n    }\n  }\n\n  htmlString += '</div>';\n  gp_disableMultiButtonContentClose = true; // SECURITY: htmlString sanitized during construction above\n\n  jQuery(htmlString).appendTo('body').show().css({\n    top: actionButtonOffset.top + $shapeActionBtn.outerHeight(),\n    left: actionButtonOffset.left\n  });\n  setTimeout(function () {\n    gp_disableMultiButtonContentClose = false;\n  }, 1);\n} // SECURITY: Returns sanitized html string\n\n\nfunction getCustomShapeActionsHTML(shape, shapeId) {\n  var objects = {}; //Use object keys to keep unique list of map objects\n\n  var actionsHTML = ''; //Build a list off objects in which we should build the action list for\n\n  try {\n    if (gp_aggregates.shapes[shapeId]) {\n      _.forEach(gp_aggregates.shapes[shapeId].dataSets, function (dataSet) {\n        objects[dataSet.objectName] = true;\n      });\n    } else if (gp_aggregates.shapeGroups[shapeId]) {\n      _.forEach(gp_aggregates.shapeGroups[shapeId].counts, function (count, object) {\n        objects[object] = true;\n      });\n    }\n  } catch (e) {\n    console.log(e);\n  }\n\n  const shapeIdSanitized = gp_DOMPurify.sanitize(shapeId); //Loop through all of the geopointe actions\n\n  for (var i = 0; i < getOrderedActionsArray().length; i++) {\n    var action = getOrderedActionsArray()[i];\n    var actionObjects;\n\n    if (action.mapObjects) {\n      actionObjects = action.mapObjects.split(',');\n    }\n\n    var actionValidForObjects = false; //Check to see if this action should be applied to any of the data set searches based on the map object\n\n    for (key in objects) {\n      if (actionObjects.indexOf(key) > -1) {\n        actionValidForObjects = true;\n        break;\n      }\n    }\n\n    const actionIdSanitized = gp_DOMPurify.sanitize(action.id);\n    const actionNameSanitized = gp_DOMPurify.sanitize(action.name); //Only build an action if it is for all objects or one of the searched objects\n\n    if (action.applyTo == 'List' && (action.allObjects == true || actionValidForObjects == true)) {\n      if (action.standardAction) {\n        if (action.standardAction.toLowerCase() == 'add all to route') {\n          actionsHTML += '<div class=\"multiButtonOption\" onclick=\"gp_addAllToRoute(extractIdsInShape(\\'' + shapeIdSanitized + '\\'));\">' + '<span class=\"multiButtonOptionText\">' + actionNameSanitized + '</span>' + '</div>';\n        } else if (action.standardAction.toLowerCase() == 'add to campaign') {\n          actionsHTML += '<div class=\"multiButtonOption\" onclick=\"gp_trackAddToCampaign(); executeShapePOSTAction(\\'' + actionIdSanitized + \"','\" + shapeIdSanitized + '\\');\">' + '<span class=\"multiButtonOptionText\">' + actionNameSanitized + '</span>' + '</div>';\n        } else if (action.standardAction.toLowerCase() == 'change owner') {\n          actionsHTML += '<div class=\"multiButtonOption\" onclick=\"gp_trackChangeOwner(); executeShapePOSTAction(\\'' + actionIdSanitized + \"','\" + shapeIdSanitized + '\\');\">' + '<span class=\"multiButtonOptionText\">' + actionNameSanitized + '</span>' + '</div>';\n        } else if (action.standardAction.toLowerCase() == 'update field') {\n          actionsHTML += '<div class=\"multiButtonOption\" onclick=\"gp_trackUpdateField(); executeShapePOSTAction(\\'' + actionIdSanitized + \"','\" + shapeIdSanitized + '\\');\">' + '<span class=\"multiButtonOptionText\">' + actionNameSanitized + '</span>' + '</div>';\n        } else if (action.standardAction.toLowerCase() == 'export csv' && gp_userSettings.userInfo.exportReports) {\n          actionsHTML += '<div class=\"multiButtonOption\" onclick=\"executeShapePOSTAction(\\'' + actionIdSanitized + \"','\" + shapeIdSanitized + '\\');\">' + '<span class=\"multiButtonOptionText\">' + actionNameSanitized + '</span>' + '</div>';\n        } else if (action.standardAction.toLowerCase() == 'export kml' && gp_userSettings.userInfo.exportReports) {\n          actionsHTML += '<div class=\"multiButtonOption\" onclick=\"executeShapePOSTAction(\\'' + actionIdSanitized + \"','\" + shapeIdSanitized + '\\');\">' + '<span class=\"multiButtonOptionText\">' + actionNameSanitized + '</span>' + '</div>';\n        } else if (action.standardAction.toLowerCase() == 'import business') {\n          if (!_.find(gp_layers, ['dataType', 'zoominfo'])) continue;\n          var shapeReference = {};\n\n          if (shape.gpProperties.uniqueId === shapeIdSanitized) {\n            shapeReference.overlayId = shapeIdSanitized;\n          } else {\n            shapeReference.groupLayerId = shapeIdSanitized;\n          }\n\n          actionsHTML += \"<div class=\\\"multiButtonOption\\\" onclick=\\\"angular.element('#modalListDirective').scope().initFromOverlay('zoominfo', \" + JSON.stringify(gp_DOMPurify.sanitize(shapeReference)).replace(/\"/g, \"'\") + \", 'Companies'); return false;\\\">\" + '<span class=\"multiButtonOptionText\">' + actionNameSanitized + '</span>' + '</div>';\n        } else if (action.standardAction.toLowerCase() == 'add to calendar list') {\n          actionsHTML += \"<div class=\\\"multiButtonOption\\\" onclick=\\\"gp_addToCalendarList('\".concat(shapeIdSanitized, \"')\\\"><span class=\\\"multiButtonOptionText\\\">\").concat(actionNameSanitized, \"</span></div>\");\n        } else if (action.standardAction.toLowerCase() === 'remove all') {\n          actionsHTML += \"<div class=\\\"multiButtonOption\\\" onclick=\\\"gp_removeRecordsListAction('\".concat(shapeIdSanitized, \"')\\\"><span class=\\\"multiButtonOptionText\\\">\").concat(actionNameSanitized, \"</span></div>\");\n        }\n      } else if (action.actionType == 'Apex') {\n        //Custom actions\n        actionsHTML += '<div class=\"multiButtonOption\" onclick=\"executeShapeApexAction(\\'' + actionIdSanitized + \"','\" + shapeIdSanitized + '\\');\">' + '<span notranslate class=\"multiButtonOptionText\">' + actionNameSanitized + '</span>' + '</div>';\n      } else if (action.actionType == 'POST (Visualforce)') {\n        actionsHTML += '<div class=\"multiButtonOption\" onclick=\"executeShapePOSTAction(\\'' + actionIdSanitized + \"','\" + shapeIdSanitized + '\\');\">' + '<span notranslate class=\"multiButtonOptionText\">' + actionNameSanitized + '</span>' + '</div>';\n      }\n    }\n  }\n\n  return actionsHTML;\n}\n\nfunction gp_editShape(uniqueId) {\n  //Get the shape\n  let overlay = polygonObjects[uniqueId]; //Unique Id may have been a groupingId for a geoshape, try to find overlay with this\n\n  if (!overlay) {\n    for (const key in polygonObjects) {\n      if (polygonObjects[key].gpProperties.groupLayerId === uniqueId) {\n        overlay = polygonObjects[key];\n        break;\n      }\n    }\n  }\n\n  if (overlay.gpProperties.usageType == 'GeoShape') {\n    const {\n      sfdcId,\n      groupLayerId,\n      sfdcName,\n      sfdcDescription,\n      folderId,\n      folderName,\n      gpType,\n      usedInAssignments,\n      dissolve,\n      showLabel,\n      subShapes\n    } = overlay.gpProperties;\n\n    const shapeFromList = _.find(angular.element('.dataSetController').scope().shapes, ['id', sfdcId]);\n\n    const isPolyLine = 'polyline' === gpType;\n    const shapeData = {\n      sfdcId,\n      id: sfdcId,\n      folderId,\n      folderName,\n      usedInAssignments,\n      showLabel,\n      dissolve,\n      layerName: sfdcName,\n      layerDescription: sfdcDescription,\n      layerNameBeforeSave: sfdcName,\n      selectedGeoShapes: {},\n      originalShapes: {},\n      subShapes,\n      initList: true,\n      isEdit: true,\n      accessLevel: shapeFromList && shapeFromList.accessLevel,\n      color: isPolyLine ? overlay.strokeColor : overlay.fillColor,\n      opacity: isPolyLine ? overlay.strokeOpacity : overlay.fillOpacity,\n      visible: true\n    };\n    gp_events.emit('multiShapeEditorService', {\n      action: 'editShape',\n      data: {\n        shapeData\n      }\n    });\n  } else if (overlay.gpProperties.usageType == 'Shape Field') {\n    gp_mapMode = 'addShape';\n    jQuery('#mapContextMenu').hide();\n    jQuery('.drawingControls').hide();\n    gp_infoWindow.setMap(null); //Hide the open info window\n    //Setup the angular controller by passing over data\n\n    var controller = angular.element('.shapeFieldTypeController').scope();\n    controller.isEdit = true;\n    controller.sfdcId = overlay.gpProperties.sfdcId;\n    controller.gpCollectionName = overlay.gpProperties.gpCollectionName;\n    controller.recordName = overlay.gpProperties.relatedRecordName;\n    controller.relatedRecordId = overlay.gpProperties.relatedRecordId;\n    controller.selectedShapeField = {\n      name: overlay.gpProperties.relatedRecordFieldName,\n      label: overlay.gpProperties.relatedRecordFieldLabel\n    };\n    controller.shapeDescription = overlay.gpProperties.sfdcDescription;\n    controller.allShapeFieldsPopulated = false;\n    controller.noShapeFields = false;\n    controller.color = 'polyline' == overlay.gpProperties.gpType ? overlay.strokeColor : overlay.fillColor;\n    controller.opacity = 'polyline' == overlay.gpProperties.gpType ? overlay.strokeOpacity : overlay.fillOpacity;\n    controller.dissolve = overlay.gpProperties.dissolve;\n    controller.showLabel = overlay.gpProperties.showLabel;\n    controller.overlay = overlay;\n    controller.centerLatLng = {\n      lat: overlay.gpProperties.recordLat,\n      lng: overlay.gpProperties.recordLng\n    };\n    controller.selectedGeoShapes = {};\n    controller.initGeoShapeList = true;\n    controller.enteringEditMode = true;\n    controller.usedInAssignments = overlay.gpProperties.usedInAssignments;\n    controller.$broadcast('resetGeoShapeSelector');\n\n    if (overlay.gpProperties.gpType) {\n      controller.shapeType = overlay.gpProperties.gpType.toLowerCase();\n\n      if (overlay.gpProperties.gpType.toLowerCase() == 'polygon' || overlay.gpProperties.gpType.toLowerCase() == 'polyline') {\n        overlay.setOptions({\n          editable: true\n        });\n        controller.range = 5; //default to 5 if user switch from circle to polygon\n\n        controller.centerLatLng = {\n          lat: overlay.gpProperties.recordLat,\n          lng: overlay.gpProperties.recordLng\n        }; //Set center as record\n      } else if (overlay.gpProperties.gpType.toLowerCase() == 'circle') {\n        controller.range = overlay.gpProperties.range;\n        overlay.setEditable(true);\n        controller.addCenterListener(overlay);\n        controller.addRadiusListener(overlay);\n        controller.centerLabel = controller.recordName;\n\n        if (controller.isCenterAtRecord(overlay)) {\n          controller.centerLabel = controller.recordName;\n        } else {\n          controller.centerLabel = overlay.gpProperties.centerLabel;\n        }\n      } else if (overlay.gpProperties.gpType.toLowerCase() == 'geoshape') {\n        // Subshape info is stored/retrieved differently depending on whether shape is dissolved\n        if (controller.dissolve) {\n          var subshapes = overlay.gpProperties.subShapes;\n\n          for (var i = 0, last = subshapes.length; i < last; i++) {\n            controller.selectedGeoShapes[subshapes[i].id] = {\n              id: subshapes[i].id,\n              name: subshapes[i].name,\n              type: subshapes[i].type\n            };\n          }\n        } else {\n          //Loop through all the polygon overlay objects and populate the selected shapes array in the shapeFieldTypeController\n          for (key in polygonObjects) {\n            var thisOverlay = polygonObjects[key]; //If this polygon is part of the larger shape add it to list of selected geo shapes\n\n            if (thisOverlay.gpProperties.groupLayerId == overlay.gpProperties.groupLayerId) {\n              controller.selectedGeoShapes[thisOverlay.gpProperties.geoShapeId] = {\n                id: thisOverlay.gpProperties.geoShapeId,\n                name: thisOverlay.gpProperties.geoShapeName,\n                type: thisOverlay.gpProperties.geoShapeType\n              };\n            }\n          }\n        }\n      }\n    }\n\n    if (overlay.gpProperties.units == 'Miles') {\n      controller.rangeUnits = 'm';\n    } else if (overlay.gpProperties.units == 'Kilometers') {\n      controller.rangeUnits = 'k';\n    }\n\n    setTimeout(function () {\n      controller.$apply();\n    }, 0);\n    jQuery('.mapControlsWrapper').hide(); //Hide the map controls, TODO this needs to be a smart function\n\n    jQuery('#addShapeFieldShape').show(); //Show the box explaining add shape mode\n  } else {\n    //If shape is used in Assignment plans show a warning.\n    if (overlay.gpProperties.usedInAssignments == true) {\n      alert('This Shape is used in Geopointe Assignment Plans. Modifiying it may affect geographic assignment of records to this shape.');\n    } //Make shape editable\n\n\n    overlay.setOptions({\n      editable: true\n    }); //Hide the info window\n\n    gp_infoWindow.setMap(null);\n  }\n}\n\nfunction gp_editGeoShape(shapeData) {\n  gp_events.emit('multiShapeEditorService', {\n    action: 'editShape',\n    data: {\n      shapeData\n    }\n  });\n}\n\nfunction gp_saveShape(uniqueId, isSaveAs) {\n  //Get the shape from the polygonObjects object\n  var polygon = polygonObjects[uniqueId]; //Set isSaveAs to false if it is undefined, Javascript rempoting requiers false value\n\n  if (!isSaveAs) isSaveAs = false;\n  var title = 'Save Shape';\n\n  if (isSaveAs) {\n    title = 'Save As Shape';\n  } //Get access to the Folder Service\n\n\n  var folderService = angular.element('.dataSetController').injector().get('folderService');\n  folderService.getFolders(function (folders) {\n    var saveFolderId = polygon.gpProperties.folderId;\n\n    if (!polygon.gpProperties.folderId || polygon.gpProperties.accessLevel === 'read') {\n      saveFolderId = folderService.getPersonalFolder().id;\n    }\n\n    var foldersHtml = '<a class=\"modal-style\" id=\"gp_saveShapeFolderId\" data-id=\"' + saveFolderId + '\">' + folderService.getFolderNameById(saveFolderId) + '</a>';\n    var buttonText = 'Save';\n    if (isSaveAs) buttonText = 'Save As';\n    var body = gp_translations.Enter_a_Name_and_Short_Description_for_the_shape + '<br/>' + '<table>' + '<tr><td class=\"saveShapeLabel\">' + gp_translations.Name + '</td><td><input type=\"text\" value=\"' + gp_escapeVariable(polygon.gpProperties.sfdcName) + '\" id=\"gp_saveShapeName\" style=\"width: 300px;\"/></td></tr>' + '<tr><td class=\"saveShapeLabel\">Folder</td><td>' + foldersHtml + '</td></tr>' + '<tr><td class=\"saveShapeLabel\">Show Label</td><td><input type=\"checkbox\" id=\"gp_saveShapeShowLabel\"/></td></tr>' + '<tr><td class=\"saveShapeLabel alignTop\">' + gp_translations.Description + '</td><td><textarea maxlength=\"255\" style=\"height: 50px; width: 200px;\" id=\"gp_saveShapeDescription\">' + polygon.gpProperties.sfdcDescription + '</textarea></td></tr>' + '</table>'; //Remove any existing save dialogs\n\n    jQuery('.gpSaveDialog').remove();\n    jQuery('<div class=\"gpSaveDialog\"></div>').append('<p>' + gp_DOMPurify.sanitize(body) + '</p>').dialog({\n      modal: true,\n      draggable: false,\n      width: '515px',\n      title: title,\n      position: {\n        my: 'bottom',\n        at: 'center',\n        of: window\n      },\n      open: function open() {\n        //Create Enter event listner\n        jQuery('#gp_saveShapeName').keypress(function (e) {\n          if (e.keyCode == 13) {\n            //Click the first button in this modal, which is the OK button\n            jQuery(this).parents('.ui-dialog').find('button').first().click();\n          }\n        }); // set up to handle labels\n\n        jQuery('#gp_saveShapeShowLabel').attr('checked', polygon.gpProperties.showLabel ? true : false);\n        'dragend'; //If save as, wipe out input field for name\n\n        if (isSaveAs) jQuery('#gp_saveShapeName').val('');\n      },\n      buttons: [{\n        text: buttonText,\n        click: async function click() {\n          var _document$getElementB, _document$getElementB2, _document$getElementB3, _document$getElementB4;\n\n          const name = (_document$getElementB = document.getElementById('gp_saveShapeName')) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.value;\n          const description = (_document$getElementB2 = document.getElementById('gp_saveShapeDescription')) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.value;\n          const folderId = (_document$getElementB3 = document.getElementById('gp_saveShapeFolderId')) === null || _document$getElementB3 === void 0 ? void 0 : _document$getElementB3.getAttribute('data-id');\n          const showLabel = (_document$getElementB4 = document.getElementById('gp_saveShapeShowLabel')) === null || _document$getElementB4 === void 0 ? void 0 : _document$getElementB4.checked;\n\n          if (folderId === 'nofolder') {\n            return gp_alert('Folder name field is required.');\n          } // Proceed if name was supplied\n\n\n          if (name) {\n            // Close this dialog\n            // since we are using a jQuery dialog leaving\n            // this here, had trouble refactoring to not use jQuery\n            jQuery(this).remove();\n            geopointeAjaxStart('body', gp_translations.Saving_Shape + '...'); // Build a shape object to save\n\n            let shapeToSave = {\n              sfdcId: polygon.gpProperties.sfdcId,\n              name: name,\n              folderId: folderId,\n              saveAsFolderId: isSaveAs ? folderId : null,\n              saveAsName: isSaveAs ? name : null,\n              description: description,\n              usageType: 'Standard',\n              color: 'polyline' == polygon.gpProperties.gpType ? polygon.strokeColor : polygon.fillColor,\n              opacity: 'polyline' == polygon.gpProperties.gpType ? polygon.strokeOpacity : polygon.fillOpacity,\n              showLabel: showLabel\n            };\n\n            if (polygon.gpProperties.gpType === 'circle') {\n              shapeToSave.type = 'Circle';\n              shapeToSave.coordinates = '';\n              shapeToSave.centerLat = polygon.getCenter().lat();\n              shapeToSave.centerLng = polygon.getCenter().lng();\n              shapeToSave.radius = polygon.getRadius() / 1000;\n              shapeToSave.units = 'Kilometers';\n              shapeToSave.labelPointLat = shapeToSave.centerLat;\n              shapeToSave.labelPointLng = shapeToSave.centerLng;\n            } else if (polygon.gpProperties.gpType === 'rectangle') {\n              shapeToSave.type = 'Rectangle'; // Build a string with SW coords and NE coords - code based on shapeFieldTypeController.js\n\n              const coords = [];\n              const sw = polygon.getBounds().getSouthWest();\n              const ne = polygon.getBounds().getNorthEast(); // Following geoJSON structure so store lng first.\n\n              coords.push([Number(Math.round(sw.lng() + 'e' + 6) + 'e-' + 6), Number(Math.round(sw.lat() + 'e' + 6) + 'e-' + 6)]);\n              coords.push([Number(Math.round(ne.lng() + 'e' + 6) + 'e-' + 6), Number(Math.round(ne.lat() + 'e' + 6) + 'e-' + 6)]);\n              shapeToSave.coordinates = JSON.stringify([coords]);\n              const eastEnd = ne.lng() + (sw.lng() > ne.lng() ? 360 : 0);\n              const westEnd = sw.lng();\n              const midLng = (westEnd + eastEnd) * 0.5;\n              shapeToSave.labelPointLat = (sw.lat() + ne.lat()) * 0.5;\n              shapeToSave.labelPointLng = midLng - (midLng > 180 ? 360 : 0);\n            } else {\n              const isPolyline = 'polyline' === polygon.gpProperties.gpType;\n              shapeToSave.type = isPolyline ? 'Polyline' : 'Polygon'; // Build a string of lng lat coordinates - code copied from shapeFieldTypeController.js\n\n              const coords = [];\n              polygon.getPath().forEach(function (e, i) {\n                const point = []; // Following geoJSON structure so store lng first.\n\n                point.push(Number(Math.round(e.lng() + 'e' + 6) + 'e-' + 6));\n                point.push(Number(Math.round(e.lat() + 'e' + 6) + 'e-' + 6));\n                coords.push(point);\n              }); // Following geoJSON spec for polygon, the last point needs to match the first\n\n              if (!isPolyline && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {\n                coords.push([coords[0][0], coords[0][1]]);\n              }\n\n              shapeToSave.coordinates = JSON.stringify([coords]);\n\n              if (shapeToSave.showLabel) {\n                let labelPoint;\n\n                if (isPolyline) {\n                  const midPt = Math.floor(coords.length / 2);\n                  labelPoint = {\n                    lat: coords[midPt][1],\n                    lng: coords[midPt][0]\n                  };\n                } else {\n                  const polyFeature = turf.polygon([coords]);\n                  const useLabelPoint = turf.pointOnFeature(polyFeature);\n                  labelPoint = {\n                    lat: useLabelPoint.geometry.coordinates[1],\n                    lng: useLabelPoint.geometry.coordinates[0]\n                  };\n                }\n\n                shapeToSave.labelPointLat = labelPoint.lat;\n                shapeToSave.labelPointLng = labelPoint.lng;\n              } // Uncomment following line to create encoded data for testing\n              // shapeToSave.coordinates = google.maps.geometry.encoding.encodePath(polygon.getPath());\n\n            } // Save the shape\n\n\n            const payload = {\n              action: 'saveShape',\n              data: {\n                shapeToSave,\n                isSaveAs\n              }\n            };\n            const result = await asyncGpEmitter('ShapeService', payload);\n\n            if (result) {\n              // Success\n              // Update the object stored in polygonObjects\n              polygon.gpProperties.sfdcName = name;\n              polygon.gpProperties.folderId = folderId;\n              polygon.gpProperties.sfdcDescription = description;\n              polygon.gpProperties.sfdcId = result.sfdcId;\n              polygon.gpProperties.showLabel = result.showLabel;\n              polygon.centroid = {\n                lat: result.labelPointLat,\n                lng: result.labelPointLng\n              }; // remove any old label\n\n              if (polygon.mapLabel) polygon.mapLabel.setMap(null);\n              if (polygon.bufferPolygon) polygon.bufferPolygon.setMap(null);\n\n              if (polygon.gpProperties.showLabel) {\n                const payload = {\n                  action: 'createShapeMapLabel',\n                  data: {\n                    labelText: name,\n                    location: polygon.centroid\n                  }\n                };\n                polygon.mapLabel = await asyncGpEmitter('ShapeService', payload);\n                polygon.mapLabel.setMap(gp_map);\n              } // Turn off edit mode\n\n\n              polygon.setOptions({\n                editable: false\n              });\n              geopointeAjaxEnd();\n              const toasterDetails = {\n                isSuccess: true,\n                message: 'Shape Saved.'\n              };\n              gp_events.emit('toasterMessage', toasterDetails); // Broadcast events to update the shape folder lists\n\n              gp_events.emit('dataSetController', {\n                action: 'folderListChanged'\n              }); // Notify shape layer controller that layers on map changed\n\n              angular.element('#ngApp').scope().$broadcast('layersChanged', {\n                doApply: true\n              });\n            }\n          }\n        }\n      }, {\n        text: gp_translations.Cancel,\n        click: function click() {\n          jQuery(this).remove();\n        }\n      }]\n    });\n    jQuery('#gp_saveShapeFolderId').on('click', function () {\n      angular.element('#main-folder-list').scope().openFolderSelect().then(function (parentFolder) {\n        jQuery('#gp_saveShapeFolderId').text(gp_DOMPurify.sanitize(parentFolder.name));\n        jQuery('#gp_saveShapeFolderId').attr('data-id', parentFolder.id);\n      });\n    });\n  }); //End get folders from folder services\n}\n\nfunction gp_addShapeToMap(shape, callback, isFolderAddShapesToMap) {\n  //Check to see if shape is already on the map\n  for (key in polygonObjects) {\n    if (shape.sfdcId == polygonObjects[key].gpProperties.sfdcId) {\n      //geopointeAjaxEnd();\n      gp_bounds = polygonObjects[key].getBounds(); //Readjust the map\n\n      if (!isFolderAddShapesToMap) gp_centerZoom();\n      if (callback) callback();\n      return;\n    }\n  }\n\n  if (checkShapeInvalid(shape)) {\n    if (callback) callback();\n    return;\n  } //Shape was not already on the map, add it\n\n\n  try {\n    gp_addShapeIdToMap(shape.sfdcId, callback, isFolderAddShapesToMap);\n  } catch (exc) {\n    console.log(\"Error in Shape '\" + shape.name + \"': \" + (exc.message ? exc.message : 'Cannot be added to map'));\n    jQuery.extend(toastr.options, {\n      timeOut: 60000\n    });\n    toastr.error('An error occurred while trying to add the shape to the map.  If this error continues please contact Geopointe support.');\n  }\n}\n\nfunction checkShapeInvalid(shape) {\n  // check and alert whether shape has a problem before trying to add to map\n  if (shape.invalid) {\n    var useName = shape.name ? shape.name : shape.relatedRecordName + ' - ' + shape.relatedRecordFieldLabel;\n\n    if (!useName) {\n      // wow, they're really putting us through the wringer...\n      useName = 'record ' + shape.relatedRecordId;\n    }\n\n    jQuery.extend(toastr.options, {\n      timeOut: 60000\n    });\n    toastr.error(shape.invalidReason ? gp_DOMPurify.sanitize(shape.invalidReason) : 'Coordinates JSON for this shape failed a deserialize check');\n    return true;\n  }\n\n  return false;\n}\n\nfunction gp_addShapeIdToMap(sfdcShapeId, callback, isFolderAddShapesToMap) {\n  gp_bounds = new google.maps.LatLngBounds(); //Get the shape coordinates\n\n  Visualforce.remoting.Manager.invokeAction(gpRemoteAction, 'Map_Controller.getShapeLatLng', {\n    shapeId: sfdcShapeId\n  }, async function (result, event) {\n    if (event.status) {\n      try {\n        result = JSON.parse(result);\n        if (!result.color) // If no color, set default color\n          result.color = '#00C414';else if (result.color.indexOf('#') != 0) //Make sure color starts with #\n          result.color = '#' + result.color;\n        if (!result.opacity) result.opacity = 0.4; //Special handing for Geo Shapes\n\n        if (result.usageType == 'GeoShape' || result.usageType == 'Shape Field' && result.type == 'MultiPolygon') {\n          //Set user the Angular geoShapeService to add shapes to the map\n          var geoShapeService = angular.element('.dataSetController').injector().get('geoShapeService'); //Build a list of Geo Shape URLs that should be used to add shapes to the map\n\n          var geoShapeIds = JSON.parse(result.coordinates);\n          geoShapeService.GETgeoShapes({\n            addToMap: true,\n            color: result.color,\n            opacity: result.opacity,\n            dissolve: result.dissolve,\n            layerName: result.name,\n            layerDescription: result.description,\n            sfdcId: result.sfdcId,\n            folderId: result.folderId,\n            folderName: result.folderName,\n            usedInAssignments: result.usedInAssignments,\n            shapeIds: geoShapeIds,\n            isFolderAddShapesToMap: isFolderAddShapesToMap,\n            showLabel: result.showLabel,\n            onComplete: function onComplete(result) {\n              //Zoom and fit map to shape\n              for (key in polygonObjects) {\n                var overlay = polygonObjects[key];\n\n                if (overlay.gpProperties.groupLayerId == result.groupLayerId) {\n                  var paths = overlay.getPaths();\n\n                  for (var p = 0; p < paths.getLength(); p++) {\n                    var path = paths.getAt(p);\n\n                    for (var i = 0; i < path.getLength(); i++) {\n                      gp_bounds.extend(path.getAt(i));\n                    }\n                  }\n                }\n              } //Readjust the map\n\n\n              if (!isFolderAddShapesToMap) gp_centerZoom(); //Call the supplied callback\n\n              if (callback) {\n                callback(result);\n              } //Notify shape layer controller that layers on map changed\n\n\n              angular.element('#ngApp').scope().$broadcast('layersChanged', {\n                doApply: true\n              });\n            },\n            onFail: function onFail() {\n              return callback();\n            }\n          });\n        } else {\n          var _angular$element$scop;\n\n          //Standard Shape\n          if (!result.type || !result.type.toLowerCase) {\n            throw 'Unknown shape type';\n          }\n\n          var type = result.type.toLowerCase();\n          var shape;\n          var labelPoint = {\n            lat: result.labelPointLat,\n            lng: result.labelPointLng\n          };\n          var coordArrays = null;\n\n          if (type === 'multipolygon') {\n            if (result.coordinates && result.coordinates.search(/^\\s*\\[\\s*\\[\\s*\\[\\s*\\[/) == 0) {\n              // Stored in GeoJSON format, the only valid format for multipolygon\n              var paths = [];\n              shape = new google.maps.Polygon({\n                paths: paths,\n                // these are restated here because of an apparent bug in google.maps.Polygon code,\n                // whereby if you update value between ctor and setMap() call, new value is ignored.\n                fillColor: result.color,\n                fillOpacity: result.opacity,\n                strokeWeight: 1\n              });\n              polygonArrays = JSON.parse(result.coordinates);\n              polygonArrays.forEach(polygon => {\n                var latLngs = []; // first array of lng lats is the outer ring of the main shape\n\n                var lngLatArray = polygon[0];\n\n                for (var j = 0; j < lngLatArray.length; j++) {\n                  latLngs.push(new google.maps.LatLng(lngLatArray[j][1], lngLatArray[j][0]));\n                }\n\n                paths.push(latLngs); // Make sure bounds of map include the shape\n\n                for (var i = 0; i < latLngs.length; i++) {\n                  gp_bounds.extend(latLngs[i]);\n                }\n\n                if (polygon.length > 1) {\n                  // if there were holes / extra pieces, set up to display them\n                  if (!shape.gpProperties) {\n                    shape.gpProperties = {};\n                    shape.gpProperties.innerRings = {};\n                    shape.gpProperties.outerRingsToInnerRings = {};\n                    shape.gpProperties.outerRingsToInnerRings[0] = [];\n                  }\n\n                  for (var cdx = 1; cdx < polygon.length; cdx++) {\n                    shape.gpProperties.outerRingsToInnerRings[cdx] = [];\n                    var innerRingArray = polygon[cdx];\n                    var innerLatLngs = [];\n\n                    for (var ix = 0; ix < innerRingArray.length; ix++) {\n                      innerLatLngs.push(new google.maps.LatLng(innerRingArray[ix][1], innerRingArray[ix][0]));\n                      gp_bounds.extend(innerLatLngs[innerLatLngs.length - 1]);\n                    }\n\n                    paths.push(innerLatLngs);\n                    shape.gpProperties.innerRings[paths.length - 1] = true;\n                    shape.gpProperties.outerRingsToInnerRings[cdx].push(paths.length - 1);\n                  }\n                }\n              });\n              shape.setPaths(paths);\n              var polyFeature = turf.multiPolygon(polygonArrays);\n              var useLabelPoint = turf.pointOnFeature(polyFeature);\n              labelPoint = {\n                lat: useLabelPoint.geometry.coordinates[1],\n                lng: useLabelPoint.geometry.coordinates[0]\n              };\n            } else {\n              throw 'Bad coordinates data for multipolygon shape.';\n            }\n          } else if (type == 'polygon' || type == 'polyline') {\n            var latLngs = [];\n\n            if (result.coordinates && result.coordinates.search(/^\\s*\\[\\s*\\[\\s*\\[/) == 0) {\n              //Stored in GeoJSON format\n              coordArrays = JSON.parse(result.coordinates);\n              var lngLatArray = coordArrays[0]; // first array of lng lats is the outer ring of the main shape\n\n              for (var j = 0; j < lngLatArray.length; j++) {\n                latLngs.push(new google.maps.LatLng(lngLatArray[j][1], lngLatArray[j][0]));\n              }\n            } else {\n              //Decode the lat lng string stored in sfdc, multiple lat lng fields are combined into Lat_Lng_1__c\n              latLngs = google.maps.geometry.encoding.decodePath(result.coordinates);\n            }\n\n            if ('polyline' == type) {\n              shape = new google.maps.Polyline({\n                path: latLngs,\n                strokeColor: result.color,\n                strokeOpacity: result.opacity,\n                strokeWeight: GP_POLYLINE_STROKE\n              });\n            } else {\n              shape = new google.maps.Polygon({\n                paths: latLngs,\n                fillColor: result.color,\n                // these are restated here because of an apparent bug in google.maps.Polygon code,\n                fillOpacity: result.opacity,\n                // whereby if you update value between ctor and setMap() call, new value is ignored.\n                strokeWeight: 1\n              });\n\n              if (coordArrays && coordArrays.length > 1) {\n                // if there were holes / extra pieces, set up to display them\n                shape.gpProperties = {};\n                shape.gpProperties.innerRings = {};\n                shape.gpProperties.outerRingsToInnerRings = {};\n                shape.gpProperties.outerRingsToInnerRings[0] = [];\n                var paths = [];\n                paths.push(latLngs);\n\n                for (var cdx = 1; cdx < coordArrays.length; cdx++) {\n                  shape.gpProperties.outerRingsToInnerRings[cdx] = [];\n                  var innerRingArray = coordArrays[cdx];\n                  var innerLatLngs = [];\n\n                  for (var ix = 0; ix < innerRingArray.length; ix++) {\n                    innerLatLngs.push(new google.maps.LatLng(innerRingArray[ix][1], innerRingArray[ix][0]));\n                    gp_bounds.extend(innerLatLngs[innerLatLngs.length - 1]);\n                  }\n\n                  paths.push(innerLatLngs);\n                  shape.gpProperties.innerRings[paths.length - 1] = true;\n                  shape.gpProperties.outerRingsToInnerRings[cdx].push(paths.length - 1);\n                }\n\n                shape.setPaths(paths);\n              }\n            } //Make sure bounds of map include the shape\n\n\n            for (var i = 0; i < latLngs.length; i++) {\n              gp_bounds.extend(latLngs[i]);\n            }\n          } else if (type == 'circle') {\n            // radius needs to be in meters.  convert from km or mi.  if not either of those, just use the radius\n            var units = result.units.toLowerCase();\n            var radius = units == 'kilometers' || units == 'km' || units == 'k' ? result.radius * 1000 : units == 'miles' || units == 'mi' || units == 'm' ? result.radius * 1609.344 : result.radius;\n            shape = new google.maps.Circle({\n              center: new google.maps.LatLng(result.centerLat, result.centerLng),\n              fillColor: result.color,\n              // these are restated here because of an apparent bug in google.maps.Circle code,\n              fillOpacity: result.opacity,\n              // whereby if you update value between ctor and setMap() call, new value is ignored.\n              radius: radius,\n              strokeWeight: 1\n            });\n            labelPoint = {\n              lat: result.centerLat,\n              lng: result.centerLng\n            }; //Make sure bounds of map include the shape\n\n            var circleBounds = shape.getBounds();\n            gp_bounds.extend(circleBounds.getNorthEast());\n            gp_bounds.extend(circleBounds.getSouthWest());\n          } else if (type == 'rectangle') {\n            // Rectangles are stored in GeoJSON, SW point then NE point.\n            var lngLatArray = JSON.parse(result.coordinates)[0]; //Doesn't support holes so first array of lng lats is the shape\n\n            var sw = new google.maps.LatLng(lngLatArray[0][1], lngLatArray[0][0]);\n            var ne = new google.maps.LatLng(lngLatArray[1][1], lngLatArray[1][0]);\n            shape = new google.maps.Rectangle({\n              bounds: new google.maps.LatLngBounds(sw, ne),\n              fillColor: result.color,\n              // these are restated here because of an apparent bug in google.maps.Rectangle code,\n              fillOpacity: result.opacity,\n              // whereby if you update value between ctor and setMap() call, new value is ignored.\n              strokeWeight: 1\n            });\n            var eastEnd = ne.lng() + (sw.lng() > ne.lng() ? 360 : 0);\n            var westEnd = sw.lng();\n            var midLng = (westEnd + eastEnd) * 0.5;\n            labelPoint = {\n              lat: (sw.lat() + ne.lat()) * 0.5,\n              lng: midLng - (midLng > 180 ? 360 : 0)\n            }; //Make sure bounds of map include the shape\n\n            gp_bounds.extend(sw);\n            gp_bounds.extend(ne);\n          } else {\n            if (callback) callback(true);\n            throw 'Unknown shape type';\n          } // set common properties to all types of shape overlays\n\n\n          shape.setOptions({\n            clickable: true,\n            zIndex: 1,\n            editable: false,\n            draggable: false\n          });\n\n          if ('polyline' == type) {\n            shape.strokeColor = result.color;\n            shape.strokeOpacity = result.opacity;\n            shape.strokeWeight = GP_POLYLINE_STROKE;\n          } else {\n            shape.fillColor = result.color;\n            shape.fillOpacity = result.opacity;\n            shape.strokeWeight = 1.5;\n          } // always calculate labelPoint for polygons, in case user-entered coordinate data (supported in 17.x) has changed\n\n\n          if ('polygon' == type && coordArrays && coordArrays.length) {\n            var polyFeature = turf.polygon(coordArrays);\n            var useLabelPoint = turf.pointOnFeature(polyFeature);\n            labelPoint = {\n              lat: useLabelPoint.geometry.coordinates[1],\n              lng: useLabelPoint.geometry.coordinates[0]\n            };\n          }\n\n          shape.centroid = labelPoint; //Set the saved properties on the overlay shape object\n\n          if (!shape.gpProperties) {\n            shape.gpProperties = {};\n          }\n\n          shape.gpProperties.sfdcId = result.sfdcId;\n          shape.gpProperties.sfdcName = result.name;\n          shape.gpProperties.sfdcDescription = result.description;\n          shape.gpProperties.folderId = result.folderId;\n          shape.gpProperties.folderName = result.folderName;\n\n          var shapeFromList = _.find((_angular$element$scop = angular.element('.dataSetController').scope()) === null || _angular$element$scop === void 0 ? void 0 : _angular$element$scop.shapes, ['id', sfdcShapeId]);\n\n          shape.gpProperties.accessLevel = shapeFromList && shapeFromList.accessLevel;\n          shape.gpProperties.usedInAssignments = result.usedInAssignments;\n          shape.gpProperties.originalOpacity = parseFloat(result.opacity);\n          shape.gpProperties.originalColor = result.color;\n          shape.gpProperties.gpType = type;\n          shape.gpProperties.showLabel = result.showLabel; //Add the shape to map\n\n          shape.setMap(gp_map);\n\n          if (result.showLabel) {\n            if (!(labelPoint.lat && labelPoint.lng)) {\n              // polygon labelPoint already calculated above, if possible\n              if ('polyline' == type) {\n                var midPt = Math.floor(lngLatArray.length / 2);\n                labelPoint = {\n                  lat: lngLatArray[midPt][1],\n                  lng: lngLatArray[midPt][0]\n                };\n              }\n            }\n\n            const payload = {\n              action: 'createShapeMapLabel',\n              data: {\n                labelText: result.name,\n                location: labelPoint\n              }\n            };\n            shape.mapLabel = await asyncGpEmitter('ShapeService', payload);\n            shape.mapLabel.setMap(shape.gpProperties.showLabel ? gp_map : null);\n          } // mapPane will be behind polygons unless its Canvas is lifted\n\n\n          if (shape.mapLabel) {\n            jQuery(shape.mapLabel.getPanes().mapPane).css('z-index', shape.mapLabel.zIndex);\n          } //Call polygon added to map method, make sure it is added to polygon Objects array\n\n\n          gp_shapeAddedToMap(shape, type); //Track in mixpanel that a geo shape was added to the map\n\n          gp_track('Shape Added', {\n            Type: 'Standard',\n            'Number of Sub Shapes': 1\n          }); //Readjust the map\n\n          if (!isFolderAddShapesToMap) gp_centerZoom();\n          if (callback) callback();\n        }\n      } catch (exc) {\n        console.log(\"Error in Shape '\" + shape.name + \"': \" + (exc.message ? exc.message : 'Cannot be added to map'));\n        jQuery.extend(toastr.options, {\n          timeOut: 60000\n        });\n        toastr.error('An error occurred while trying to add the shape to the map.  If this error continues please contact Geopointe support.');\n      }\n    } else {\n      //Error handling\n      if (callback) callback(true);\n      var message = {\n        severity: 'ERROR',\n        message: \"Uh oh. Something didn't work quite right. If this error continues please contact Geopointe support. \"\n      };\n      console.log(event.message);\n      updatePageMessages([message]);\n      gp_track('Error', {\n        Language: 'JavaScript',\n        Type: 'Remoting',\n        Function: 'gp_addShapeToMap',\n        Message: event.message\n      });\n    }\n  }, {\n    escape: false\n  });\n}\n\nfunction gp_deleteShapeConfirm(uniqueId) {\n  //Get the current data set\n  var polygon = polygonObjects[uniqueId]; //Unique Id may have been a groupingId for a geoshape, try to find polygon with this\n\n  if (!polygon) {\n    for (key in polygonObjects) {\n      if (polygonObjects[key].gpProperties.groupLayerId == uniqueId) {\n        polygon = polygonObjects[key];\n        break;\n      }\n    }\n  } //Set the dialog title and body\n\n\n  var title = gp_translations.Delete_Shape;\n  var body = '<div class=\"gp-modal-content\">';\n\n  if (polygon.gpProperties.usageType == 'Shape Field') {\n    body += gp_DOMPurify.sanitize(gp_translations.This_will_DELETE_the_selected_shape_and_clear_the_Shape_field_on_the_record) + ':<br/><br/>';\n    body += gp_DOMPurify.sanitize('<b>' + gp_translations.Record_Name + '</b>: <var>' + polygon.gpProperties.relatedRecordName + '</var><br/>');\n    body += gp_DOMPurify.sanitize('<b>' + gp_translations.Shape_Field + '</b>: <var>' + polygon.gpProperties.relatedRecordFieldLabel + '</var>');\n  } else {\n    body += gp_DOMPurify.sanitize(gp_translations.This_will_DELETE_the_selected_Shape_and_remove_it_from_your_list);\n    body += gp_DOMPurify.sanitize('<br/><br/><b>' + gp_translations.Name + '</b>: <var>' + polygon.gpProperties.sfdcName + '</var>');\n  }\n\n  body += '</div>' + '<div class=\"gp-modal-footer\">' + '<input class=\"gp-btn btn-lg modalButtonRight\" onclick=\"jQuery(this).closest(\\'.ui-dialog-content\\').dialog(\\'close\\');\" type=\"button\" value=\"' + gp_DOMPurify.sanitize(gp_translations.Close) + '\">' + \"<input class=\\\"gp-btn btn-lg btn-danger modalButtonRight\\\" onclick=\\\"jQuery(this).closest('.ui-dialog-content').dialog('close'); gp_deleteShape('\" + gp_DOMPurify.sanitize(polygon.gpProperties.sfdcId) + '\\')\" type=\"button\" value=\"' + gp_DOMPurify.sanitize(gp_translations.Delete) + '\">' + '<div class=\"clear\"></div>' + '</div>';\n  jQuery('<div></div>').append(body) // SECURITY: body sanitized during its construction above\n  .dialog({\n    modal: true,\n    draggable: false,\n    width: '515px',\n    title: title,\n    position: {\n      my: 'bottom',\n      at: 'center',\n      of: window\n    },\n    dialogClass: 'gp-modal warn',\n    resizable: false,\n    open: function open(event, ui) {\n      //Set height of modal content\n      setGPmodalContentHeight(jQuery(this));\n    }\n  });\n}\n\nfunction gp_deleteShape(sfdcId) {\n  const payload = {\n    action: 'deleteShape',\n    data: {\n      sfdcId\n    }\n  };\n  asyncGpEmitter('ShapeService', payload);\n}\n\nfunction gp_removeShape(uniqueId) {\n  //UniqueId could be unique shape Id or groupLayerId\n  // special case for info window on route polyline: shape gets removed with its route\n  if ('activeRoute' === uniqueId) {\n    gp_routes.clearRoute(gp_routes.activeRouteId);\n\n    if (!polygonObjects[uniqueId]) {\n      gp_closeInfoWindow(false);\n    }\n\n    return;\n  } else if (isCalRouteId(uniqueId)) {\n    // Calendar Route layers are search buffer only\n    var calRoute = polygonObjects[uniqueId];\n\n    if (calRoute && calRoute.gpProperties) {\n      calRoute.gpProperties.range = '';\n      setPolylineBufferPolygon(calRoute);\n      calcRecordsInShapes();\n      gp_closeInfoWindow(false);\n    }\n\n    return;\n  } //Remove from map\n\n\n  var overlay = polygonObjects[uniqueId];\n  var groupLayerIdToRemove; //UniqueId was a unique shape Id\n\n  if (overlay) {\n    groupLayerIdToRemove = overlay.gpProperties.groupLayerId;\n  } else {\n    //UniqueId was a groupLayerId\n    groupLayerIdToRemove = uniqueId;\n  }\n\n  for (key in polygonObjects) {\n    if (polygonObjects[key].gpProperties.groupLayerId == groupLayerIdToRemove) {\n      if (polygonObjects[key].mapLabel) polygonObjects[key].mapLabel.setMap(null);\n      if (polygonObjects[key].bufferPolygon) polygonObjects[key].bufferPolygon.setMap(null);\n      polygonObjects[key].setMap(null);\n      delete polygonObjects[key];\n    }\n  } //Close the info window\n\n\n  gp_closeInfoWindow(false); //Update the layers list with new record counts\n\n  setTimeout(function () {\n    angular.element('#ngApp').scope().$broadcast('layersChanged', {\n      doApply: true\n    });\n  }, 0);\n}\n\nfunction gp_removeFolderShapes(folderId) {\n  //Check folderId of mapped shapes and remove any that match the input\n  _.forEach(polygonObjects, function (shape, key) {\n    if (shape.gpProperties.folderId === folderId) {\n      if (shape.mapLabel) shape.mapLabel.setMap(null);\n      if (shape.bufferPolygon) shape.bufferPolygon.setMap(null);\n      shape.setMap(null);\n      delete polygonObjects[key];\n    }\n  }); //Update the layers list with new record counts\n\n\n  setTimeout(function () {\n    angular.element('#ngApp').scope().$broadcast('layersChanged', {\n      doApply: true\n    });\n  }, 0);\n} //IE this will remove one zip code from a shape comprised of many zip codes\n\n\nfunction gp_removeSubShape(uniqueId) {\n  var overlay = polygonObjects[uniqueId];\n  if (overlay.mapLabel) overlay.mapLabel.setMap(null);\n  overlay.setMap(null);\n  delete polygonObjects[uniqueId]; //Close the info window\n\n  gp_closeInfoWindow(false); //Update the layers list with new record counts\n\n  setTimeout(function () {\n    angular.element('#ngApp').scope().$broadcast('layersChanged', {\n      doApply: true\n    });\n  }, 0);\n}\n\nfunction gp_removeAllShapesFromMap() {\n  jQuery('<div></div>').append(gp_DOMPurify.sanitize('<p>' + gp_translations.This_will_remove_all_shapes_from_the_map + '<br/><br/>' + gp_translations.Select_Remove_to_continue + '</p>')).dialog({\n    modal: true,\n    draggable: false,\n    width: '270px',\n    title: gp_translations.Remove_All_Shapes,\n    position: {\n      my: 'bottom',\n      at: 'center',\n      of: window\n    },\n    buttons: [{\n      text: 'Remove',\n      click: function click() {\n        //Remove shapes from the map\n        for (key in polygonObjects) {\n          var shape = polygonObjects[key]; //Dont remove shape field shapes\n\n          if (shape.gpProperties.usageType == 'Shape Field') continue;\n          if (shape.mapLabel) shape.mapLabel.setMap(null);\n          if (shape.bufferPolygon) shape.bufferPolygon.setMap(null);\n          shape.setMap(null);\n          delete polygonObjects[key];\n        } //Remove geojson files\n\n\n        gp_map.data.forEach(function (shape) {\n          gp_map.data.remove(shape);\n        }); //Close info window that may be open\n\n        gp_closeInfoWindow(false); //Close this dialog\n\n        jQuery(this).remove(); //Update angular ui elements\n\n        angular.element('.dataSetController').scope().$apply();\n      }\n    }, {\n      text: 'Cancel',\n      click: function click() {\n        jQuery(this).remove();\n      }\n    }]\n  });\n}\n\nfunction gp_goToShapeField(sfdcRecordId, shapeRecordId) {\n  //Loop through all the polygon objects\n  for (key in polygonObjects) {\n    var shape = polygonObjects[key];\n\n    if (shape.gpProperties.relatedRecordId == sfdcRecordId && shape.gpProperties.sfdcId == shapeRecordId) {\n      gp_goToShape(key);\n    }\n  }\n}\n\nfunction gp_goToShape(sfdcIdUniqueId) {\n  for (key in polygonObjects) {\n    var shape = polygonObjects[key];\n\n    if (shape.gpProperties.sfdcId == sfdcIdUniqueId || shape.gpProperties.uniqueId == sfdcIdUniqueId) {\n      var bounds = shape.getBounds();\n      gp_map.fitBounds(bounds);\n    }\n  }\n}\n\nfunction checkIfPoiInShapes(poi, groupLayerId) {\n  //groupLayerId is optional\n  //Construct a google lat lng object from the poi\n  var latLng = new google.maps.LatLng(poi.lat, poi.lng);\n\n  for (key in polygonObjects) {\n    var overlay = polygonObjects[key];\n\n    if (!overlay.visible || null == overlay.map) {\n      continue; // check next shape, this one is hidden\n    }\n\n    if (typeof groupLayerId == 'undefined' || typeof groupLayerId != 'undefined' && groupLayerId == overlay.gpProperties.groupLayerId || typeof groupLayerId != 'undefined' && groupLayerId == overlay.gpProperties.uniqueId) {\n      if (overlay.gpProperties.gpType == 'circle') {\n        var distanceFromCenterKM = getGeoDistance(overlay.getCenter().lat(), overlay.getCenter().lng(), poi.lat, poi.lng, 'kilometers');\n        if (distanceFromCenterKM <= overlay.radius / 1000) return true;\n      } else if (overlay.gpProperties.gpType == 'rectangle') {\n        if (overlay.getBounds().contains(latLng)) return true;\n      } else if ('polyline' == overlay.gpProperties.gpType) {\n        // Polyline only 'contains' records if a search-within-distance value is set.\n        if (overlay.gpProperties.range && !overlay.bufferPolygon) {\n          setPolylineBufferPolygon(overlay);\n        }\n\n        if (overlay.bufferPolygon && google.maps.geometry.poly.containsLocation(latLng, overlay.bufferPolygon)) return true;\n      } else {\n        if (google.maps.geometry.poly.containsLocation(latLng, overlay)) return true;\n      }\n    }\n  } //Poi is not inside a shape\n\n\n  return false;\n}\n\nfunction calcZoomTolerance() {\n  var z = gp_map.getZoom();\n  return Math.pow(z, -z * 0.22); // be 'close to' polyline whatever the zoom level\n}\n\nfunction calcDistanceInPolyline(poly) {\n  if (poly && 'polyline' === poly.gpProperties.gpType && google.maps.geometry) {\n    var totalDistance = 0.0;\n    var path = poly.getPath();\n    var prev = path.getAt(0);\n    var curr;\n\n    for (var i = 1, end = path.length; i < end; i++) {\n      curr = path.getAt(i);\n      totalDistance += google.maps.geometry.spherical.computeDistanceBetween(prev, curr);\n      prev = curr;\n    } // totalDistance is in meters.  Convert to ft or miles, and convert to km if > 1000\n\n\n    poly.gpProperties.distance = {};\n    poly.gpProperties.distance.totalM = totalDistance;\n    poly.gpProperties.distance.us = totalDistance > 1500 ? angular.injector(['ng']).get('numberFilter')(totalDistance / 1609.34, 2) + ' mi' : angular.injector(['ng']).get('numberFilter')(totalDistance * 3.28084, 2) + ' ft';\n    poly.gpProperties.distance.metric = totalDistance >= 1000 ? angular.injector(['ng']).get('numberFilter')(totalDistance / 1000, 2) + ' km' : angular.injector(['ng']).get('numberFilter')(totalDistance, 2) + ' m';\n  }\n}\n\nvar recordsInShapesTimeoutHandler;\n\nfunction calcRecordsInShapes() {\n  window.clearTimeout(recordsInShapesTimeoutHandler);\n\n  if (gp_shapeDragInProgress == false) {\n    recordsInShapesTimeoutHandler = window.setTimeout(function () {\n      gp_calcRecordsUtils.doCalcRecords();\n    }, 250);\n  }\n}\n\nvar gp_aggregates = {\n  dataSets: {},\n  shapes: {},\n  shapeGroups: {},\n  formulas: ['sum', 'avg', 'min', 'max'],\n  cache: {},\n  batchId: '',\n  completedBatch: '',\n  formatNumber: function formatNumber(num, type, scale) {\n    var formattedNumber = '';\n\n    if (type === 'CURRENCY') {\n      if (gp_orgSettings.multiCurrency) {\n        // Only converted fields get aggregated, so use the user's currency\n        let decimalPlaces = gp_orgSettings.currencyDecimalPlaces[gp_userSettings.userInfo.userCurrency.isoCode];\n        formattedNumber += gp_userSettings.userInfo.userCurrency.isoCode + ' ' + angular.injector(['ng']).get('numberFilter')(num, decimalPlaces);\n      } else {\n        formattedNumber += angular.injector(['ng']).get('currencyFilter')(num, gp_userSettings.userInfo.userCurrency.symbol, scale);\n      }\n    } else {\n      formattedNumber += angular.injector(['ng']).get('numberFilter')(num, scale);\n    }\n\n    if (type === 'PERCENT') {\n      formattedNumber += '%';\n    } // if formattedNumber might include some malicious payload, strip it out\n\n\n    return formattedNumber.includes('<') ? gp_DOMPurify.sanitize(formattedNumber) : formattedNumber;\n  },\n  setFieldSummaryType: function setFieldSummaryType(layerId, field, summaryType) {\n    gp_aggregates.cache[layerId + '__' + field] = summaryType;\n  },\n  getFieldSummaryType: function getFieldSummaryType(layerId, field, fieldType) {\n    var aggregateType;\n    var cacheFailed = false;\n\n    try {\n      aggregateType = gp_aggregates.cache[layerId + '__' + field].selected;\n    } catch (err) {\n      cacheFailed = true;\n    }\n\n    if (!aggregateType || cacheFailed) {\n      if (gp_aggregates.dataSets[layerId] && gp_aggregates.dataSets[layerId].aggregates && gp_aggregates.dataSets[layerId].aggregates[field] && gp_aggregates.dataSets[layerId].aggregates[field].showMetrics) {\n        aggregateType = gp_aggregates.dataSets[layerId].aggregates[field].showMetrics;\n      } else {\n        // user hasn't specified metric, default per datatype\n        aggregateType = 'PERCENT' === fieldType ? 'avg' : 'sum';\n      }\n    }\n\n    return gp_DOMPurify.sanitize(aggregateType);\n  },\n  getFieldSummaryValue: function getFieldSummaryValue(layerId, field, useShapeLayer, type) {\n    var value = '';\n    var datatype;\n    var scale;\n\n    try {\n      var layerData;\n\n      if (useShapeLayer) {\n        layerData = gp_aggregates.shapeGroups[layerId];\n      } else {\n        // layer id is for a data set\n        if (gp_aggregates.dataSets[layerId]) {\n          layerData = gp_aggregates.dataSets[layerId]; // layer id is for a single or merged shape\n        } else if (polygonObjects[layerId]) {\n          layerData = gp_aggregates.shapeGroups[polygonObjects[layerId].gpProperties.groupLayerId]; // layer id is route polyline with buffer polygon\n        } else if (gp_routes.activeRouteId === layerId) {\n          layerData = gp_aggregates.shapeGroups[polygonObjects['activeRoute'].gpProperties.groupLayerId]; // layer id is for a group of shapes\n        } else if (_.find(polygonObjects, 'gpProperties.groupLayerId', layerId)) {\n          layerData = gp_aggregates.shapeGroups[layerId];\n        }\n      }\n\n      if (field === 'count') {\n        value = layerData.points.length;\n      } else {\n        var aggregate = layerData.aggregates[field];\n\n        if (useShapeLayer && type) {\n          value = aggregate[type];\n        } else {\n          datatype = aggregate.type;\n          var aggType = gp_aggregates.getFieldSummaryType(layerId, field, datatype);\n          value = aggregate[aggType];\n        }\n\n        scale = aggregate.scale;\n      }\n    } catch (err) {}\n\n    return gp_aggregates.formatNumber(value, datatype, scale);\n  },\n  setLegendSummaryType: function setLegendSummaryType(layerId, field, summaryType, localCache) {\n    var cache = localCache || gp_aggregates.cache;\n    cache[layerId + '__legend__' + field] = summaryType;\n  },\n  getLegendSummaryType: function getLegendSummaryType(layerId, field, fieldType, localCache) {\n    var aggregateType;\n    var cache = localCache || gp_aggregates.cache;\n\n    try {\n      aggregateType = cache[layerId + '__legend__' + field].selected;\n    } catch (err) {\n      aggregateType = 'sum';\n\n      if (fieldType === 'PERCENT') {\n        aggregateType = 'avg';\n      }\n    }\n\n    return gp_DOMPurify.sanitize(aggregateType);\n  },\n  getLegendSummaryValue: function getLegendSummaryValue(layerId, legendValue, field, aggregateData, localCache) {\n    var value = '';\n    var type;\n    var scale;\n\n    try {\n      aggregateData = aggregateData || gp_aggregates.dataSets[layerId].legend;\n      var legendValueData = aggregateData[legendValue];\n\n      if (field === 'count') {\n        value = legendValueData.points.length;\n      } else {\n        var aggregate = legendValueData.aggregates[field];\n        type = aggregate.type;\n        value = aggregate[gp_aggregates.getLegendSummaryType(layerId, field, type, localCache)];\n        scale = aggregate.scale;\n      }\n    } catch (err) {}\n\n    const displayValue = gp_aggregates.formatNumber(value, type, scale);\n    return {\n      value,\n      displayValue\n    };\n  }\n};\nvar gp_calcRecordsUtils = {\n  doCalcRecords: function doCalcRecords() {\n    gp_calcRecordsUtils.clearAggregates();\n    gp_calcRecordsUtils.setAggregateFieldsByDataSet();\n    gp_calcRecordsUtils.setAggregateFieldsByCSV();\n    gp_calcRecordsUtils.setPointsByDataSet();\n    gp_calcRecordsUtils.setPointsByLegendValue();\n    gp_calcRecordsUtils.setShapesByShapeGroup();\n    gp_calcRecordsUtils.setPointsByShape().then(function () {\n      gp_calcRecordsUtils.setSRecordIdsInShapes();\n      gp_calcRecordsUtils.setPointsByShapeGroup();\n      gp_calcRecordsUtils.buildAllAggregates();\n      gp_aggregates.completedBatch = gp_aggregates.batchId;\n      angular.element('#ngApp').scope().$broadcast('layersChanged', {\n        doApply: true\n      });\n    }).catch(e => {\n      console.error(e);\n    });\n  },\n  clearAggregates: function clearAggregates() {\n    gp_aggregates.dataSets = {};\n    gp_aggregates.shapes = {};\n    gp_aggregates.shapeGroups = {};\n    gp_aggregates.batchId = guid();\n  },\n  getVisibleMarkersByDataSet: function getVisibleMarkersByDataSet() {\n    return _.chain(gp_markers).filter(function (marker) {\n      return !marker.hiddenByLegend && marker.visible && marker.sObject && marker.collectionName !== 'centerPOI';\n    }).groupBy('collectionName').value();\n  },\n  setAggregateFieldsByDataSet: function setAggregateFieldsByDataSet() {\n    _.forEach(gp_calcRecordsUtils.getVisibleMarkersByDataSet(), function (markers, collectionName) {\n      // Only process real data sets, not CSV \"data sets\"\n      if (gp_dataSetSearches[collectionName].searchType === gpCsv) return;\n      var aggregateFields = {};\n      var objectName = gp_dataSetSearches[collectionName].qo.moNew.SobjectName;\n      var dataSetName = gp_dataSetSearches[collectionName].name; // Loop through fields to determine currency fields for this object\n\n      _.forEach(gp_dataSetSearches[collectionName].qo.dataSetFields, function (field) {\n        // Only aggregate numeric fields w/ special handling of currency fields\n        if (field.type === 'CURRENCY' && !gp_orgSettings.multiCurrency || field.type === 'INTEGER' || field.type === 'DOUBLE' || field.type === 'PERCENT') {\n          aggregateFields[field.field] = {\n            field: field.field,\n            label: field.label,\n            scale: field.scale,\n            type: field.type,\n            showMetrics: field.showMetrics\n          };\n        } else if (gp_orgSettings.multiCurrency && gp_isConvertibleCurrField(field, gp_dataSetSearches[collectionName].qo.moNew)) {\n          let alias = gp_convCurrAlias(field.field);\n          aggregateFields[alias] = {\n            field: alias,\n            label: field.label,\n            scale: gp_orgSettings.currencyDecimalPlaces[gp_userSettings.userInfo.userCurrency.isoCode],\n            type: field.type,\n            showMetrics: field.showMetrics\n          };\n        }\n      });\n\n      gp_aggregates.dataSets[collectionName] = {\n        aggregateFields: aggregateFields,\n        dataSetName: dataSetName,\n        objectName: objectName,\n        collectionName: collectionName\n      };\n    });\n  },\n  setAggregateFieldsByCSV: function setAggregateFieldsByCSV() {\n    _.forEach(gp_calcRecordsUtils.getVisibleMarkersByDataSet(), function (markers, collectionName) {\n      // Only process CSV \"data sets\", not real data sets\n      if (gp_dataSetSearches[collectionName].searchType !== gpCsv) return;\n      var aggregateFields = {};\n      var objectName = gpCsv;\n      var dataSetName = gp_dataSetSearches[collectionName].name;\n      if (!gp_dataSetSearches[collectionName].columnLabels || !gp_dataSetSearches[collectionName].columnLabels.additionalFields || !gp_dataSetSearches[collectionName].columnLabels.additionalFields.length) return;\n      var addlFields = gp_dataSetSearches[collectionName].columnLabels.additionalFields; // Loop through fields to determine currency fields for this object\n\n      _.forEach(addlFields, function (field) {\n        // Only aggregate numeric fields w/ special handling of currency fields\n        if (field.datatype === 'CURRENCY' && !gp_orgSettings.multiCurrency || field.datatype === 'INTEGER' || field.datatype === 'DOUBLE' || field.datatype === 'PERCENT') {\n          aggregateFields[field.name] = {\n            field: field.name,\n            label: field.name,\n            scale: field.scale,\n            type: field.datatype,\n            showMetrics: field.showMetrics\n          };\n        }\n      });\n\n      gp_aggregates.dataSets[collectionName] = {\n        aggregateFields: aggregateFields,\n        dataSetName: dataSetName,\n        objectName: objectName,\n        collectionName: collectionName\n      };\n    });\n  },\n  setPointsByDataSet: function setPointsByDataSet() {\n    const getVisibleMarkersByDataSetResult = gp_calcRecordsUtils.getVisibleMarkersByDataSet();\n\n    for (const [collectionName, markers] of Object.entries(getVisibleMarkersByDataSetResult)) {\n      const aggregateFields = gp_aggregates.dataSets[collectionName].aggregateFields;\n      const isCSV = gp_dataSetSearches[collectionName].searchType === gpCsv;\n      const objectName = isCSV ? gpCsv : gp_dataSetSearches[collectionName].qo.moNew.SobjectName; // Generate points for point in poly check\n\n      gp_aggregates.dataSets[collectionName].points = markers.map(marker => {\n        const pointValues = {}; // Loop through aggregate fields\n\n        Object.values(aggregateFields).forEach(_ref4 => {\n          let {\n            field\n          } = _ref4;\n          let value = parseFloat(marker.sObject[field]);\n\n          if (isNaN(value)) {\n            value = 0;\n          }\n\n          pointValues[field] = value;\n        });\n        const point = turf.point([marker.position.lng(), marker.position.lat()]);\n        point.properties.id = isCSV ? marker.uniqueID : marker.recordId;\n        point.properties.values = pointValues;\n        point.properties.collectionName = collectionName;\n        point.properties.objectName = objectName;\n        point.properties.markerId = marker.uniqueID;\n        return point;\n      });\n    }\n  },\n  setPointsByLegendValue: function setPointsByLegendValue() {\n    _.forEach(gp_dataSetSearches, function (dataSet, collectionName) {\n      var dataSet = gp_aggregates.dataSets[collectionName];\n\n      if (!dataSet) {\n        return;\n      }\n\n      dataSet.legend = {};\n      var mapLegendService = angular.element('.legendController').injector().get('mapLegendService'); // empty legend to deal with id arrays\n\n      var legend = mapLegendService.getLegend(collectionName) || {};\n      var tempPointCache = {};\n\n      _.forEach(dataSet.points, function (point) {\n        tempPointCache[point.properties.markerId] = point;\n      });\n\n      _.forEach(legend.itemsByValue, function (items, value) {\n        if (!items.visible) {\n          return;\n        }\n\n        dataSet.legend[value] = {\n          name: value\n        };\n        dataSet.legend[value].points = [];\n\n        _.forEach(items.uniqueMarkerIds, function (markerId) {\n          if (tempPointCache[markerId]) {\n            dataSet.legend[value].points.push(tempPointCache[markerId]);\n          }\n        });\n      });\n    });\n  },\n  setPointsByShape: function setPointsByShape(geoJSONHash, standardShapeLayers) {\n    var dataLayerInjector = angular.element('#dataLayerDirective').injector();\n    if (!dataLayerInjector) return Promise.reject('DataLayer Injector not present'); // nothing to do here without dataLayer\n\n    var dataLayerSearchService = dataLayerInjector.get('dataLayerSearchService');\n    let isGEOJSON = false;\n    let polygons = polygonObjects;\n\n    if (geoJSONHash) {\n      isGEOJSON = true;\n      polygons = geoJSONHash;\n    }\n\n    const points = _.chain(gp_aggregates.dataSets).filter(dataset => !!dataset).map(dataSet => dataSet.points).flatten().value();\n\n    const promises = _.map(polygons, (shape, shapeId) => {\n      return dataLayerSearchService.containsLocationFilter(points, shape, gp_aggregates.batchId, isGEOJSON ? shape : null).then(filteredPoints => {\n        gp_aggregates.shapes[shapeId] = {\n          points: filteredPoints\n        };\n      }).catch(err => {\n        console.warn('constainsLocationFilter promise rejected. Message :', err.message);\n      });\n    }); // Handle standard shape layers for MSE\n\n\n    if (Array.isArray(standardShapeLayers)) {\n      standardShapeLayers.forEach(standardLayerId => {\n        const shape = polygonObjects[standardLayerId];\n\n        if (shape) {\n          const promise = dataLayerSearchService.containsLocationFilter(points, shape, gp_aggregates.batchId, null).then(filteredPoints => {\n            gp_aggregates.shapes[standardLayerId] = {\n              points: filteredPoints\n            };\n          }).catch(err => {\n            console.warn('constainsLocationFilter promise rejected. Message :', err.message);\n          });\n          promises.push(promise);\n        }\n      });\n    }\n\n    return Promise.all(promises);\n  },\n  setSRecordIdsInShapes: function setSRecordIdsInShapes(shapeLayers) {\n    if (shapeLayers) {\n      _.forEach(gp_aggregates.shapes, (shape, shapeId) => {\n        const recordIdsInShape = _.map(shape.points, 'properties.id');\n\n        shapeLayers.forEach(shapeLayer => {\n          if (shapeLayer.selectedGeoShapes[shapeId]) {\n            if (shapeLayer.aggregates[shapeId]) {\n              shapeLayer.aggregates[shapeId].recordIdsInShape = recordIdsInShape;\n            } else {\n              shapeLayer.aggregates[shapeId] = {\n                recordIdsInShape\n              };\n            }\n          }\n        });\n      });\n    } else {\n      _.forEach(gp_aggregates.shapes, function (shape, shapeId) {\n        var pObj = polygonObjects[shapeId];\n\n        if (pObj) {\n          pObj.gpProperties.recordIdsInShape = _.map(shape.points, 'properties.id');\n        }\n      });\n    }\n  },\n  setShapesByShapeGroup: function setShapesByShapeGroup() {\n    var shapeGroups = gp_aggregates.shapeGroups;\n\n    _.forEach(polygonObjects, function (shape, shapeId) {\n      if (!shape.gpProperties.groupLayerId) return;\n\n      if (shapeGroups[shape.gpProperties.groupLayerId]) {\n        shapeGroups[shape.gpProperties.groupLayerId].shapes.push(shapeId);\n      } else {\n        shapeGroups[shape.gpProperties.groupLayerId] = {\n          shapes: [shapeId]\n        };\n      }\n    });\n  },\n  // Shape layers are from multi-shape-editor\n  setShapeByShapeLayers: (layers, standardShapeLayers) => {\n    var shapeGroups = gp_aggregates.shapeGroups;\n    layers.forEach(layer => {\n      const {\n        id,\n        selectedGeoShapes\n      } = layer;\n      Object.keys(selectedGeoShapes).forEach(shapeId => {\n        if (shapeGroups[id]) {\n          shapeGroups[id].shapes.push(shapeId);\n        } else {\n          shapeGroups[id] = {\n            shapes: [shapeId]\n          };\n        }\n      });\n    });\n    standardShapeLayers.forEach(standardLayerId => {\n      var _shape$gpProperties;\n\n      const shape = polygonObjects[standardLayerId];\n      const groupId = shape === null || shape === void 0 ? void 0 : (_shape$gpProperties = shape.gpProperties) === null || _shape$gpProperties === void 0 ? void 0 : _shape$gpProperties.groupLayerId;\n      if (!groupId) return;\n\n      if (shapeGroups[groupId]) {\n        shapeGroups[groupId].shapes.push(standardLayerId);\n      } else {\n        shapeGroups[groupId] = {\n          shapes: [standardLayerId]\n        };\n      }\n    });\n  },\n  setPointsByShapeGroup: function setPointsByShapeGroup() {\n    _.forEach(gp_aggregates.shapeGroups, function (shapeGroup) {\n      shapeGroup.points = _.chain(shapeGroup.shapes).filter(shapeId => !!gp_aggregates.shapes[shapeId]).map(function (shapeId) {\n        return gp_aggregates.shapes[shapeId].points;\n      }).flatten().value();\n    });\n  },\n  buildAggregates: function buildAggregates(aggregateData) {\n    aggregateData.aggregates = {};\n\n    var pointsByObject = _.groupBy(aggregateData.points, 'properties.objectName');\n\n    aggregateData.counts = {};\n\n    _.forEach(pointsByObject, function (points, object) {\n      var objectLabelPlural = gp_objectMeta[object] ? gp_objectMeta[object].objectLablePlural : 'Selected Records';\n      aggregateData.counts[object] = {\n        pluralName: objectLabelPlural,\n        count: points.length\n      };\n    });\n\n    _.forEach(aggregateData.points, function (point) {\n      _.forEach(point.properties.values, function (aggregateFieldValue, aggregateFieldName) {\n        // skip aggregation for datatypes which do not aggregate, subfields of compound values,\n        //   and fields for which the user has configured aggregation metrics off.\n        var aggField = gp_aggregates.dataSets[point.properties.collectionName].aggregateFields[aggregateFieldName];\n\n        if (aggField.showMetrics === 'exclude' || aggregateFieldName.endsWith('__s') || gp_supportedAggrFieldTypes.indexOf(aggField.type) == -1) {\n          return;\n        }\n\n        aggregateData.aggregates[aggregateFieldName] = _.clone(aggField);\n      });\n    });\n\n    _.forEach(aggregateData.aggregates, function (aggregate, aggregateFieldName) {\n      var points = _.filter(aggregateData.points, function (point) {\n        return typeof point.properties.values[aggregateFieldName] === 'number';\n      });\n\n      var sum = _.sumBy(points, function (point) {\n        return point.properties.values[aggregateFieldName] || 0;\n      });\n\n      var avg = _.meanBy(points, function (point) {\n        return point.properties.values[aggregateFieldName] || 0;\n      });\n\n      var min;\n      var max;\n\n      try {\n        min = _.minBy(points, function (point) {\n          return point.properties.values[aggregateFieldName] || 0;\n        }).properties.values[aggregateFieldName] || 0;\n        max = _.maxBy(points, function (point) {\n          return point.properties.values[aggregateFieldName] || 0;\n        }).properties.values[aggregateFieldName] || 0;\n      } catch (err) {\n        min = 0;\n        max = 0;\n      }\n\n      if (points.length === 0 || !_.isFinite(sum)) {\n        sum = 0;\n      }\n\n      if (points.length === 0 || !_.isFinite(avg)) {\n        avg = 0;\n      }\n\n      if (points.length === 0 || !_.isFinite(min)) {\n        min = 0;\n      }\n\n      if (points.length === 0 || !_.isFinite(max)) {\n        max = 0;\n      }\n\n      aggregate.sum = sum;\n      aggregate.avg = avg;\n      aggregate.min = min;\n      aggregate.max = max;\n    });\n  },\n  buildByDataSetAggregates: function buildByDataSetAggregates(shape) {\n    var pointsByDataSet = _.groupBy(shape.points, 'properties.collectionName');\n\n    shape.dataSets = {};\n\n    _.forEach(pointsByDataSet, function (points, collectionName) {\n      shape.dataSets[collectionName] = {\n        points: points,\n        dataSetName: gp_aggregates.dataSets[collectionName].dataSetName,\n        objectName: gp_aggregates.dataSets[collectionName].objectName,\n        collectionName: gp_aggregates.dataSets[collectionName].collectionName\n      };\n      gp_calcRecordsUtils.buildAggregates(shape.dataSets[collectionName]);\n    });\n  },\n  buildAllAggregates: function buildAllAggregates() {\n    _.forEach(gp_aggregates.dataSets, gp_calcRecordsUtils.buildAggregates);\n\n    _.forEach(gp_aggregates.dataSets, function (dataSet) {\n      _.forEach(dataSet.legend, gp_calcRecordsUtils.buildAggregates);\n    });\n\n    _.forEach(gp_aggregates.shapes, gp_calcRecordsUtils.buildByDataSetAggregates);\n\n    _.forEach(gp_aggregates.shapeGroups, gp_calcRecordsUtils.buildAggregates);\n  }\n};\n\nfunction gp_getItemForCalendar(marker, pointType) {\n  const userId = gp_userSettings.userInfo.userId;\n  const markerId = marker.uniqueID;\n  const itemLocId = marker.recordId;\n  let recordName = marker.gp_title;\n  let address = '';\n  let sfdcObject = '';\n  let sfdcObjectLabel = '';\n  let street;\n  let state;\n  let city;\n  let postalCode;\n  let country;\n\n  if (marker.type === 'Location') {\n    street = marker.markerInfo.street;\n    state = marker.markerInfo.state;\n    city = marker.markerInfo.city;\n    postalCode = marker.markerInfo.postalCode;\n    sfdcObject = 'geopointe__Geo_Location__c';\n    sfdcObjectLabel = 'Geopointe Location';\n  } else if (marker.type == 'RecordSearch') {\n    const searchRecInfo = window.gp_recordSearchInfo['gp_recordSearchPoi'];\n    country = searchRecInfo.country;\n    street = searchRecInfo.street;\n    state = searchRecInfo.state;\n    postalCode = searchRecInfo.postal;\n    city = searchRecInfo.city;\n    sfdcObject = searchRecInfo.sfdcObject;\n    sfdcObjectLabel = searchRecInfo.sObjectLabel;\n    recordName = searchRecInfo.name;\n  } else {\n    const moNew = gp_dataSetSearches[marker.collectionName].qo.moNew;\n    country = getDescendantProp(marker.sObject, moNew.ReadCountryField);\n    street = getDescendantProp(marker.sObject, moNew.ReadStreetField);\n    state = getDescendantProp(marker.sObject, moNew.ReadStateField);\n    city = getDescendantProp(marker.sObject, moNew.ReadCityField);\n    postalCode = getDescendantProp(marker.sObject, moNew.ReadPostalField);\n\n    if (moNew.SobjectName) {\n      sfdcObject = moNew.SobjectName;\n    } else {\n      sfdcObject = marker.sObject.type;\n    }\n\n    if (moNew.SobjectLabel) {\n      sfdcObjectLabel = moNew.SobjectLabel;\n    }\n  }\n\n  if (street) {\n    address += street;\n  }\n\n  if (city) {\n    if (address) {\n      address += ', ' + city;\n    } else {\n      address += city;\n    }\n  }\n\n  if (state) {\n    if (address) {\n      address += ', ' + state;\n    } else {\n      address += state;\n    }\n  }\n\n  if (postalCode) {\n    if (address) {\n      address += ' ' + postalCode;\n    } else {\n      address += postalCode;\n    }\n  }\n\n  address = gp_DOMPurify.sanitize(address.replace(/\\r?\\n|\\r|\\t/g, ' '));\n  const relatedItemLoc = {\n    itemLocId,\n    name: recordName\n  };\n  return {\n    id: guid(),\n    lat: marker.position.lat(),\n    lng: marker.position.lng(),\n    title: recordName,\n    subject: 'Meeting',\n    modified: true,\n    dbAction: 'insert',\n    calItemId: null,\n    userId,\n    originalUserId: userId,\n    readOnly: null,\n    isAllDayEvent: false,\n    itemDate: null,\n    calObjId: null,\n    isSelfLocationObject: false,\n    state,\n    city,\n    street,\n    country,\n    postalCode,\n    pointType,\n    address,\n    sfdcObject,\n    sfdcObjectLabel,\n    relatedItemLoc,\n    markerId,\n    pageLayoutData: null,\n    excludeCalendarRouteFieldSet: false,\n    excludeCalendarRoute: false\n  };\n}\n\nfunction gp_addItemToCalendar(poiString, poiCollectionString, pointType) {\n  var marker = gp_markers[poiString];\n\n  if (marker) {\n    var item = gp_getItemForCalendar(marker, pointType);\n    gp_events.emit('addItemToCalendarStaging', [item]);\n  } else {\n    jQuery.extend(toastr.options, {\n      timeOut: 5000\n    });\n    toastr.error('Cannot add to Calendar Staging!');\n    console.error('Cannot add to Calendar Staging, no marker information');\n  }\n\n  gp_closeInfoWindow(false);\n}\n\nfunction gp_addToCalendarList(shapeId) {\n  const items = gp_getMarkersFromTables(shapeId).map(marker => gp_getItemForCalendar(marker, 'record'));\n\n  if (items.length) {\n    gp_events.emit('addItemToCalendarStaging', items);\n  }\n\n  return false;\n}\n\ngp_events.on('updateCalendarEventsCount', function (count) {\n  var eventsCountBubble = document.querySelector('#calendarEventsCount');\n\n  if (eventsCountBubble) {\n    if (count > 0) {\n      eventsCountBubble.innerText = count;\n      eventsCountBubble.style.display = '';\n    } else {\n      eventsCountBubble.innerText = '';\n      eventsCountBubble.style.display = 'none';\n    }\n  }\n});\ngp_events.on('toasterMessage', function (toasterInfo) {\n  const message = toasterInfo.message;\n  Object.assign(toastr.options, {\n    timeOut: 5000\n  });\n\n  if (toasterInfo.isSuccess) {\n    toastr.success(gp_DOMPurify.sanitize(message));\n  } else if (toasterInfo.isInfo) {\n    toastr.info(gp_DOMPurify.sanitize(message));\n  } else {\n    toastr.error(gp_DOMPurify.sanitize(message));\n  }\n});\ngp_events.on('GeopointeJS_goog', ev => {\n  const {\n    action,\n    data\n  } = ev;\n\n  if (action === 'calculatePointsInSelectedShapes') {\n    const {\n      geoJSONHash\n    } = data;\n    gp_aggregates.batchId = guid();\n    gp_calcRecordsUtils.setPointsByShape(geoJSONHash).then(() => {\n      gp_aggregates.completedBatch = gp_aggregates.batchId;\n      const payload = {\n        action: 'calculatedPointsInSelectedShapes',\n        data: {}\n      };\n      gp_events.emit('multiShapeEditorService', payload);\n    });\n  } else if (action === 'calculateAggregatesInShapes') {\n    const {\n      shapeLayers,\n      geoJSONHash,\n      standardShapeLayers\n    } = data;\n    gp_calcRecordsUtils.clearAggregates();\n    gp_calcRecordsUtils.setAggregateFieldsByDataSet();\n    gp_calcRecordsUtils.setAggregateFieldsByCSV();\n    gp_calcRecordsUtils.setPointsByDataSet(); // mayber remove this line/\n\n    gp_calcRecordsUtils.setPointsByLegendValue();\n    gp_calcRecordsUtils.setShapeByShapeLayers(shapeLayers, standardShapeLayers);\n    gp_calcRecordsUtils.setPointsByShape(geoJSONHash, standardShapeLayers).then(function () {\n      gp_calcRecordsUtils.setSRecordIdsInShapes(shapeLayers);\n      gp_calcRecordsUtils.setPointsByShapeGroup();\n      gp_calcRecordsUtils.buildAllAggregates();\n      gp_aggregates.completedBatch = gp_aggregates.batchId;\n      const data = {\n        shapeLayers,\n        gp_aggregates\n      };\n      const payload = {\n        action: 'calculatedAggregates',\n        data\n      };\n      gp_events.emit('multiShapeEditorService', payload);\n    }).catch(e => {\n      console.error(e);\n    });\n  }\n});\n\nfunction gp_removeRecordsListAction(shapeId) {\n  window.geopointeAjaxStart('body', 'Removing items');\n  const markerTableHash = gp_getMarkersFromTables(shapeId).reduce((obj, marker) => {\n    const {\n      collectionName,\n      uniqueID\n    } = marker;\n\n    if (Array.isArray(obj[collectionName])) {\n      obj[collectionName] = obj[collectionName].concat(uniqueID);\n    } else {\n      obj[collectionName] = [uniqueID];\n    }\n\n    return obj;\n  }, {});\n  const layersToRemove = [];\n  let markerIds = [];\n  let tableIds = [];\n  Object.entries(markerTableHash).forEach(_ref5 => {\n    let [tableId, uniqueMarkerIds] = _ref5;\n    const tableElm = jQuery(\"#\".concat(tableId));\n    const table = tableElm.dataTable();\n    const gp_ColumnInfo = tableElm.data('columnInfo');\n    markerIds = markerIds.concat(uniqueMarkerIds);\n    tableIds = tableIds.concat(tableId); // update the num  of records\n\n    const markersToRemove = uniqueMarkerIds.length;\n    gp_dataSetSearches[tableId].numOfRecords -= markersToRemove; // Decrement the record count in the data table tab\n\n    const $countBubble = jQuery(\"#countBubble-\".concat(tableId));\n    const newCount = parseInt($countBubble.text()) - markersToRemove;\n    $countBubble.text(newCount); // For large amount of markers to remove clear the whole table and reAdd the filtered data\n    // this is faster than doing the fnDeleteRow() method\n\n    const dataTableData = table.fnGetData().filter(rowData => {\n      const markerId = rowData[gp_ColumnInfo.uniqueId];\n      const markerIdIndex = uniqueMarkerIds.indexOf(markerId);\n\n      if (markerIdIndex > -1) {\n        // remove the marker from teh marker array and then remove the row from the table\n        uniqueMarkerIds.splice(markerIdIndex, 1);\n        return false;\n      }\n\n      return true;\n    });\n\n    if (dataTableData.length) {\n      table.fnClearTable();\n      table.fnAddData(dataTableData, false);\n      table.fnDraw();\n    } else {\n      // if there are no more rows in the dataTable, then all of them have been removed. Remove the layer in this case\n      layersToRemove.push(tableId);\n    }\n  });\n\n  if (layersToRemove.length) {\n    const mapLayersService = angular.element('.dataSetController').injector().get('mapLayersService');\n    layersToRemove.forEach(layerId => {\n      const layer = mapLayersService.getLayerById(layerId);\n\n      if (layer) {\n        tableIds = tableIds.filter(id => id !== layerId);\n        mapLayersService.removeLayer(layer);\n      } //Need to refresh folder list to show refresh icon if only one DataSet is on map\n\n\n      setTimeout(() => {\n        angular.element('#ngApp').scope().$broadcast('folderListChanged');\n      }, 1);\n    });\n  } // remove the referenced shapes form the markers\n\n\n  for (const key in polygonObjects) {\n    const shape = polygonObjects[key];\n\n    if (shape.gpProperties.gpPoiId && markerIds.includes(shape.gpProperties.gpPoiId)) {\n      if (shape.mapLabel) shape.mapLabel.setMap(null);\n      if (shape.bufferPolygon) shape.bufferPolygon.setMap(null);\n      shape.setMap(null);\n      delete polygonObjects[key];\n    }\n  } //Recalculate the number of records in shapes\n\n\n  try {\n    calcRecordsInShapes();\n  } catch (e) {} //function doesn't exist for MQ\n  // Update the layers\n\n\n  angular.element('#ngApp').scope().$broadcast('layersChanged', {\n    doApply: true\n  }); // remove the markers from the map and update the legend\n\n  const mapLegendService = angular.element('.legendController').injector().get('mapLegendService');\n  markerIds.forEach(markerId => {\n    if (gp_markers[markerId]) {\n      //Remove the item from the legend\n      mapLegendService.remove(markerId);\n      gp_removeMarkerMap(markerId);\n    }\n  }); // rebuild the charts for each table;\n\n  tableIds.forEach(tableId => window.updateChartAfterMarkerRemoval(tableId));\n  window.geopointeAjaxEnd();\n} //Record action that launches process to create a new shape associated with a record, ie Polygon Field type\n\n\nfunction gp_addShapeFieldShape(recordId, poiId, name, lat, lng, gpCollectionName) {\n  gp_mapMode = 'addShape';\n  jQuery('#mapContextMenu').hide();\n  jQuery('.drawingControls').hide();\n  gp_enterDrawMode('polygon'); //Enter draw mode\n\n  gp_infoWindow.setMap(null); //Hide the open info window\n  // check for an existing zero-radius circle in the field (valid shape since release-26)\n\n  const editableCircle = _.find(polygonObjects, po => po.gpProperties.relatedRecordId == recordId && po.gpProperties.gpType == 'circle' && po.gpProperties.range == 0);\n\n  if (editableCircle) {\n    // since no clickable shape exists when circle is zero-sized, just open it from here\n    return gp_editShape(editableCircle.gpProperties.uniqueId);\n  } //Setup the angular controller by passing over data\n\n\n  var controller = angular.element('.shapeFieldTypeController').scope();\n  delete controller.sfdcId;\n  controller.$apply(function () {\n    controller.init();\n  });\n  controller.initGeoShapeList = true; //Make it so watch on shapeType fires\n\n  var shapeTypeBefore = controller.shapeType;\n  controller.shapeType = 'polygon';\n  controller.$apply();\n  controller.shapeType = shapeTypeBefore; //Init controller properties\n\n  controller.recordName = name;\n  controller.centerLatLng = {\n    lat: lat,\n    lng: lng\n  };\n  controller.relatedRecordId = recordId;\n  controller.getShapeFields();\n  controller.isEdit = false;\n  controller.gpCollectionName = gpCollectionName;\n  controller.poiId = poiId;\n  controller.initGeoShapeList = true;\n  controller.usedInAssignments = false;\n  controller.$apply();\n  jQuery('.mapControlsWrapper').hide(); //Hide the map controls, TODO this needs to be a smart function\n\n  jQuery('.hiddenPanel').hide(); //Hide any other open panels\n\n  jQuery('#addShapeFieldShape').show(); //Show the box explaining add shape mode\n\n  geopointeAjaxStart('#addShapeFieldShape', gp_translations.Loading + '...');\n}\n\nfunction gp_exitAddShapeMode() {\n  gp_mapMode = 'search';\n  gp_exitDrawMode(); //Exit draw mode\n\n  jQuery('.drawingControls').show();\n  jQuery('.mapControlsWrapper').show(); //Show the map controls, TODO this needs to be a smart function\n\n  jQuery('.hiddenPanel').hide(); //Hide any open panels\n  //Remove any Shape Fields that were not saved\n\n  for (key in polygonObjects) {\n    var shape = polygonObjects[key]; //Turn off edit mode for the shape\n\n    shape.setOptions({\n      editable: false\n    }); //Remove any pending shape that was drawn on the map\n\n    if (shape.gpProperties.usageType == 'Shape Field' && !shape.gpProperties.sfdcId) {\n      shape.setMap(null);\n      delete polygonObjects[key];\n    }\n  }\n}\n\nfunction gp_correctLocationHideMapObjects() {\n  var reshow = [];\n  var activeCollections = [];\n\n  for (var mx in gp_markers) {\n    var mkr = gp_markers[mx];\n\n    if (mkr.setMap) {\n      reshow.push(mkr);\n      mkr.setMap(null);\n    }\n\n    if (mkr.collectionName && gp_dataSetSearches[mkr.collectionName].markerClusterer && -1 == activeCollections.indexOf(mkr.collectionName)) {\n      activeCollections.push(mkr.collectionName); // only do this once\n\n      gp_dataSetSearches[mkr.collectionName].markerClusterer.clearMarkers();\n    }\n  }\n\n  for (var slx in gp_sameLocationMarkers) {\n    var mkr = gp_sameLocationMarkers[slx];\n\n    if (mkr.setMap) {\n      mkr.setMap(null);\n    }\n  }\n\n  gp_sameLocationMarkers = []; // they'll be completely rebuilt on exit\n\n  return reshow;\n} // Record Action that launches process to add custom/corrected Lat, Lng values to record\n\n\nfunction gp_correctLocation(poiId, name, customLatLng, latField, lngField) {\n  var mkr = gp_markers[poiId];\n\n  if (mkr.uniqueID !== poiId) {\n    console.log('poiId mismatch: ', poiId, mkr.uniqueID);\n  }\n\n  gp_mapMode = 'correctLocation';\n  jQuery('#mapContextMenu').hide();\n  jQuery('.drawingControls').hide();\n  gp_infoWindow.setMap(null);\n  gp_remapHidden = gp_correctLocationHideMapObjects();\n  gp_dragMarker = new google.maps.Marker({\n    uniqueID: mkr.uniqueID,\n    position: mkr.position,\n    icon: mkr.icon,\n    flat: true,\n    draggable: true\n  }); // follow along with label-only marker\n\n  if (mkr.mapLabel) {\n    gp_dragMarker.mapLabel = new MapLabel({\n      fontSize: mkr.mapLabel.fontSize,\n      strokeWeight: mkr.mapLabel.strokeWeight,\n      position: mkr.mapLabel.position,\n      text: mkr.mapLabel.text,\n      zIndex: mkr.mapLabel.zIndex\n    });\n    gp_dragMarker.setOpacity(mkr.opacity);\n    gp_dragMarker.type = mkr.type;\n    gp_dragMarker.addListener('dragend', function (event) {\n      gp_dragMarker.mapLabel.position = gp_dragMarker.position;\n      gp_dragMarker.mapLabel.setMap(gp_map);\n    });\n  }\n\n  var corLocController = angular.element('.correctLocationController').scope();\n  var recordId = 'centerPOI' == poiId ? gp_centerPOI.recordId : mkr.sObject.id;\n  var recordType = 'centerPOI' == poiId ? gp_centerPOI.sfdcObject : gp_dataSetSearches[mkr.collectionName].objectName;\n  corLocController.recordName = name;\n  corLocController.poiId = poiId;\n  corLocController.relatedRecordId = recordId;\n  corLocController.recordTypeString = recordType;\n  corLocController.customLatField = latField;\n  corLocController.customLngField = lngField;\n  corLocController.editAccess = customLatLng ? 'checking' : 'no';\n\n  if (customLatLng && (latField.indexOf('.') > 0 || lngField.indexOf('.') > 0)) {\n    corLocController.editAccess = 'ref'; // can't correct location on referenced MapObjects\n  }\n\n  if ('checking' === corLocController.editAccess) {\n    Visualforce.remoting.Manager.invokeAction(gpRemoteAction, 'Map_Controller.hasCorrectLocationWriteAccess', {\n      recordType: corLocController.recordTypeString,\n      recordId: recordId,\n      latField: latField,\n      lngField: lngField\n    }, function (result, event) {\n      if (event.status) {\n        corLocController.editAccess = result ? result : 'noPerm';\n\n        if ('custom' == corLocController.editAccess) {\n          corLocController.resetLocActive = true;\n          corLocController.editAccess = 'yes';\n        } else {\n          corLocController.resetLocActive = false;\n        }\n      } else {\n        corLocController.editAccess = 'noPerm';\n      }\n\n      corLocController.$apply();\n    });\n  }\n\n  corLocController.$apply();\n  jQuery('.mapControlsWrapper').hide();\n  jQuery('#correctLocation').show();\n  gp_dragMarker.setMap(gp_map);\n}\n\nfunction gp_correctLocationUpdateMarker() {\n  // pass new location info to Angular remoteAction caller\n  var corLocController = angular.element('.correctLocationController').scope();\n  corLocController.newLat = gp_dragMarker.position.lat();\n  corLocController.newLng = gp_dragMarker.position.lng();\n  var failback = gp_markers[gp_dragMarker.uniqueID].position;\n  gp_markers[gp_dragMarker.uniqueID].position = gp_dragMarker.position;\n\n  if (gp_markers[gp_dragMarker.uniqueID].mapLabel) {\n    gp_markers[gp_dragMarker.uniqueID].mapLabel.position = gp_dragMarker.position;\n    gp_markers[gp_dragMarker.uniqueID].mapLabel.setMap(gp_map);\n  }\n\n  return failback;\n}\n\nfunction gp_exitCorrectLocationMode(failback) {\n  jQuery('.mapControlsWrapper').show(); // Show the map controls\n\n  jQuery('#correctLocation').hide();\n\n  if (failback) {\n    gp_markers[gp_dragMarker.uniqueID].position = failback;\n\n    if (gp_markers[gp_dragMarker.uniqueID].mapLabel) {\n      gp_markers[gp_dragMarker.uniqueID].mapLabel.position = failback;\n      gp_markers[gp_dragMarker.uniqueID].mapLabel.setMap(gp_map);\n    }\n  } else {\n    // push new data into relevant dataTable row or\n    // gp_centerPOI, depending on what we're moving\n    var tableId = gp_markers[gp_dragMarker.uniqueID].collectionName;\n\n    if ('centerPOI' == tableId) {\n      gp_centerPOI.lat = gp_centerPOI.latDisplay = gp_markers[gp_dragMarker.uniqueID].position.lat();\n      gp_centerPOI.lng = gp_centerPOI.lngDisplay = gp_markers[gp_dragMarker.uniqueID].position.lng();\n    } else {\n      var dataElement = jQuery('#' + tableId);\n      var aoData = dataElement.dataTable().fnGetData();\n      var colInfo = dataElement.data('columnInfo');\n\n      if (aoData && aoData.length && colInfo) {\n        for (var i = 0, iLen = aoData.length; i < iLen; i++) {\n          var thisRow = aoData[i];\n\n          if (thisRow[colInfo.uniqueId] == gp_dragMarker.uniqueID) {\n            thisRow[colInfo.latitude] = thisRow[gp_ColumnInfo.latitudeDisplay] = gp_markers[gp_dragMarker.uniqueID].position.lat();\n            thisRow[colInfo.longitude] = thisRow[gp_ColumnInfo.longitudeDisplay] = gp_markers[gp_dragMarker.uniqueID].position.lng();\n            break;\n          }\n        }\n      }\n    }\n\n    gp_createSameLocationMarkers();\n  }\n\n  gp_dragMarker.setMap(null);\n  gp_dragMarker = null; // unhide all hidden objects\n\n  var remapped = [];\n\n  for (var hx in gp_remapHidden) {\n    var mkr = gp_remapHidden[hx];\n\n    if (mkr.setMap) {\n      mkr.setMap(gp_map);\n\n      if (mkr.collectionName && gp_dataSetSearches[mkr.collectionName]) {\n        if (-1 == remapped.indexOf(mkr.collectionName)) {\n          remapped.push(mkr.collectionName); // just do this once per collection\n        }\n      }\n    }\n  }\n\n  for (var cx in remapped) {\n    if (gp_dataSetSearches[remapped[cx]]) {\n      gp_restoreDataSetSearchOnMap(remapped[cx]);\n    }\n  }\n\n  gp_mapMode = 'search';\n  jQuery('.drawingControls').show();\n} // Extend the google Marker.setMap method to include awareness of mapLabel objects and their visibility\n\n\ngoogle.maps.Marker.prototype.gp_superSetMap = google.maps.Marker.prototype.setMap;\n\ngoogle.maps.Marker.prototype.setMap = function (map, labelVisible) {\n  if (this.gp_superSetMap) {\n    this.gp_superSetMap(map);\n  } else {\n    console.log('marker gp_superSetMap missing');\n  } // Set correct visibility for marker label (if any)\n\n\n  if (this.mapLabel) {\n    var dsSrch = gp_dataSetSearches[this.collectionName];\n\n    if (map) {\n      var showLabel = undefined != labelVisible ? labelVisible : dsSrch && dsSrch.layerSettings ? dsSrch.layerSettings.markerLabelsVisible : true;\n      this.mapLabel.setMap(showLabel ? map : null);\n    } else {\n      this.mapLabel.setMap(null); // labels always disappear with their marker\n    }\n  } // Set correct visibility for selected checkbox marker (if any)\n\n\n  if (this.selectedMarker) {\n    this.selectedMarker.setMap(map);\n  }\n}; //Extend the google Polygon object with getBounds - https://github.com/tparkin/Google-Maps-Point-in-Polygon\n\n\nif (!google.maps.Polygon.prototype.getBounds) {\n  google.maps.Polygon.prototype.getBounds = function (latLng) {\n    var bounds = new google.maps.LatLngBounds();\n    var paths = this.getPaths();\n    var path;\n\n    for (var p = 0; p < paths.getLength(); p++) {\n      path = paths.getAt(p);\n\n      for (var i = 0; i < path.getLength(); i++) {\n        bounds.extend(path.getAt(i));\n      }\n    }\n\n    return bounds;\n  };\n} // Also extend google Polyline with getBounds\n\n\nif (!google.maps.Polyline.prototype.getBounds) {\n  google.maps.Polyline.prototype.getBounds = function () {\n    var bounds = new google.maps.LatLngBounds();\n    this.getPath().forEach(function (item, index) {\n      bounds.extend(new google.maps.LatLng(item.lat(), item.lng()));\n    });\n    return bounds;\n  };\n}\n/*Start Heatmap Methods */\n\n\nfunction toggleHeatMap(layer) {\n  var collectionName = layer.id; //Check to see if heatmap is all ready visible on the map, and if so remove it\n\n  if (gp_heatmaps[collectionName]) {\n    if (gp_heatmaps[collectionName].getMap()) {\n      //Remove from map\n      gp_heatmaps[collectionName].setMap(null);\n      delete gp_heatmaps[collectionName]; //Hide the heat map slider controls\n\n      jQuery('#heatMapSlider-' + collectionName).hide(); //jQuery(btn).removeClass('btnSelected');\n      //Add markers back to map\n\n      if (gp_dataSetSearches[collectionName]) {\n        gp_dataSetSearches[collectionName].markersVisible = true;\n      }\n\n      gp_restoreDataSetSearchOnMap(collectionName, true);\n    }\n  } else {\n    //Need to add to map\n    heatmap = new google.maps.visualization.HeatmapLayer({\n      opacity: 0.5,\n      radius: jQuery('#heatmapSlider-' + collectionName).slider('value'),\n      maxIntensity: 5,\n      gradient: ['rgba(0, 0, 255, 0)', 'rgba(0, 0, 255, 1)', 'rgba(0, 255, 255, 1)', 'rgba(0, 255, 0, 1)', 'rgba(255, 255, 0, 1)', 'rgba(255, 0, 0, 1)']\n    });\n\n    if (layer.heatmapWeightField) {\n      heatmap.gp_weightField = layer.heatmapWeightField.field;\n    }\n\n    if (layer.heatMapNormalizationMode) {\n      heatmap.gp_heatMapNormalizationMode = layer.heatMapNormalizationMode.value;\n    }\n\n    if (typeof layer.showHeatMapMarkers !== 'undefined') {\n      heatmap.gp_showHeatMapMarkers = layer.showHeatMapMarkers;\n    }\n\n    heatmap.setMap(gp_map); //Remove the marker pins on the map\n\n    if (!layer.showHeatMapMarkers) {\n      gp_removeDataSetSearchFromMap(collectionName, true);\n      gp_dataSetSearches[collectionName].markersVisible = false;\n    } else {\n      gp_dataSetSearches[collectionName].markersVisible = true;\n    } //Add to heatmap object\n\n\n    gp_heatmaps[collectionName] = heatmap; //Update the data points for the heatmap\n\n    updateHeapMapDataPoints(collectionName); //Track in mixpanel\n\n    if (gp_dataSetSearches[collectionName]) {\n      gp_track('Heatmap Added', {\n        'Number of Markers': gp_dataSetSearches[collectionName].numOfRecords,\n        'Zoom Level': gp_getZoomLevel()\n      });\n    }\n  }\n}\n\nfunction updateHeapMapDataPoints(collectionName) {\n  const heatmap = gp_heatmaps[collectionName]; //Create array of google.maps.LatLng objects\n\n  if (heatmap) {\n    let latLngs = [];\n    let maxIntensity = 5;\n    const {\n      gp_heatMapNormalizationMode: mode,\n      gp_weightField,\n      gp_showHeatMapMarkers\n    } = heatmap;\n\n    for (const key in gp_markers) {\n      const marker = gp_markers[key];\n\n      if (marker && marker.collectionName == collectionName && marker.hiddenByLegend !== true) {\n        if (gp_weightField) {\n          let weight = getDescendantProp(marker.sObject, gp_weightField);\n          if (!weight || weight < 0) weight = 0;\n          if (weight > maxIntensity) maxIntensity = weight;\n          latLngs.push({\n            location: marker.getPosition(),\n            weight\n          });\n        } else {\n          latLngs.push(marker.getPosition());\n        } // hide the markers if the heatmap marker toggle is turned off\n\n\n        if (!gp_showHeatMapMarkers) marker.setMap(null);\n      }\n    } // if the mode is scaled update the weights\n\n\n    if (mode === 'scaled') {\n      if (gp_weightField) {\n        const data = latLngs.map(_ref6 => {\n          let {\n            weight\n          } = _ref6;\n          return weight;\n        });\n        const totalRecords = data.length;\n        const mean = getMean(data, totalRecords);\n        const stDev = getStandardDeviation(data, mean, totalRecords);\n        const maxDev = mean + stDev;\n        const minDev = mean - stDev;\n        maxIntensity = 5;\n        latLngs = latLngs.map(_ref7 => {\n          let {\n            location,\n            weight\n          } = _ref7;\n          if (weight > maxDev) weight = maxDev;else if (weight < minDev) weight = minDev;\n          if (weight > maxIntensity) maxIntensity = weight;\n          return {\n            location,\n            weight\n          };\n        });\n\n        function getStandardDeviation(arr, mean, totalNumber) {\n          return Math.sqrt(getMean(arr.map(x => Math.pow(x - mean, 2)), totalNumber));\n        }\n\n        function getMean(arr, n) {\n          if (isNaN(n)) n = arr.length;\n          return arr.reduce((a, b) => a + b) / n;\n        }\n      }\n    } //Update the heatmap\n\n\n    gp_heatmaps[collectionName].set('maxIntensity', maxIntensity);\n    gp_heatmaps[collectionName].set('data', new google.maps.MVCArray(latLngs));\n  }\n}\n\nfunction toggleMapMarkers(collectionName) {\n  //Only proceed if gp_dataSetSearches object contains meta data for this search, it always should\n  if (gp_dataSetSearches[collectionName]) {\n    if (gp_dataSetSearches[collectionName].markersVisible != false) {\n      gp_removeDataSetSearchFromMap(collectionName, true); //Update the gp_dataSetSearches object with state of marker visibility\n\n      if (gp_dataSetSearches[collectionName]) {\n        gp_dataSetSearches[collectionName].markersVisible = false;\n      }\n    } else {\n      //Update the gp_dataSetSearches object with state of marker visibility\n      if (gp_dataSetSearches[collectionName]) {\n        gp_dataSetSearches[collectionName].markersVisible = true;\n      }\n\n      gp_restoreDataSetSearchOnMap(collectionName); //Add markers to map\n    }\n  }\n}\n/* End Heatmap Methods */\n\n\nfunction gp_setCurrentPositionMarker(callback) {\n  // spin the icon as feedback - this may take a sec...\n  var spinner = jQuery('.fa-location-arrow').addClass('fa-spin');\n  navigator.geolocation.getCurrentPosition(function (position) {\n    spinner.removeClass('fa-spin');\n    var curLoc = gp_markers['gp_currentLocation'];\n\n    if (curLoc) {\n      curLoc.setMap(null);\n    } // SECURITY: gp_createMarker must be called with sanitized html (3rd parameter). 3rd param is a static string here\n\n\n    curLoc = gp_createMarker(new google.maps.LatLng(position.coords.latitude, position.coords.longitude), 'Current Location', '<div class=\"poiTitle\">Current Location</div>', gpImg.currentLocation, 'gp_currentLocation');\n    curLoc.setIcon({\n      url: gpImg.currentLocation,\n      scaledSize: new google.maps.Size(30, 30),\n      anchor: new google.maps.Point(12, 12)\n    });\n    curLoc.setMap(gp_map);\n    gp_markers['gp_currentLocation'] = curLoc;\n\n    if (typeof callback === 'function') {\n      callback(curLoc.position);\n    }\n  }, function () {\n    // called if getCurrentPosition fails\n    spinner.removeClass('fa-spin');\n  });\n}\n\nfunction gp_addLongPressListeners(layer) {\n  google.maps.event.addListener(layer, 'mousedown', event => {\n    gp_isMouseUp = false;\n    gp_isLongPress = false;\n    setTimeout(() => {\n      // Google maps passes the dom event object but so look for it and then check if the type of event is touchstart\n      // if it is not then the user did not open the infoWindow with a long press\n      if (event) {\n        for (const prop of Object.values(event)) {\n          if (prop instanceof Event) {\n            if (prop.type !== 'touchstart') return;\n          }\n        }\n      } else {\n        return;\n      }\n\n      if (!gp_isMouseUp && !gp_isDrawingMode) {\n        gp_isLongPress = true;\n        gp_openRigthClickMenu(event);\n      }\n    }, 500);\n  });\n  google.maps.event.addListener(layer, 'mouseup', event => {\n    gp_isMouseUp = true;\n  });\n}\n\nfunction gp_closeInfoWindow() {\n  let hideToolTip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  gp_infoWindow.thematicLayerId = null;\n  gp_infoWindow.locationId = null;\n  gp_infoWindow.layered = false;\n  gp_infoWindow.wmsLayerId = null;\n  gp_infoWindow.markerId = null;\n  gp_infoWindow.groupLayerId = null;\n  gp_infoWindow.tabsDIV = null;\n  gp_infoWindow.clusterId = null;\n  gp_infoWindow.close();\n  if (hideToolTip) gp_tooltip.close();\n}\n\ngoogle.maps.Polyline.prototype.douglasPeucker = function (tolerance) {\n  var res = null; //adjust tolerance depending on the zoom level\n\n  tolerance = tolerance * Math.pow(2, 20 - gp_map.getZoom());\n\n  if (this.getPath() && this.getPath().getLength()) {\n    var points = this.getPath().getArray();\n\n    var Line = function Line(p1, p2) {\n      this.p1 = p1;\n      this.p2 = p2;\n\n      this.distanceToPoint = function (point) {\n        // slope\n        var m = (this.p2.lat() - this.p1.lat()) / (this.p2.lng() - this.p1.lng()),\n            // y offset\n        b = this.p1.lat() - m * this.p1.lng(),\n            d = []; // distance to the linear equation\n\n        d.push(Math.abs(point.lat() - m * point.lng() - b) / Math.sqrt(Math.pow(m, 2) + 1)); // distance to p1\n\n        d.push(Math.sqrt(Math.pow(point.lng() - this.p1.lng(), 2) + Math.pow(point.lat() - this.p1.lat(), 2))); // distance to p2\n\n        d.push(Math.sqrt(Math.pow(point.lng() - this.p2.lng(), 2) + Math.pow(point.lat() - this.p2.lat(), 2))); // return the smallest distance\n\n        return d.sort(function (a, b) {\n          return a - b; //causes an array to be sorted numerically and ascending\n        })[0];\n      };\n    };\n\n    var douglasPeucker = function douglasPeucker(points, tolerance) {\n      if (points.length <= 2) {\n        return [points[0]];\n      }\n\n      var returnPoints = [],\n          // make line from start to end\n      line = new Line(points[0], points[points.length - 1]),\n          // find the largest distance from intermediate poitns to this line\n      maxDistance = 0,\n          maxDistanceIndex = 0,\n          p;\n\n      for (var i = 1; i <= points.length - 2; i++) {\n        var distance = line.distanceToPoint(points[i]);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          maxDistanceIndex = i;\n        }\n      } // check if the max distance is greater than our tollerance allows\n\n\n      if (maxDistance >= tolerance) {\n        p = points[maxDistanceIndex];\n        line.distanceToPoint(p, true); // include this point in the output\n\n        returnPoints = returnPoints.concat(douglasPeucker(points.slice(0, maxDistanceIndex + 1), tolerance)); // returnPoints.push( points[maxDistanceIndex] );\n\n        returnPoints = returnPoints.concat(douglasPeucker(points.slice(maxDistanceIndex, points.length), tolerance));\n      } else {\n        // ditching this point\n        p = points[maxDistanceIndex];\n        line.distanceToPoint(p, true);\n        returnPoints = [points[0]];\n      }\n\n      return returnPoints;\n    };\n\n    res = douglasPeucker(points, tolerance); // always have to push the very last point on so it doesn't get left off\n\n    res.push(points[points.length - 1]);\n    this.setPath(res);\n  }\n\n  return this;\n}; //http://jsfiddle.net/9gvsq3od/\n///Start custom poly fill code\n\n\nPolyLineFill.prototype = new google.maps.OverlayView();\nPolyLineFill.prototype.constructor = PolyLineFill;\n\nfunction PolyLineFill(poly, map, options) {\n  var bounds = new google.maps.LatLngBounds();\n\n  for (var i = 0; i < poly.length; i++) {\n    bounds.extend(poly[i]);\n  } //initialize all properties.\n\n\n  this.bounds_ = bounds;\n  this.map_ = map;\n  this.div_ = null;\n  this.poly_ = poly;\n  this.polysvg_ = null;\n  this.fill_ = options.fill;\n  this.opacity_ = options.opacity || '0.5';\n  this.stroke_ = options.stroke;\n  this.onClick_ = options.onClick; // Explicitly call setMap on this overlay\n\n  this.setMap(map);\n}\n\nPolyLineFill.prototype.updateStyle = function (style) {\n  this.fill_ = style.fill || this.fill_;\n  this.stroke_ = style.stroke || this.stroke_;\n  this.setMap(this.map_);\n};\n\nPolyLineFill.prototype.onAdd = function () {\n  // Create the DIV and set some basic attributes.\n  var div = document.createElement('div');\n  div.style.borderStyle = 'none';\n  div.style.borderWidth = '0px';\n  div.style.position = 'absolute'; //createthe svg element\n\n  var svgns = 'http://www.w3.org/2000/svg';\n  var svg = document.createElementNS(svgns, 'svg');\n  svg.setAttributeNS(null, 'preserveAspectRatio', 'xMidYMid meet');\n  var def = document.createElementNS(svgns, 'defs'); //create the pattern fill\n\n  var pattern = document.createElementNS(svgns, 'pattern');\n  pattern.setAttributeNS(null, 'id', 'lineFill');\n  pattern.setAttributeNS(null, 'patternUnits', 'userSpaceOnUse');\n  pattern.setAttributeNS(null, 'patternTransform', 'rotate(-45)');\n  pattern.setAttributeNS(null, 'height', '4');\n  pattern.setAttributeNS(null, 'width', '4');\n  def.appendChild(pattern);\n  var rect = document.createElementNS(svgns, 'rect');\n  rect.setAttributeNS(null, 'id', 'rectFill');\n  rect.setAttributeNS(null, 'fill', this.fill_ || 'none');\n  rect.setAttributeNS(null, 'fill-opacity', this.opacity_ || '0.5');\n  rect.setAttributeNS(null, 'stroke', this.stroke_ || 'black');\n  rect.setAttributeNS(null, 'stroke-width', '2');\n  rect.setAttributeNS(null, 'stroke-opacity', '0.1'); // rect.setAttributeNS(null, \"stroke-dasharray\", \"7,7\");\n\n  rect.setAttributeNS(null, 'height', '4');\n  rect.setAttributeNS(null, 'width', '4');\n  pattern.appendChild(rect);\n  svg.appendChild(def); //add path to the div\n\n  var path = document.createElementNS(svgns, 'path');\n  path.setAttributeNS(null, 'fill', 'url(#lineFill)');\n  path.setAttributeNS(null, 'stroke', '#000');\n  path.setAttributeNS(null, 'stroke-width', '1');\n  this.path_ = path;\n  svg.appendChild(this.path_);\n  svg.appendChild(this.path_);\n  div.appendChild(svg); // Set the overlay's div_ property to this DIV\n\n  this.div_ = div;\n  this.div_.className = 'polygon'; // We add an overlay to a map via one of the map's panes.\n  // We'll add this overlay to the overlayLayer pane.\n\n  var panes = this.getPanes();\n  panes.overlayLayer.appendChild(div);\n};\n\nPolyLineFill.prototype.AdjustPoints = function () {\n  //adjust the polygon points based on the projection.\n  var proj = this.getProjection();\n  var sw = proj.fromLatLngToDivPixel(this.bounds_.getSouthWest());\n  var ne = proj.fromLatLngToDivPixel(this.bounds_.getNorthEast());\n  var points = '';\n\n  for (var i = 0; i < this.poly_.length; i++) {\n    var point = proj.fromLatLngToDivPixel(this.poly_[i]);\n\n    if (i == 0) {\n      points += point.x - sw.x + ', ' + (point.y - ne.y);\n    } else {\n      points += ' ' + (point.x - sw.x) + ', ' + (point.y - ne.y);\n    }\n  }\n\n  return points;\n};\n\nPolyLineFill.prototype.draw = function () {\n  // Size and position the overlay. We use a southwest and northeast\n  // position of the overlay to peg it to the correct position and size.\n  // We need to retrieve the projection from this overlay to do this.\n  var overlayProjection = this.getProjection(); // Retrieve the southwest and northeast coordinates of this overlay\n  // in latlngs and convert them to pixels coordinates.\n  // We'll use these coordinates to resize the DIV.\n\n  var sw = overlayProjection.fromLatLngToDivPixel(this.bounds_.getSouthWest());\n  var ne = overlayProjection.fromLatLngToDivPixel(this.bounds_.getNorthEast()); // Resize the image's DIV to fit the indicated dimensions.\n\n  var div = this.div_;\n  div.style.left = sw.x + 'px';\n  div.style.top = ne.y + 'px';\n  div.style.width = ne.x - sw.x + 'px';\n  div.style.height = sw.y - ne.y + 'px';\n  this.path_.setAttributeNS(null, 'd', 'M' + this.AdjustPoints() + 'z');\n};\n\nPolyLineFill.prototype.onRemove = function () {\n  this.div_.parentNode.removeChild(this.div_);\n  this.div_ = null;\n}; ///end poly fill code"}]);
//# sourceMappingURL=GeopointeJS_goog.js.map