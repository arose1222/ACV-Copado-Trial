!function(e){var n={};function t(a){if(n[a])return n[a].exports;var o=n[a]={i:a,l:!1,exports:{}};return e[a].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=e,t.c=n,t.d=function(e,n,a){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:a})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(t.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(a,o,function(n){return e[n]}.bind(null,o));return a},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=4)}([function(e,n){e.exports=function(e){function n(e){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",e)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(e):"undefined"!=typeof eval?eval.call(null,e):n("EvalError: No eval function available")}catch(e){n(e)}}},,,,function(e,n,t){e.exports=t(5)},function(e,n,t){t(0)(t(6))},function(e,n){e.exports="/*************************\n * Global  Vars\n *************************/\nvar gp_stopSubmit = false,\n    // boolean to stop the form submit in certain cases\ngp_dataSetInfo = {},\n    gp_objectMeta = new Object(),\n    // global holding configuration information for each map object\ngp_tooltips = new Object(),\n    // global holding the content of the tooltips\ngp_userSettings,\n    // global holding the user settings record + some additional user specific info\ngp_orgSettings,\n    // global holding the org settings record + some additional org specific info\ngp_lastMapObject,\n    // a string with the most recent Map Object selected based upon the data set selected\ngp_lastDataSet,\n    //keeps track of previously selected data set\ngp_centerPOICollectionName = 'centerPOI',\n    // a constant, keep it in sync with the value in controller, mq\ngp_searchPOICollectionName = 'searchPOI',\n    // collecton name for address search marker mq\ngp_centerPOI = {},\n    // Object containing information about the centerPOI since we are not holding it in a Data Table, goog\ngp_searchPOI,\n    // Object containing information about the searchPOI since we are not holding it in a Data Table, goog\ngp_selectedPlacePOI,\n    //When a places marker is clicked this object is updated with information such as name, address, etc\ngp_baseURL,\n    // The Base Salesforce URL for the org\ngp_searchAddress,\n    //Updated with parsed geocode response everytime a address search is performed\ngp_radialAddress,\n    //Updated with parsed geocode response everytime a radial search is performed\ngp_centerPointKeepAddress,\n    //Boolean that keeps track if the center point address should be saved and used instead of reverse geocoding on radial searches\ngp_dataSetSearches = {},\n    //Keeps track of basic info about each data set search that is performed, stays in sync with data searches/list, reset with each search when clear existing = true\ngp_recordSearchPOI,\n    gp_recordSearchCollectionName = 'recordSearchPOI'; // Visualforce UI Elements on Map page that get put into JavaScript variables since their ID is unpredictable\n\nvar gp_UIElem = {\n  selectedcolor: null,\n  // override marker color\n  dataSetSelectList: null,\n  // drop-down box for the data set select. code at Penske uses this\n  hidden_routeLocXML: null,\n  // hidden form data\n  hidden_colorMarkersBy: null,\n  // hidden form data\n  googViz_DataSet: null,\n  // Data Set\n  googViz_Region: null,\n  // Region\n  googViz_SumBy: null,\n  // Summarize By\n  googViz_showData: null,\n  // Show data table\n  analytics_DataSetList: null,\n  // list of DS to load to SK\n  analytics_OrgWide: null\n}; //Column Definitions for the Data Tables\n\nvar gp_ColumnInfo = {\n  uniqueId: 0,\n  recordId: 1,\n  mapIconURLDataTable: 2,\n  mapIconURL: 3,\n  mapIconColor: 4,\n  mapIconSize: 5,\n  latitude: 6,\n  longitude: 7,\n  latitudeDisplay: 8,\n  longitudeDisplay: 9,\n  usesCustomerGeocode: 10,\n  actions: 11,\n  rowNum: 12,\n  title: 13,\n  title2: 14,\n  fulladdress: 15,\n  street: 16,\n  city: 17,\n  state: 18,\n  postalCode: 19,\n  country: 20,\n  countryISO: 21,\n  col1Type: 22,\n  col1Value: 23,\n  col2Type: 24,\n  col2Value: 25,\n  col3Type: 26,\n  col3Value: 27,\n  col4Type: 28,\n  col4Value: 29,\n  col5Type: 30,\n  col5Value: 31,\n  distance: 32,\n  distanceDrive: 33,\n  geocodeQuality: 34,\n  infoContent: 35,\n  recordTypeId: 38,\n  timeDrive: 39\n}; //Little script that should prevent console errors in IE\n\nif (!window.console || typeof console == 'undefined') {\n  console = {\n    log: function log() {},\n    time: function time() {},\n    timeEnd: function timeEnd() {}\n  };\n} // Run the jQuery noConflict code if jQuery is loaded\n\n\nif (typeof jQuery !== 'undefined') {\n  jQuery.noConflict();\n}\n/*************************\n * jQuery Data Tables functions\n *************************/\n\n\nfunction __JQUERY_DATA_TABLE_FUNCTIONS__() {} //Add custom filtering function for data tables, some pages don't have table to wrap in try catch\n\n\ntry {\n  jQuery.fn.dataTableExt.afnFiltering.push(function (oSettings, aData, iDataIndex) {\n    //Get the unique id of the record and the corresponding map marker\n    var uniqueId = oSettings.aoData[iDataIndex]._aData[0];\n    var marker = gp_markers[uniqueId];\n\n    if (marker) {\n      if (marker.hiddenByLegend === true) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  });\n} catch (e) {} // Destroy all jQuery Data Tables in the DIV passed in\n\n\nfunction gp_destroyDataTables(div) {\n  //Wipe out the dataset result tabs and content\n  jQuery('.dataSetResultTableTab,.dataSetResultTableTabContent').remove();\n  jQuery('#gp_dataTablesNoData').show();\n} // Create a new tab that will contain the data table\n\n\nfunction gp_newDataTableStructure(div, poiCollection) {\n  jQuery('#gp_dataTables').show(); //Set the left and right padding for the tabs, varies due to translations\n\n  var $tabsList = jQuery('#gp_dataTableTabs ul:first');\n  $tabsList.css({\n    'padding-left': jQuery('#mappedDataTitle').width() + 17,\n    'padding-right': jQuery('#mappedDataButtons').width() + 13\n  }); //Create label for tab and add to page, first determine count bubble color\n\n  var countColor = poiCollection.mapIconColor;\n  var colorOverride = jQuery(\"input[id$='gp_selectedcolor']\").val();\n\n  if (colorOverride) {\n    countColor = colorOverride;\n  }\n\n  var tabLabel = '<li class=\"dataSetResultTableTab\" data-collectionName=\"' + poiCollection.collectionName + '\">' + '<a href=\"#tabs-' + poiCollection.collectionName + '\">' + '<span class=\"poiCollectionTabLabel\" data-collectionName=\"' + poiCollection.collectionName + '\" notranslate>' + poiCollection.dataSetName + '</span>&nbsp;&nbsp;' + '<span id=\"countBubble-' + poiCollection.collectionName + '\" class=\"countBubble countBubbleTab\" style=\"background-color:#' + countColor + ';\">' + poiCollection.POIs.length + '</span>' + '<img class=\"tabShowHideIcon tabHideIcon removeDataSetSearchIcon\" src=\"' + blackXiconURL + '\" data-collectionName=\"' + poiCollection.collectionName + '\" title=\"Remove Data Set Search from map\"/>' + '<img class=\"tabShowHideIcon tabShowIcon showDataSetSearchIcon\" src=\"' + blackPlusIconURL + '\" data-collectionName=\"' + poiCollection.collectionName + '\" title=\"Show Data Set Search on map\"/>' + '</a>' + '</li>';\n  jQuery('#gp_dataTableTabs ul').append(gp_DOMPurify.sanitize(tabLabel)); //Create the tab content which is the datatable\n\n  var tabContent = '<div class=\"dataSetResultTableTabContent\" id=\"tabs-' + poiCollection.collectionName + '\">' + '<div class=\"removeDataSetSearchButtons\" id=\"removeDataSetSearchButtons' + poiCollection.collectionName + '\">' + '<input class=\"showDataSetBtn btn\" type=\"button\" value=\"Show Data Set\" data-collectionName=\"' + poiCollection.collectionName + '\"/>' + '<input class=\"removeDataSetTabBtn btn\" type=\"button\" value=\"Remove Data Set Tab\" data-collectionName=\"' + poiCollection.collectionName + '\"/>' + '</div>' + '<div class=\"chartPanel\" id=\"chartPane-' + poiCollection.collectionName + '\">Here goes the charts</div>' + '<div class=\"dataTableScrollWrapper\" style=\"visibility:hidden;\"></div>' + '<table cellpadding=\"0\" cellspacing=\"0\" border=\"0\" width=\"100%\" class=\"list display gp_dataTable\" id=\"' + poiCollection.collectionName + '\"></table>' + '</div>';\n  jQuery('#gp_dataTableTabs').append(gp_DOMPurify.sanitize(tabContent)); //Refresh the tab panel so jQuery UI relfects the newly added tab, fist store the scroll offset as refresh could cause scroll bars to jump\n\n  jQuery('#gp_dataTableTabs').tabs('refresh');\n  jQuery('#gp_dataTablesNoData').hide();\n} // SECURITY: Returns sanitized html string\n\n\nfunction gp_constructRecordActionsDD(thisPOIC, aData) {\n  // SECURITY: because the html string includes javascript, we will sanitize variables as we construct the string\n  return '<i style=\"margin-top:-5px;margin-left:4px;margin-right:5px;\" class=\"fa fa-caret-square-o-down recordActionsDropDownIcon\" title=\"View Record Actions\" alt=\"View Record Actions\" data-uniqueId=\"' + gp_DOMPurify.sanitize(aData[gp_ColumnInfo.uniqueId]) + '\"></i>' + '<div class=\"recordActionsDropDown\" id=\"gpActionDD-' + aData[gp_ColumnInfo.uniqueId] + '\">' + '<div class=\"actionPlaceholder\">hi</div>' + '<a href=\"#\" onclick=\"gp_zoomToStreet(' + gp_DOMPurify.sanitize(aData[gp_ColumnInfo.latitude] + ',' + aData[gp_ColumnInfo.longitude]) + ',16);event.preventDefault();\">' + gp_DOMPurify.sanitize(gp_translations.Zoom_and_Center) + '</a>' + '</div>';\n} // Define the Data Table Columns array\n\n\nfunction gp_defineDataTableColumns(thisPOIC) {\n  var dsController = angular.element('.dataSetController').scope(); // Create column structure for jQuery Table\n\n  var tableCols = new Array(); // Hidden columns\n\n  /* 0 */\n\n  tableCols.push({\n    sTitle: 'Unique Id',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell',\n    gpName: 'uniqueId'\n  });\n  /* 1 */\n\n  tableCols.push({\n    sTitle: gp_DOMPurify.sanitize(gp_translations.Record_Id),\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell',\n    gpName: 'recordId'\n  });\n  /* 2 */\n\n  tableCols.push({\n    sTitle: 'Map Icon URL Data Table',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell',\n    gpName: 'mapIconURLDataTable'\n  });\n  /* 3 */\n\n  tableCols.push({\n    sTitle: 'Map Icon URL',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell',\n    gpName: 'mapIconURL'\n  });\n  /* 4 */\n\n  tableCols.push({\n    sTitle: 'Map Icon Color',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell',\n    gpName: 'mapIconColor'\n  });\n  /* 5 */\n\n  tableCols.push({\n    sTitle: 'Map Icon Size',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell',\n    gpName: 'mapIconSize'\n  });\n  /* 6 */\n\n  tableCols.push({\n    sTitle: 'Latitude',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell',\n    gpName: 'latitude'\n  });\n  /* 7 */\n\n  tableCols.push({\n    sTitle: 'Longitude',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell',\n    gpName: 'longitude'\n  });\n  /* 8 */\n\n  tableCols.push({\n    sTitle: 'Latitude (display)',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell',\n    gpName: 'latitudeDisplay'\n  });\n  /* 9 */\n\n  tableCols.push({\n    sTitle: 'Longitude (display)',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell',\n    gpName: 'longitudeDisplay'\n  });\n  /* 10 */\n\n  tableCols.push({\n    sTitle: 'Uses Customer Geocodes',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell',\n    gpName: 'usesCustomerGeocode'\n  }); // Displayed Columns\n\n  var actionColWidth = '82px';\n  var markerHeight = '23px';\n\n  if (isTouchDevice) {\n    actionColWidth = '160px';\n    markerHeight = '30px';\n  }\n\n  var labelOnlySrcURL = thisPOIC.POIs[0].markerType && 'label' == thisPOIC.POIs[0].markerType ? GEOPOINTE_API + '/v1/markers/pin-m+' + dsController.baseColorPalette[0] + '.png' : '';\n  /* 11 */\n\n  tableCols.push({\n    sTitle: 'Actions',\n    bSearchable: false,\n    bSortable: false,\n    sClass: 'dataCell',\n    sWidth: actionColWidth,\n    bUseRendered: false,\n    gpName: 'actions',\n    fnRender: function fnRender(obj) {\n      const uniqueIdSanitized = gp_DOMPurify.sanitize(obj.aData[gp_ColumnInfo.uniqueId]);\n      const uniqueIdSpan = \"<span class=\\\"directionsMarkerId\\\" style=\\\"display:none;\\\">\".concat(uniqueIdSanitized, \"</span>\");\n      let checkbox = \"<input type=\\\"checkbox\\\" onclick=\\\"gp_toggleRecordSelection('\".concat(uniqueIdSanitized, \"', '\").concat(gp_DOMPurify.sanitize(thisPOIC.collectionName), \"')\\\"\");\n\n      if (gp_selectedRecords[obj.aData[gp_ColumnInfo.uniqueId]]) {\n        checkbox += ' checked ';\n      }\n\n      checkbox += '/>';\n      const mapIcon = \"<div\\n        style=\\\"display:inline-block;padding-left: 4px;margin-left:3px;margin-right:3px;width: \".concat(markerHeight, \"\\\">\\n        <img\\n        style=\\\"cursor: pointer; vertical-align:middle; height:\").concat(markerHeight, \"\\\"\\n        onclick=\\\"javascript:gp_openPoiInfoMarker('\").concat(uniqueIdSanitized, \"'); return false;\\\"\\n        src=\\\"\").concat(gp_DOMPurify.sanitize(labelOnlySrcURL ? labelOnlySrcURL : obj.aData[gp_ColumnInfo.mapIconURLDataTable]), \"\\\"\\n        title=\\\"Open Info Bubble on map\\\"\\n        alt=\\\"Open Info Bubble on map\\\"\\n        onerror=\\\"onerror=null\\\";\\n        src=\\\"gp_dataSetSearches['\").concat(gp_DOMPurify.sanitize(thisPOIC.collectionName), \"'].icon;\\\"/>\\n        </div>\");\n      const recActions = gp_constructRecordActionsDD(thisPOIC, obj.aData); // SECURITY: gp_constructRecordActionsDD returns a sanitized string\n\n      const removePOI = \"<i\\n        style=\\\"margin-top:-5px;margin-left:5px;margin-right:5px;\\\"\\n        class=\\\"fa fa-times removeRecord\\\"\\n        onclick=\\\"javascript:gp_removeMarkerTable('\".concat(uniqueIdSanitized, \"', '\").concat(gp_DOMPurify.sanitize(obj.oSettings.sTableId), \"');\\n        gp_removeMarkerMap('\").concat(uniqueIdSanitized, \"');\\n        updateChartAfterMarkerRemoval('\").concat(gp_DOMPurify.sanitize(obj.oSettings.sTableId), \"');\\n        return false;\\\"\\n        title=\\\"Remove from Map\\\"\\n        alt=\\\"Remove from Map\\\">\\n        </i>\");\n      return \"<div style=\\\"white-space: nowrap; overflow:hidden\\\">\".concat(uniqueIdSpan, \" \").concat(checkbox, \" &nbsp; \").concat(mapIcon, \" &nbsp; \").concat(recActions, \" &nbsp; \").concat(removePOI, \"</div>\");\n    }\n  }); // Used to display the # column when map pins are numbered\n\n  /* 12 */\n\n  tableCols.push({\n    sTitle: '#',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell notranslate',\n    gpName: 'rowNum'\n  });\n  /* 13 */\n\n  tableCols.push({\n    sTitle: gp_DOMPurify.sanitize(thisPOIC.columnLabels.titleLabel),\n    sClass: 'dataCell notranslate',\n    sType: 'html',\n    sWidth: '120px',\n    bUseRendered: false,\n    gpName: 'title',\n    fnRender: function fnRender(obj) {\n      var url = ''; //Add url prefix, typically for Communities if it is present\n\n      if (gp_orgSettings.urlPrefix) {\n        url = gp_orgSettings.urlPrefix + '/' + obj.aData[gp_ColumnInfo.recordId];\n      } else {\n        url = '/' + obj.aData[gp_ColumnInfo.recordId];\n      }\n\n      var returnHtml = thisPOIC.searchType === window.gpCsv ? \"<a style=\\\"cursor: not-allowed; opacity: 0.8; text-decoration: none; color: black;\\\" href=\\\"\".concat(url, \"\\\" target=\\\"_blank\\\" openConsoleTab=\\\"true\\\">\").concat(obj.aData[obj.iDataColumn], \"</a>\") : \"<a href=\\\"\".concat(url, \"\\\" target=\\\"_blank\\\" openConsoleTab=\\\"true\\\">\").concat(obj.aData[obj.iDataColumn], \"</a>\");\n      return gp_DOMPurify.sanitize(returnHtml);\n    }\n  });\n\n  if (thisPOIC.hasTitle2) {\n    /* 14 */\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(thisPOIC.columnLabels.title2Label),\n      sClass: 'dataCell notranslate',\n      sType: 'html',\n      sWidth: '120px',\n      bUseRendered: false,\n      gpName: 'title2',\n      fnRender: function fnRender(obj) {\n        let url = '';\n        let poiAccountId = '';\n        let returnHtml = \"<p>\".concat(obj.aData[obj.iDataColumn], \"</p>\");\n        thisPOIC.POIs.forEach(poi => {\n          if (poi.recordId === obj.aData[gp_ColumnInfo.recordId] && poi.sObject.accountid) {\n            poiAccountId = poi.sObject.accountid;\n          }\n        });\n\n        if (poiAccountId) {\n          //Add url prefix, typically for Communities if it is present\n          url = gp_orgSettings.urlPrefix ? \"\".concat(gp_orgSettings.urlPrefix, \"/\").concat(poiAccountId) : \"/\".concat(poiAccountId);\n          returnHtml = \"<a href=\\\"\".concat(url, \"\\\" target=\\\"_blank\\\" openConsoleTab=\\\"true\\\">\").concat(obj.aData[obj.iDataColumn], \" </a>\");\n        }\n\n        return gp_DOMPurify.sanitize(returnHtml);\n      }\n    });\n  } else {\n    /* 14 */\n    tableCols.push({\n      sTitle: 'Title 2',\n      bSearchable: false,\n      bSortable: false,\n      bVisible: false,\n      sWidth: '0px',\n      sClass: 'dataCell notranslate',\n      gpName: 'title2'\n    });\n  }\n\n  if (thisPOIC.displayFormattedAddress) {\n    /* 15 */\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(gp_translations.Address),\n      sClass: 'dataCell',\n      sType: 'string',\n      sWidth: '160px',\n      gpName: 'fulladdress'\n    });\n    /* 16 */\n\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(gp_translations.Street),\n      bSearchable: false,\n      bSortable: false,\n      bVisible: false,\n      sWidth: '0px',\n      sClass: 'dataCell notranslate',\n      gpName: 'street'\n    });\n    /* 17 */\n\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(gp_translations.City),\n      bSearchable: false,\n      bSortable: false,\n      bVisible: false,\n      sWidth: '0px',\n      sClass: 'dataCell notranslate',\n      gpName: 'city'\n    });\n    /* 18 */\n\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(gp_translations.State_Province),\n      bSearchable: false,\n      bSortable: false,\n      bVisible: false,\n      sWidth: '0px',\n      sClass: 'dataCell notranslate',\n      gpName: 'state'\n    });\n    /* 19 */\n\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(gp_translations.Postal_Code),\n      bSearchable: false,\n      bSortable: false,\n      bVisible: false,\n      sWidth: '0px',\n      sClass: 'dataCell notranslate',\n      gpName: 'postalCode'\n    });\n    /* 20 */\n\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(gp_translations.Country),\n      bSearchable: false,\n      bSortable: false,\n      bVisible: false,\n      sWidth: '0px',\n      sClass: 'dataCell notranslate',\n      gpName: 'country'\n    });\n    /* 21 */\n\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(gp_translations.Country + ' ISO'),\n      bSearchable: false,\n      bSortable: false,\n      bVisible: false,\n      sWidth: '0px',\n      sClass: 'dataCell notranslate',\n      gpName: 'countryISO'\n    });\n  } else {\n    /* 15 */\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(gp_translations.Address),\n      bSearchable: false,\n      bSortable: false,\n      bVisible: false,\n      sWidth: '0px',\n      sClass: 'dataCell',\n      gpName: 'fulladdress'\n    });\n    /* 16 */\n\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(thisPOIC.columnLabels.streetLabel),\n      sClass: 'dataCell notranslate',\n      sType: 'string',\n      sWidth: '100px',\n      gpName: 'street'\n    });\n    /* 17 */\n\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(thisPOIC.columnLabels.cityLabel),\n      sClass: 'dataCell notranslate',\n      sType: 'string',\n      gpName: 'city'\n    });\n    /* 18 */\n\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(thisPOIC.columnLabels.stateLabel),\n      sClass: 'dataCell notranslate',\n      sType: 'string',\n      gpName: 'state'\n    });\n    /* 19 */\n\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(thisPOIC.columnLabels.postalCodeLabel),\n      sClass: 'dataCell notranslate',\n      sType: 'string',\n      gpName: 'postalCode'\n    });\n    /* 20 */\n\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(thisPOIC.columnLabels.countryLabel),\n      sClass: 'dataCell notranslate',\n      sType: 'string',\n      gpName: 'country'\n    });\n    /* 21 */\n\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(gp_translations.Country + ' ISO'),\n      bSearchable: false,\n      bSortable: false,\n      bVisible: false,\n      sWidth: '0px',\n      sClass: 'dataCell notranslate',\n      gpName: 'countryISO'\n    });\n  } //Create dynamic columns based on additional fields selected in the dataset / in CSV file\n\n\n  if (thisPOIC.searchType === gpCsv) tableCols.push(...gp_getDataTableColumnsAddlCSV(thisPOIC));else if (thisPOIC.ds) tableCols.push(...gp_getDataTableColumnsAddlDataSet(thisPOIC)); // show the distance for all types of nearby searches\n\n  if (thisPOIC.searchType == 'nearbyRadial' || thisPOIC.searchType == 'nearbyShape') {\n    /* 32 */\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize('<span isolate>' + gp_translations.Distance + '</span> (<span isolate>' + thisPOIC.distanceUnitsLabel + '</span>)'),\n      sClass: 'dataCell',\n      sType: 'numeric',\n      gpName: 'distance'\n    });\n    /* 33 */\n\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize('<span isolate>' + gp_translations.Drive_Distance + '</span> (<span isolate>' + thisPOIC.distanceUnitsLabel) + '</span>) <i onclick=\"gp_calcDriveTimes(\\'' + gp_DOMPurify.sanitize(thisPOIC.collectionName) + '\\');event.stopPropagation();\" class=\"fa fa-refresh calculateDriveDistanceIcon\"></i>',\n      sClass: 'dataCell',\n      bVisible: false,\n      sType: 'gpNumeric',\n      gpName: 'distanceDrive'\n    });\n\n    if (gp_orgSettings.settings.datatableDriveTimeEnabled) {\n      /* 39 */\n      tableCols.push({\n        sTitle: '<span isolate>Drive Time</span> <span class=\"calculateDriveDistanceBox\"><i id=\"calcDriveTimeIcon' + gp_DOMPurify.sanitize(thisPOIC.collectionName) + '\" onclick=\"gp_calcDriveTimes(\\'' + gp_DOMPurify.sanitize(thisPOIC.collectionName) + '\\', true);event.stopPropagation();\" class=\"fa fa-refresh calculateDriveDistanceIcon\"></i></span>',\n        sClass: 'dataCell',\n        bSortable: true,\n        bVisible: true,\n        sType: 'gpValue',\n        gpName: 'timeDrive'\n      });\n    }\n  } else {\n    /* 32 */\n    tableCols.push({\n      sTitle: gp_DOMPurify.sanitize(gp_translations.Distance),\n      bSearchable: false,\n      bSortable: false,\n      bVisible: false,\n      sWidth: '0px',\n      sClass: 'dataCell',\n      gpName: 'distance'\n    });\n  }\n  /* 34 */\n\n\n  tableCols.push({\n    sTitle: gp_DOMPurify.sanitize(gp_translations.Geocode_Quality),\n    sClass: 'dataCell',\n    sType: 'string',\n    bUseRendered: false,\n    gpName: 'geocodeQuality',\n    fnRender: function fnRender(obj) {\n      return gp_renderGeocodeQuality(obj);\n    }\n  });\n  /* 35 */\n\n  tableCols.push({\n    sTitle: 'Info Content',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell',\n    gpName: 'infoContent'\n  });\n  /* 36 & 37 Color By Field Type Type and Color By Value*/\n\n  tableCols.push({\n    sTitle: 'Color by Field Type',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell notranslate',\n    gpName: 'colorByFieldType'\n  });\n  tableCols.push({\n    sTitle: 'Color by Value',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell notranslate',\n    gpName: 'colorByValue'\n  });\n  /* 38 */\n\n  tableCols.push({\n    sTitle: 'Record Type Id',\n    bSearchable: false,\n    bSortable: false,\n    bVisible: false,\n    sWidth: '0px',\n    sClass: 'dataCell',\n    gpName: 'recordTypeId'\n  }); //Create object that stores column name to column number, also create array that tracks the column number of additional fields that were hidden\n\n  var columnInfo = {};\n  var additionalHiddenFieldColNumbers = [];\n  var apiNameToColNumber = {};\n  var colNumToApiName = {};\n\n  for (var i = 0; i < tableCols.length; i++) {\n    columnInfo[tableCols[i].gpName] = i; //populate list of additional fields that are hidden\n\n    if (tableCols[i].isAdditionalHiddenField == true) {\n      additionalHiddenFieldColNumbers.push(i);\n    } //populate object that keeps track of API name to column number, also populate object that stores colNumToApiName\n\n\n    if (typeof tableCols[i].gpAPIname != 'undefined') {\n      apiNameToColNumber[tableCols[i].gpAPIname] = i;\n      colNumToApiName[i] = tableCols[i].gpAPIname;\n    }\n  } //Using jQuery data function attach the columnInfo object and list of additionalHiddenFieldColNumbers to the correct <table>\n\n\n  jQuery('#' + thisPOIC.collectionName).data('columnInfo', columnInfo);\n  jQuery('#' + thisPOIC.collectionName).data('additionalHiddenFieldColNumbers', additionalHiddenFieldColNumbers);\n  jQuery('#' + thisPOIC.collectionName).data('apiNameToColNumber', apiNameToColNumber);\n  jQuery('#' + thisPOIC.collectionName).data('colNumToApiName', colNumToApiName); // Define the sorting for the gpnumeric column (used for driving distance)\n\n  jQuery.fn.dataTableExt.oSort['gpNumeric-asc'] = function (a, b) {\n    var x = Number(a);\n    var y = Number(b);\n    if (isNaN(x) && isNaN(y)) return 0;\n    if (isNaN(x)) return 1;\n    if (isNaN(y)) return -1;\n    return x < y ? -1 : x > y ? 1 : 0;\n  };\n\n  jQuery.fn.dataTableExt.oSort['gpNumeric-desc'] = function (a, b) {\n    var x = Number(a);\n    var y = Number(b);\n    if (isNaN(x) && isNaN(y)) return 0;\n    if (isNaN(x)) return -1;\n    if (isNaN(y)) return 1;\n    return x < y ? 1 : x > y ? -1 : 0;\n  }; // define sorting for label-value object (used for drive time column)\n\n\n  jQuery.fn.dataTableExt.oSort['gpValue-desc'] = function (a, b) {\n    a = a.value || 0;\n    b = b.value || 0;\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  };\n\n  jQuery.fn.dataTableExt.oSort['gpValue-asc'] = function (a, b) {\n    a = a.value || 0;\n    b = b.value || 0;\n    if (a < b) return 1;\n    if (a > b) return -1;\n    return 0;\n  };\n\n  jQuery.fn.dataTableExt.oSort['label-desc'] = function (a, b) {\n    a = a.label.toLowerCase();\n    b = b.label.toLowerCase();\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  };\n\n  jQuery.fn.dataTableExt.oSort['label-asc'] = function (a, b) {\n    a = a.label.toLowerCase();\n    b = b.label.toLowerCase();\n    if (a < b) return 1;\n    if (a > b) return -1;\n    return 0;\n  };\n\n  jQuery.fn.dataTableExt.oSort['date-value-desc'] = function (a, b) {\n    a = a.value ? new Date(a.value).getTime() : 0;\n    b = b.value ? new Date(b.value).getTime() : 0;\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  };\n\n  jQuery.fn.dataTableExt.oSort['date-value-asc'] = function (a, b) {\n    a = a.value ? new Date(a.value).getTime() : 0;\n    b = b.value ? new Date(b.value).getTime() : 0;\n    if (a < b) return 1;\n    if (a > b) return -1;\n    return 0;\n  };\n\n  return tableCols;\n} // Called from gp_defineDataTableColumns to get additional fields in DS search\n\n\nfunction gp_getDataTableColumnsAddlDataSet(thisPOIC) {\n  const rv = [];\n  if (!thisPOIC || !thisPOIC.ds) return rv;\n  const ds = thisPOIC.ds;\n  var numberOfFieldsToDisplay = ds.numOfFieldsDisplayedInTable - 1;\n  let dsFieldsByName = {};\n\n  _.forEach(ds.fields, f => dsFieldsByName[f.field] = f);\n\n  for (var i = 0; i < thisPOIC.columnLabels.additionalFields.length; i++) {\n    var additionalField = thisPOIC.columnLabels.additionalFields[i];\n    var dsField = gp_isConvCurrAlias(additionalField.name) ? dsFieldsByName[gp_getCurrFieldFromAlias(additionalField.name)] : dsFieldsByName[additionalField.name]; // Set isVisible attribute as configured in DataSet edit, also track if col is additional hidden field\n\n    var isVisible = true;\n    var isAdditionalHiddenField = false;\n\n    if (dsField && dsField.inTable != undefined ? !dsField.inTable : i > numberOfFieldsToDisplay) {\n      isVisible = false;\n      isAdditionalHiddenField = true;\n    } //Create the type col\n\n\n    rv.push({\n      sTitle: 'Column ' + i + ' Type',\n      bSearchable: false,\n      bSortable: false,\n      bVisible: false,\n      sWidth: '0px',\n      sClass: 'dataCell notranslate',\n      gpName: 'col' + i + 'Type'\n    }); // construct full relationName path if applicable\n\n    var pathLabel = '';\n\n    if (dsField && dsField.pathLabel && dsField.pathLabel.length) {\n      pathLabel = dsField.pathLabel.join(' ');\n    }\n\n    var dataTableFieldOpts = {\n      sTitle: gp_DOMPurify.sanitize(additionalField.label),\n      sPathLabel: gp_DOMPurify.sanitize(pathLabel),\n      sClass: 'dataCell notranslate',\n      bUseRendered: false,\n      bVisible: isVisible,\n      isAdditionalHiddenField: isAdditionalHiddenField,\n      gpObjectApiName: gp_DOMPurify.sanitize(thisPOIC.ds.mapObjectSobjectName),\n      gpName: gp_DOMPurify.sanitize('col' + i + 'Value'),\n      gpAPIname: gp_DOMPurify.sanitize(additionalField.name),\n      gpFieldType: additionalField.datatype,\n      gpScale: additionalField.scale,\n      isUpdateable: additionalField.isUpdateable,\n      isCalculated: additionalField.isCalculated,\n      fnRender: function fnRender(obj) {\n        return gp_renderInDataTable(obj, thisPOIC);\n      }\n    };\n\n    if (additionalField.datatype === 'REFERENCE') {\n      dataTableFieldOpts.sType = 'label';\n      dataTableFieldOpts.bSortable = true;\n    } else if (additionalField.datatype === 'DATE' || additionalField.datatype === 'DATETIME') {\n      dataTableFieldOpts.sType = 'date-value';\n      dataTableFieldOpts.bSortable = true;\n    }\n\n    rv.push(dataTableFieldOpts);\n  }\n\n  return rv;\n} // Called from gp_defineDataTableColumns to get additional fields in CSV file\n\n\nfunction gp_getDataTableColumnsAddlCSV(thisPOIC) {\n  const rv = [];\n  if (!thisPOIC || !thisPOIC.columnLabels || !thisPOIC.columnLabels.additionalFields || !thisPOIC.columnLabels.additionalFields.length) return rv;\n\n  for (var i = 0; i < thisPOIC.columnLabels.additionalFields.length; i++) {\n    var additionalField = thisPOIC.columnLabels.additionalFields[i]; // CSV fields are always visible\n\n    var isVisible = true;\n    var isAdditionalHiddenField = false; //Create the type col\n\n    rv.push({\n      sTitle: 'Column ' + i + ' Type',\n      bSearchable: false,\n      bSortable: false,\n      bVisible: false,\n      sWidth: '0px',\n      sClass: 'dataCell notranslate',\n      gpName: 'col' + i + 'Type'\n    }); // no pathLabel for CSV fields\n\n    var pathLabel = '';\n    var dataTableFieldOpts = {\n      sTitle: gp_DOMPurify.sanitize(additionalField.label),\n      sPathLabel: gp_DOMPurify.sanitize(pathLabel),\n      sClass: 'dataCell notranslate',\n      bUseRendered: false,\n      bVisible: isVisible,\n      isAdditionalHiddenField: isAdditionalHiddenField,\n      gpObjectApiName: gpCsv,\n      gpName: gp_DOMPurify.sanitize('col' + i + 'Value'),\n      gpAPIname: gp_DOMPurify.sanitize(additionalField.name),\n      gpFieldType: additionalField.datatype,\n      gpScale: additionalField.scale,\n      isUpdateable: additionalField.isUpdateable,\n      isCalculated: additionalField.isCalculated,\n      fnRender: function fnRender(obj) {\n        return gp_renderInDataTable(obj, thisPOIC);\n      }\n    };\n\n    if (additionalField.datatype === 'REFERENCE') {\n      dataTableFieldOpts.sType = 'label';\n      dataTableFieldOpts.bSortable = true;\n    } else if (additionalField.datatype === 'DATE' || additionalField.datatype === 'DATETIME') {\n      dataTableFieldOpts.sType = 'date-value';\n      dataTableFieldOpts.bSortable = true;\n    }\n\n    rv.push(dataTableFieldOpts);\n  }\n\n  return rv;\n} //Define a Data Table Row array\n\n\nfunction gp_defineDataTableRow(thisPOIC, thisPOI) {\n  var tableRow = new Array(); //tableRow.DT_RowId = thisPOI.uniqueId; // Set the Row Id\n\n  /* 0 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.uniqueId)); //Unique Id\n\n  /* 1 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.recordId)); //Record Id\n\n  /* 2 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.mapIconURL)); //Map Icon for Data Table\n\n  /* 3 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.mapIconURL)); //Map Icon\n\n  /* 4 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.mapIconColor)); //Map Icon Color\n\n  /* 5 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.mapIconWidth + 'x' + thisPOI.mapIconHeight)); //Map Icon Size\n\n  /* 6 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.lat)); //Latitude\n\n  /* 7 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.lng)); //Longitude\n\n  /* 8 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.latDisplay)); //Latitude (display)\n\n  /* 9 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.lngDisplay)); //Longitude (display)\n\n  /* 9 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.usesCustomerGeocode)); //Uses Customer Geocode\n\n  /* 11 */\n\n  tableRow.push('actions'); //Actions\n\n  /* 12 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.mapIconText));\n  /* 13 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.title));\n\n  if (thisPOIC.hasTitle2) {\n    /* 14 */\n    tableRow.push(gp_escapeHtml(thisPOI.title2));\n  } else {\n    /* 14 */\n    tableRow.push('');\n  } // Do not escape the formatted address, we build it prior\n\n  /* 15 */\n\n\n  tableRow.push(gp_DOMPurify.sanitize(thisPOI.formattedAddr));\n  /* 16 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.street));\n  /* 17 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.city));\n  /* 18 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.state));\n  /* 19 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.postalCode));\n  /* 20 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.country));\n  /* 21 */\n\n  tableRow.push(gp_escapeHtml(thisPOI.countryISO)); //Create dynamic columns based on additional fields selected in the dataset\n\n  if (thisPOIC.ds) {\n    for (var i = 0; i < thisPOI.additionalFields.length; i++) {\n      var additionalField = thisPOI.additionalFields[i];\n      var typeValueSanitized = gp_escapeHtml(additionalField.datatype);\n      var dataValueSanitized = gp_escapeHtml(additionalField.value); //Make values empty string if undefined\n\n      if (!typeValueSanitized) typeValueSanitized = '';\n\n      if (typeof dataValueSanitized == 'undefined' || dataValueSanitized == null) {\n        dataValueSanitized = '';\n      }\n\n      tableRow.push(typeValueSanitized);\n      var label;\n\n      if (typeValueSanitized === 'REFERENCE') {\n        tableRow.push({\n          label: gp_escapeHtml(additionalField.referenceName) || '',\n          value: dataValueSanitized\n        });\n      } else if (typeValueSanitized === 'DATE') {\n        //Use moment.js to format the date\n        label = dataValueSanitized ? moment(dataValueSanitized).format('l') : '';\n        tableRow.push({\n          label: gp_escapeHtml(label),\n          value: dataValueSanitized\n        });\n      } else if (typeValueSanitized === 'DATETIME') {\n        //Use moment.js to format the date\n        var momentDate = moment(dataValueSanitized); //Use moment.js to format the date\n\n        label = dataValueSanitized ? momentDate.tz(gp_userSettings.userInfo.timeZone).format('l') + ' ' + momentDate.tz(gp_userSettings.userInfo.timeZone).format('LT') : '';\n        tableRow.push({\n          label: label,\n          value: dataValueSanitized\n        });\n      } else if (typeValueSanitized === 'CURRENCY' || typeValueSanitized === 'DOUBLE' || typeValueSanitized === 'INTEGER') {\n        tableRow.push(dataValueSanitized);\n      } else {\n        tableRow.push(dataValueSanitized);\n      }\n    }\n  }\n\n  if (thisPOIC.searchType == 'nearbyRadial' || thisPOIC.searchType == 'nearbyShape') {\n    /* 32 */\n    tableRow.push(gp_escapeHtml(thisPOI.distanceFromCenter));\n    /* 33 */\n\n    tableRow.push('-');\n    /* distanceDrive */\n\n    if (gp_orgSettings.settings.datatableDriveTimeEnabled) {\n      /* 39 */\n      tableRow.push('-');\n      /* timeDrive */\n    }\n  } else {\n    /* 32 */\n    tableRow.push('');\n  }\n  /* 34 */\n\n\n  tableRow.push(gp_escapeHtml(thisPOI.geocodeQuality));\n  /* 35 */\n\n  tableRow.push(thisPOI.baseInfoContentHTMLSanitized);\n  /* 36 */\n\n  if (thisPOI.colorByFieldType) {\n    tableRow.push(gp_escapeHtml(thisPOI.colorByFieldType));\n  } else {\n    tableRow.push('');\n  }\n  /* 37 */\n\n\n  if (thisPOI.colorByFieldValue) {\n    tableRow.push(gp_escapeHtml(thisPOI.colorByFieldValue));\n  } else {\n    tableRow.push('');\n  }\n  /* 38 */\n\n\n  if (thisPOI.recordTypeId) {\n    tableRow.push(gp_escapeHtml(thisPOI.recordTypeId));\n  } else {\n    tableRow.push('');\n  }\n\n  return tableRow;\n} // Returns formatted value based on data type\n// Is Passed in \"obj\" from the fnRender function at http://www.datatables.net/usage/columns\n\n\nfunction gp_renderInDataTable(obj, thisPOIC) {\n  //Attempt to find the scale value\n  var scale;\n\n  try {\n    scale = obj.oSettings.aoColumns[obj.iDataColumn].gpScale;\n  } catch (e) {\n    console.log(e);\n  }\n\n  var rowIndex = obj.aData[gp_ColumnInfo.rowNum] - 1;\n  var thisPOI = thisPOIC.POIs[rowIndex];\n  var referenceName = '';\n  var additionalFieldsObj = null;\n\n  if (thisPOI && thisPOI.additionalFields && obj.aData[obj.iDataColumn - 1] === 'REFERENCE') {\n    additionalFieldsObj = _.find(thisPOI.additionalFields, function (info) {\n      return info.name === obj.oSettings.aoColumns[obj.iDataColumn].gpAPIname;\n    });\n    referenceName = additionalFieldsObj.referenceName || '';\n  } //(fieldType,fieldValue,recordId,recordName,decimalPrecision)\n  // SECURITY: gp_formatOutputField returns a sanitized string\n\n\n  return gp_formatOutputField({\n    sfdcRecordId: obj.aData[gp_ColumnInfo.recordId],\n    fieldType: obj.aData[obj.iDataColumn - 1],\n    fieldValue: obj.aData[obj.iDataColumn],\n    recordName: obj.aData[gp_ColumnInfo.title],\n    scale: scale,\n    apiName: obj.oSettings.aoColumns[obj.iDataColumn].gpAPIname,\n    objectApiName: obj.oSettings.aoColumns[obj.iDataColumn].gpObjectApiName,\n    isUpdateable: obj.oSettings.aoColumns[obj.iDataColumn].isUpdateable,\n    isCalculated: obj.oSettings.aoColumns[obj.iDataColumn].isCalculated,\n    referenceName: referenceName,\n    isInfoWindow: false,\n    tableData: thisPOI && thisPOI.tableData ? thisPOI.tableData : null,\n    sObject: thisPOI ? thisPOI.sObject : null,\n    collectionName: thisPOIC.collectionName,\n    additionalFieldsObj: additionalFieldsObj,\n    thisPOI: thisPOI,\n    thisPOIC: thisPOIC,\n    inDataTable: true\n  });\n} // SECURITY: This returns a sanitized string\n\n\nfunction gp_formatOutputField(opts) {\n  //Special handling for shape fields\n  if (opts.fieldValue && opts.fieldValue.value && opts.fieldType == 'REFERENCE' && opts.fieldValue.value.indexOf(gp_shapeObjectPrefix) == 0 && mapProvider == 'Google') {\n    return '<a href=\"#\" onclick=\"gp_goToShapeField(\\'' + gp_DOMPurify.sanitize(opts.sfdcRecordId + \"','\" + opts.fieldValue.value) + '\\'); return false;\">View Shape</a>';\n  }\n\n  var sReturn = ''; // flag that indicates if the resulting string will be sent through\n  // to gp_DOMPurify.sanitize or not. By default we want sanitization.\n\n  opts.skipSanitize = false;\n\n  switch (opts.fieldType) {\n    case 'PERCENT':\n    case 'DOUBLE':\n    case 'INTEGER':\n      if (typeof opts.fieldValue != 'number' && (opts.fieldValue == null || typeof opts.fieldValue == 'undefined' || opts.fieldValue === '')) {\n        sReturn = '';\n      } else {\n        var decimalPlaces = opts.scale;\n\n        if (typeof decimalPlaces == 'undefined' || decimalPlaces == null || decimalPlaces == '') {\n          sReturn = angular.injector(['ng']).get('numberFilter')(opts.fieldValue);\n        } else {\n          sReturn = angular.injector(['ng']).get('numberFilter')(opts.fieldValue, decimalPlaces);\n        }\n      }\n\n      sReturn = gp_DOMPurify.sanitize(sReturn);\n      break;\n\n    case 'CURRENCY_CONVERTED':\n      if (opts.fieldValue == null || typeof opts.fieldValue == 'undefined' || opts.fieldValue === '') {\n        sReturn = '';\n      } else {\n        let currIsoCode = gp_userSettings.userInfo.userCurrency.isoCode;\n        let decimalPlaces = gp_orgSettings.currencyDecimalPlaces[currIsoCode];\n        if (typeof decimalPlaces == 'undefined' || decimalPlaces == null) decimalPlaces = 2;\n        sReturn = currIsoCode + ' ' + angular.injector(['ng']).get('numberFilter')(opts.fieldValue, decimalPlaces);\n        opts.fieldValue = Number(opts.fieldValue);\n      }\n\n      sReturn = gp_DOMPurify.sanitize(sReturn);\n      break;\n\n    case 'CURRENCY':\n      if (opts.fieldValue == null || typeof opts.fieldValue == 'undefined' || opts.fieldValue === '') {\n        sReturn = '';\n      } else if (gp_orgSettings.multiCurrency) {\n        let currIsoCode = opts.currencyIsoCode;\n        if (!currIsoCode) currIsoCode = opts.sObject && opts.sObject.currencyisocode ? opts.sObject.currencyisocode : '';\n        let decimalPlaces = gp_orgSettings.currencyDecimalPlaces[currIsoCode];\n        if (typeof decimalPlaces == 'undefined' || decimalPlaces == null) decimalPlaces = 2;\n        sReturn = currIsoCode + ' ' + angular.injector(['ng']).get('numberFilter')(opts.fieldValue, decimalPlaces);\n        opts.fieldValue = Number(opts.fieldValue);\n      } else {\n        sReturn = angular.injector(['ng']).get('currencyFilter')(opts.fieldValue, gp_userSettings.userInfo.userCurrency.symbol, opts.scale);\n        opts.fieldValue = Number(opts.fieldValue);\n      }\n\n      sReturn = gp_DOMPurify.sanitize(sReturn);\n      break;\n\n    case 'URL':\n      if (opts.fieldValue) {\n        sReturn = opts.fieldValue;\n\n        if (opts.fieldValue.indexOf('http') != 0) {\n          sReturn = 'http://' + sReturn;\n        }\n\n        sReturn = \"<a href=\\\"\".concat(sReturn, \"\\\" target=\\\"_blank\\\">\").concat(gp_escapeHtml(opts.fieldValue), \"</a>\");\n      }\n\n      sReturn = gp_DOMPurify.sanitize(sReturn);\n      break;\n\n    case 'EMAIL':\n      if (opts.fieldValue) {\n        sReturn = \"<a href=\\\"mailto:\".concat(opts.fieldValue, \"\\\"> \").concat(gp_escapeHtml(opts.fieldValue), \"</a>\");\n      }\n\n      sReturn = gp_DOMPurify.sanitize(sReturn);\n      break;\n\n    case 'BOOLEAN':\n      if (opts.fieldValue || opts.fieldValue === false) {\n        opts.fieldValue = String(opts.fieldValue);\n\n        if (opts.isLabel) {\n          if (opts.fieldValue === 'true') {\n            sReturn = 'âœ“';\n          }\n        } else {\n          if (opts.fieldValue === 'true') {\n            sReturn = \"<img src='\" + gpImg.checkbox_checked + \"' alt='true' />\";\n          } else {\n            sReturn = \"<img src='\" + gpImg.checkbox_unchecked + \"' alt='false' />\";\n          }\n        }\n      }\n\n      sReturn = gp_DOMPurify.sanitize(sReturn);\n      break;\n\n    case 'PHONE':\n      // SECURITY: because the html string includes javascript, we will sanitize variables as we construct the string\n      var currValSanitized = gp_DOMPurify.sanitize(opts.fieldValue);\n\n      if (currValSanitized) {\n        sReturn = \"<span>\".concat(gp_escapeHtml(currValSanitized), \"</span>\");\n\n        if (typeof gp_objNameByKeyPref != 'undefined') {\n          var theId = opts.sfdcRecordId;\n          var prefix = theId ? theId.substring(0, 3) : null;\n\n          if (prefix && typeof gp_objNameByKeyPref[prefix] != 'undefined') {\n            // here is the only place we want to skip the sanitization of the\n            // html string - as DOMPurify strips the javascript functions from the\n            // href and we need to call these external functions for cti to work.\n            if (typeof Sfdc != 'undefined') {\n              if (typeof Sfdc.cti != 'undefined') {\n                opts.skipSanitize = true;\n                sReturn = '<a href=\"javascript:sendCTIMessage(\\'/CLICK_TO_DIAL?DN=' + gp_DOMPurify.sanitize(encodeURIComponent(currValSanitized) + '&ID=' + opts.sfdcRecordId + '&ENTITY_NAME=' + gp_objNameByKeyPref[prefix] + '&OBJECT_NAME=' + encodeURIComponent(opts.recordName)) + '\\')\">' + gp_escapeHtml(currValSanitized) + '<img width=\"16\" height=\"10\" title=\"Click to dial\" alt=\"Click to dial\" src=\"/img/btn_dial_inline.gif\">' + '</a>';\n              } else if (typeof Sfdc.lightningClickToDial !== 'undefined' && typeof Sfdc.lightningClickToDial.dial !== 'undefined' && gp_isCtiEnabled()) {\n                opts.skipSanitize = true;\n                sReturn = '<a href=\"javascript:Sfdc.lightningClickToDial.dial(\\'' + currValSanitized + \"', '\" + gp_DOMPurify.sanitize(opts.sfdcRecordId) + '\\')\">' + gp_escapeHtml(currValSanitized) + '<img width=\"16\" height=\"10\" title=\"Click to dial\" alt=\"Click to dial\" src=\"/img/btn_dial_inline.gif\">' + '</a>';\n              }\n            }\n          }\n        }\n      }\n\n      break;\n\n    case 'DATE':\n      if (opts.fieldValue && opts.fieldValue.value) {\n        opts.moment = moment(opts.fieldValue.value);\n        sReturn = gp_DOMPurify.sanitize(opts.fieldValue.label ? opts.fieldValue.label : opts.moment.format('l'));\n      }\n\n      break;\n\n    case 'DATETIME':\n      if (opts.fieldValue && opts.fieldValue.value) {\n        opts.moment = moment(opts.fieldValue.value);\n        sReturn = gp_DOMPurify.sanitize(opts.fieldValue.label ? opts.fieldValue.label : opts.moment.format('l') + ' ' + opts.moment.format('LT'));\n      }\n\n      break;\n\n    case 'REFERENCE':\n      if (opts.fieldValue && opts.fieldValue.value) {\n        sReturn = gp_DOMPurify.sanitize(\"<a href=\\\"../\".concat(opts.fieldValue.value, \"\\\" target=\\\"_blank\\\">\").concat(gp_escapeHtml(opts.referenceName), \"</a>\"));\n      }\n\n      break;\n\n    case 'RICHTEXT':\n      sReturn = gp_DOMPurify.sanitize(unescapeHTML(opts.fieldValue));\n      break;\n\n    default:\n      var sReturn = '';\n\n      if (opts.isCalculated) {\n        //Formula fields\n        var val = opts.fieldValue ? opts.fieldValue : '';\n\n        if (opts.inDataTable) {\n          val = jQuery('<span>').html(opts.fieldValue).text();\n        }\n\n        var xssMatches = ['<script>', 'javascript', 'ipt:', 'FSCommand', 'onAbort', 'onActivate', 'onAfterPrint', 'onAfterUpdate', 'onBeforeActivate', 'onBeforeCopy', 'onBeforeCut', 'onBeforeDeactivate', 'onBeforeEditFocus', 'onBeforePaste', 'onBeforePrint', 'onBeforeUnload', 'onBeforeUpdate', 'onBegin', 'onBlur', 'onBounce', 'onCellChange', 'onChange', 'onClick', 'onContextMenu', 'onControlSelect', 'onCopy', 'onCut', 'onDataAvailable', 'onDataSetChanged', 'onDataSetComplete', 'onDblClick', 'onDeactivate', 'onDrag', 'onDragEnd', 'onDragLeave', 'onDragEnter', 'onDragOver', 'onDragDrop', 'onDragStart', 'onDrop', 'onEnd', 'onError', 'onErrorUpdate', 'onFilterChange', 'onFinish', 'onFocus', 'onFocusIn', 'onFocusOut', 'onHashChange', 'onHelp', 'onInput', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onLayoutComplete', 'onLoad', 'onLoseCapture', 'onMediaComplete', 'onMediaError', 'onMessage', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp', 'onMouseWheel', 'onMove', 'onMoveEnd', 'onMoveStart', 'onOffline', 'onOnline', 'onOutOfSync', 'onPaste', 'onPause', 'onPopState', 'onProgress', 'onPropertyChange', 'onReadyStateChange', 'onRedo', 'onRepeat', 'onReset', 'onResize', 'onResizeEnd', 'onResizeStart', 'onResume', 'onReverse', 'onRowsEnter', 'onRowExit', 'onRowDelete', 'onRowInserted', 'onScroll', 'onSeek', 'onSelect', 'onSelectionChange', 'onSelectStart', 'onStart', 'onStop', 'onStorage', 'onSyncRestored', 'onSubmit', 'onTimeError', 'onTrackChange', 'onUndo', 'onUnload', 'onURLFlip', 'seekSegmentTime']; //If &lt; //Salesforce already escaped, do nothing.\n\n        if (val.indexOf('&lt;') > -1) {//Salesforce already escaped, do nothing.\n        } else if (val.indexOf('<a') > -1 || val.indexOf('<img') > -1) {\n          //There are <a or <img tags. Allow, but look for malicious scripts and escape\n          //Check for potential script matches\n          for (var i = 0; i < xssMatches.length; i++) {\n            if (val.toLowerCase().indexOf(xssMatches[i].toLowerCase()) > -1) {\n              val = gp_escapeHtml(val);\n              break;\n            }\n          }\n        } else {\n          //escape it all others\n          val = gp_escapeHtml(val);\n        }\n\n        sReturn = val;\n      } else {\n        if (opts.inDataTable || opts.isLabel) {\n          // Fields in datatable are already escaped, label fields don't need to be escaped\n          sReturn = null == opts.fieldValue ? '' : opts.fieldValue;\n\n          if (opts.fieldType == 'TEXTAREA' && opts.fieldValue.indexOf('&amp;lt;') > -1) {\n            sReturn = null == opts.fieldValue ? '' : jQuery('<span>').html(opts.fieldValue).text();\n          }\n        } else if (opts.fieldType == 'TEXTAREA' && opts.fieldValue.indexOf('&lt;') > -1) {\n          //Attempt to detect already escaped rich text field\n          //Already escaped, just return value\n          sReturn = null == opts.fieldValue ? '' : gp_escapeHtml(opts.fieldValue);\n        } else {\n          sReturn = null == opts.fieldValue ? '' : gp_escapeHtml(opts.fieldValue); //Escape all other fields\n        }\n      }\n\n      break;\n  }\n\n  if (null == sReturn || typeof sReturn == 'undefined') {\n    console.log('sReturn null or undef: opts = { fieldType: ' + opts.fieldType + ', fieldValue: ' + opts.fieldValue + ', scale: ' + opts.scale + ' }');\n    sReturn = '';\n  } // sReturn is already sanitized\n\n\n  opts.html = sReturn;\n  return gp_orgSettings.settings.inlineEditEnabled ? gp_inlineEdit.buildEditableHtml(opts) : opts.html;\n} // SECURITY: returns sanitized html\n//Returns formatted value for the Geocode Quality column\n//Is Passed in \"obj\" from the fnRender function at http://www.datatables.net/usage/columns\n\n\nfunction gp_renderGeocodeQuality(obj) {\n  var theValue = obj.aData[obj.iDataColumn] || 'CUSTOM';\n  var poorGCImage = '<img src=\"' + gpImg.error12 + '\" alt=\"Poor Geocode Quality\" />';\n  var medGCImage = '<img src=\"' + gpImg.warning12 + '\" alt=\"Medium Geocode Quality\" />';\n  var goodGCImage = '<img src=\"' + gpImg.confirm12 + '\" alt=\"High Geocode Quality\" />';\n  var qual = gp_getGeocodeQualityCategory(theValue);\n  return gp_DOMPurify.sanitize((qual == 'high' ? goodGCImage : qual == 'medium' ? medGCImage : poorGCImage) + ' ' + theValue);\n} // Should match the definitions in MapObject\n\n\nfunction gp_getGeocodeQualityCategory(quality) {\n  if (!quality) return '';\n  const highQualityCodes = ['rooftop', 'custom', 'address', 'street'];\n  const mediumQualityCodes = ['estimated', 'range_interpolated', 'nearaddress', 'block'];\n  const lowQualityCodes = ['postal_code', 'country', 'geometric_center', 'approximate', 'extendedzip', 'zip', 'neighborhood', 'city', 'county', 'state', 'unknown'];\n  var q = quality.toLowerCase();\n\n  if (highQualityCodes.includes(q)) {\n    return 'high';\n  }\n\n  if (mediumQualityCodes.includes(q)) {\n    return 'medium';\n  }\n\n  if (lowQualityCodes.includes(q)) {\n    return 'low';\n  }\n\n  return '';\n} // Remove Marker from a Table\n\n\nfunction gp_removeMarkerTable(markerID, tableId) {\n  // Find and remove the data table row\n  const dataTable = jQuery('#' + tableId).dataTable(); // we might not have a datatable, checking settings here\n  // equates to checking if we have a datatable\n\n  if (dataTable.fnSettings()) {\n    const aoData = dataTable.fnGetData();\n    const gp_ColumnInfo = dataTable.data('columnInfo');\n\n    for (let i = 0, iLen = aoData.length; i < iLen; i++) {\n      if (aoData[i][gp_ColumnInfo.uniqueId] === markerID) {\n        dataTable.fnDeleteRow(i);\n        break;\n      }\n    }\n  } //Remove any related shape fields on the map\n\n\n  for (const key in polygonObjects) {\n    var shape = polygonObjects[key];\n\n    if (shape.gpProperties.gpPoiId && shape.gpProperties.gpPoiId == markerID) {\n      if (shape.mapLabel) shape.mapLabel.setMap(null);\n      if (shape.bufferPolygon) shape.bufferPolygon.setMap(null);\n      shape.setMap(null);\n      delete polygonObjects[key];\n    }\n  } //Recalculate the number of records in shapes\n\n\n  try {\n    calcRecordsInShapes();\n  } catch (e) {} //function doesn't exist for MQ\n  //Decrement the record count in the data table tab\n\n\n  var $countBubble = jQuery('#countBubble-' + tableId);\n  var newCount = parseInt($countBubble.text()) - 1;\n  $countBubble.text(newCount); //Decrement number in layers list\n\n  gp_dataSetSearches[tableId].numOfRecords--;\n  if (mapProvider == 'Google') angular.element('#ngApp').scope().$broadcast('layersChanged', {\n    doApply: true\n  }); //Remove the item from the legend\n\n  var mapLegendService = angular.element('.legendController').injector().get('mapLegendService');\n  mapLegendService.remove(markerID);\n} //Select all records in a datatable\n// As of release 21, selectAll checkbox behaves more like gMail:\n// - setting selectAll selects all records on visible page, brings up 'helper' header row\n// - when changing page, if all checkboxes on new page are selected, selectAll appears checked\n// - clearing selectAll check deselects visible page records, dismisses helper row\n// - selecting all records individually, or clearing an individual record when all are selected,\n//   does not change the state of selectAll.\n// - helper row displays number of selected records, includes 'Select All' link which selects entire search result\n// - when entire search result is selected, helper link displays 'Clear Selection' and does that if clicked.\n\n\nfunction gp_toggleAllInDataTable(collectionName, entireResult) {\n  geopointeAjaxStart('#dataTableDIV', 'Setting record selection...', 40); // setTimeout just to let the spinner render before we get busy\n\n  setTimeout(function () {\n    var aoData = jQuery('#' + collectionName).dataTable().fnGetData();\n    var aiDisplay = jQuery('#' + collectionName).dataTable().fnSettings().aiDisplay;\n    var gp_ColumnInfo = jQuery('#' + collectionName).data('columnInfo');\n    var helperRow = jQuery('#selectAllHelper' + collectionName); //Get selectAllCheckBox value\n\n    var selectAll = jQuery('#toggleAllInDataTable' + collectionName).is(':checked');\n    var pageSize = jQuery('#' + collectionName + '_length select').val() * 1;\n    if (pageSize < 0) pageSize = aiDisplay.length;\n    var visiblePage = jQuery('#' + collectionName + '_paginate .paginate_active').text() - 1;\n    var selectSize = entireResult ? aiDisplay.length : pageSize || 25;\n    var selectStart = entireResult ? 0 : selectSize * visiblePage;\n    var selectEnd = entireResult ? selectSize : selectStart + selectSize;\n    var totalSelected = 0;\n\n    if (entireResult) {\n      if (gp_dataSetSearches[collectionName].selectCount === aiDisplay.length) {\n        // everything is selected, and we've chosen to deselect\n        selectAll = false;\n      } else {\n        // cover the situation where 'Select All' is clicked after selecting\n        // a different page, where the top checkbox may NOT be checked.\n        selectAll = true;\n      }\n\n      jQuery('#toggleAllInDataTable' + collectionName).prop('checked', selectAll);\n    }\n\n    for (var i = 0; i < aiDisplay.length; i++) {\n      var rowNum = aiDisplay[i];\n      var row = aoData[rowNum];\n      var poiId = row[gp_ColumnInfo.uniqueId];\n\n      if (selectAll == true && i >= selectStart && i < selectEnd && (typeof gp_selectedRecords[poiId] == 'undefined' || gp_selectedRecords[poiId] == false)) {\n        gp_toggleRecordSelection(poiId);\n      } else if (selectAll == false && i >= selectStart && i < selectEnd && gp_selectedRecords[poiId] == true) {\n        gp_toggleRecordSelection(poiId);\n      }\n\n      if (gp_selectedRecords[poiId]) {\n        totalSelected++;\n      }\n    }\n\n    gp_dataSetSearches[collectionName].selectCount = totalSelected;\n    geopointeAjaxEnd();\n\n    if (selectAll) {\n      helperRow.find('th:first .displaySelectCount').html(gp_DOMPurify.sanitize('Selected ' + totalSelected + ' of ' + aiDisplay.length + ' records. '));\n\n      if (totalSelected === aiDisplay.length) {\n        helperRow.find('a').text('Clear Selection');\n      } else {\n        helperRow.find('a').text('Select All');\n      }\n\n      helperRow.show();\n    } else {\n      helperRow.hide();\n    }\n  }, 0);\n} //Initialize the Data Table\n\n\nfunction gp_initDataTable(thisPOIC, tableCols, tableData) {\n  // Create the Data Table\n  jQuery('#' + thisPOIC.collectionName).dataTable({\n    bPaginate: true,\n    sPaginationType: 'full_numbers',\n    bLengthChange: true,\n    aLengthMenu: [[5, 10, 25, 50, 100, 250, 500, -1], [5, 10, 25, 50, 100, 250, 500, gp_translations.All]],\n    iDisplayLength: 25,\n    bProcessing: false,\n    bDeferRender: true,\n    aaSorting: [],\n    bSortClasses: false,\n    asStripClasses: ['dataRow odd', 'dataRow even'],\n    // add classes to alternating rows\n    bJQueryUI: false,\n    sDom: '<\"gp_tablecontrols\"pfl><\"dataTableScrollWrapper\"rt>',\n    // inject table components into the DOM\n    aaData: tableData,\n    // the data\n    bInfo: false,\n    aoColumns: tableCols,\n    // the columns\n    bAutoWidth: false,\n    fnInfoCallback: function fnInfoCallback(oSettings, iStart, iEnd, iMax, iTotal, sPre) {\n      return '<b>' + gp_DOMPurify.sanitize(sPre) + '</b>';\n    },\n    oLanguage: gp_dataTableTranslations\n  }); //Add a select all checkbox, timeout becuase creation of table is delay and we need to add checkbox after table has been rendered\n\n  setTimeout(function () {\n    // Sanitize\n    collectionNameSanitized = gp_DOMPurify.sanitize(thisPOIC.collectionName);\n    gp_setMaxDataTableWidth();\n    var colInfo = jQuery('#' + thisPOIC.collectionName).data('columnInfo');\n    var hdrRowInstance = jQuery('#' + thisPOIC.collectionName).find('tr.headerRow');\n    var pageSize = jQuery('#' + thisPOIC.collectionName + '_length select').val();\n    hdrRowInstance.find('th:first').prepend('<input type=\"checkbox\" id=\"toggleAllInDataTable' + collectionNameSanitized + '\" onclick=\"gp_toggleAllInDataTable(\\'' + collectionNameSanitized + '\\');\"/>&nbsp;&nbsp;');\n    hdrRowInstance.after('<tr id=\"selectAllHelper' + collectionNameSanitized + '\" role=\"row\" style=\"line-height:2.5em;display:none\">' + '<th colspan=\"' + hdrRowInstance[0].cells.length + '\" style=\"padding-left:2em;text-transform:unset\"><span class=\"displaySelectCount\">Select records.</span>' + '<a href=\"#\" onclick=\"gp_toggleAllInDataTable(\\'' + collectionNameSanitized + '\\', true);event.preventDefault();\">Select All</a></th></tr>');\n  }, 1); //Add a chart button to the table control pane\n\n  jQuery('#' + thisPOIC.collectionName + '_wrapper .gp_tablecontrols').append('<div class=\"gpButton gpButtonBasicSmall showChartBtn\" onclick=\"showChartPane(\\'' + gp_DOMPurify.sanitize(thisPOIC.collectionName) + '\\');\">' + '<img style=\"height: 17px !important; width: 17px !important;\" src=\"' + gp_DOMPurify.sanitize(chartIconURL) + '\"/></div>'); //Init the charting controls\n\n  buildChartControls(thisPOIC);\n  /* Fix up the table with Salesforce CSS that cannot be applied through the data tables plugin */\n  // header row\n\n  var hdrRow = jQuery('#' + thisPOIC.collectionName + ' thead tr');\n  hdrRow.removeClass('dataRow');\n  hdrRow.addClass('headerRow'); // fixup field labels with complete relationship path where applicable\n\n  if (thisPOIC.ds) {\n    // ignore idArray layers, which don't have this\n    setTimeout(function () {\n      for (var fx = 0; fx < thisPOIC.ds.fields.length; fx++) {\n        var fd = thisPOIC.ds.fields[fx];\n\n        if (fd.pathLabel && fd.pathLabel.length) {\n          var pathText = fd.pathLabel.join(' ');\n          jQuery('th.dataCell:nth-of-type(' + (fx + 1) + ')').filter(function () {\n            return jQuery(this).text() === fd.label;\n          }).text(gp_DOMPurify.sanitize(pathText + ' (' + fd.label + ')'));\n        }\n      }\n    }, 1);\n  } //\"click\" that data set tab for the current search\n\n\n  jQuery('#gp_dataTableTabs ul li.dataSetResultTableTab:last a').click(); // Add properties to the table\n\n  var oSettings = jQuery('#' + thisPOIC.collectionName).dataTable().fnSettings();\n  oSettings.gp_collectionName = thisPOIC.collectionName;\n  oSettings.gp_dataSetName = thisPOIC.dataSetName;\n  oSettings.gp_sfdcObject = thisPOIC.sfdcObject;\n\n  if (thisPOIC.searchType === gpCsv) {\n    var col;\n\n    if (thisPOIC.ds && thisPOIC.ds.markerMetaData && thisPOIC.ds.markerMetaData.colorByField && thisPOIC.ds.markerMetaData.colorByField.field) {\n      col = jQuery('#' + thisPOIC.collectionName).data('columnInfo')[thisPOIC.ds.markerMetaData.colorByField.field];\n    }\n\n    if (!col) col = jQuery('#' + thisPOIC.collectionName).data('columnInfo')['title'];\n    jQuery('#' + thisPOIC.collectionName).dataTable().fnSort([[col, 'asc']]);\n  } else if (!thisPOIC.qo.orderBy && (thisPOIC.searchType == 'nearbyRadial' || thisPOIC.searchType == 'nearbyShape')) {\n    //If this was a radial search sort the table by distance\n    //Find the index of the distance column and sort by this\n    var distanceCol = jQuery('#' + thisPOIC.collectionName).data('columnInfo')['distance'];\n    jQuery('#' + thisPOIC.collectionName).dataTable().fnSort([[distanceCol, 'asc']]);\n  } else if (!thisPOIC.qo.orderBy) {\n    //sort by name if no order by specified\n    //Find the index of the distance column and sort by this\n    var nameCol = jQuery('#' + thisPOIC.collectionName).data('columnInfo')['title'];\n    jQuery('#' + thisPOIC.collectionName).dataTable().fnSort([[nameCol, 'asc']]);\n  } // As of release 21, selectAll checkbox selects / deselects only the records on the\n  // currently visible page.  When a new page is displayed, the selectAll checkbox\n  // should be checked if all the currently visible records are selected, so the user\n  // can use the checkbox in its new function without having to 'prime' it (i.e. it had\n  // an inappropriate setting from the previous page).\n  // Note that the page-change function is called on the 'draw' event, because the 'page' event\n  // can be fired early enough that the table.fnSettings() return is not completely initialized.\n\n\n  var tbl = jQuery('#' + thisPOIC.collectionName).dataTable();\n  tbl.on('draw.dt', function () {\n    // hookPageChange(tbl);\n    var settings = tbl.fnSettings();\n    var aoData = tbl.fnGetData();\n    var columnInfo = jQuery('#' + settings.gp_collectionName).data('columnInfo');\n    var allDisplayedRecordsSelected = true; // make an assumption - we'll break when we find it's not true\n\n    for (var i = settings._iDisplayStart; i < settings._iDisplayEnd; i++) {\n      var rowNum = settings.aiDisplay[i];\n      var row = aoData[rowNum];\n      var poiId = row[columnInfo.uniqueId];\n\n      if (typeof gp_selectedRecords[poiId] == 'undefined' || gp_selectedRecords[poiId] == false) {\n        allDisplayedRecordsSelected = false;\n        break;\n      }\n    }\n\n    jQuery('#toggleAllInDataTable' + settings.gp_collectionName).prop('checked', allDisplayedRecordsSelected);\n  });\n} // Read table data, create CSV and send to server\n\n\nfunction gp_writeCSV(applyToIds) {\n  const payload = {\n    action: 'track',\n    data: {\n      event: 'Export CSV',\n      eventData: {\n        Selection: document.getElementById('applyActionTo').value\n      }\n    }\n  };\n  asyncGpEmitter('MixPanelService', payload);\n  gp_clearHiddenFields();\n\n  if (typeof applyToIds === 'string') {\n    applyToIds = applyToIds.split(',');\n  }\n\n  let csv = '';\n  const exportHiddenCols = [gp_ColumnInfo.recordId]; // Id\n\n  const ignoreVisibleCols = [gp_ColumnInfo.actions]; // actions\n\n  const newline = navigator.userAgent.match(/Windows/) ? '\\r\\n' : '\\n';\n  const applyToVal = document.getElementById('applyActionTo').value;\n  const isSelectedRecords = applyToVal === 'selectedRecords' || typeof applyToIds !== 'undefined' && applyToIds.length > 0;\n  const numberPins = gp_userSettings.settings__c[gp_orgSettings.fieldPrefix + 'Number_Map_Pins__c'];\n  const latIndex = gp_ColumnInfo.latitude;\n  const lngIndex = gp_ColumnInfo.longitude; // Get all data tables\n\n  const allTables = gp_getTablesToProcess({\n    applyAllTables: applyToIds ? true : false\n  }); // Don't continue if there's no data\n\n  if (allTables.length === 0) {\n    return false;\n  } // Loop through each table\n\n\n  for (let i = 0; i < allTables.length; i++) {\n    // Get Table Settings Object\n    const oSettings = jQuery(allTables[i]).dataTable().fnSettings(); // Get the Table Data\n\n    const aoData = jQuery(allTables[i]).dataTable().fnGetData();\n    const additionalHiddenFieldColNumbers = jQuery(allTables[i]).data('additionalHiddenFieldColNumbers');\n    const columnInfo = jQuery(allTables[i]).data('columnInfo'); // Build header row by looping through each column definition\n\n    let headerRow = ''; //Add a number column if mapped pins are numbered\n\n    if (numberPins) {\n      headerRow = '\"#\"';\n    }\n\n    let lastAddressIndex = -1;\n\n    for (let j = 0; j < oSettings.aoColumns.length; j++) {\n      // Get column\n      const col = oSettings.aoColumns[j]; //if visible, but not set to be ignored                          OR it's in the list to always export \t\t\t\t\t\t   OR it is a hidden additional field\n\n      if (col.bVisible && !ignoreVisibleCols.includes(j) || !col.bVisible && exportHiddenCols.includes(j) || additionalHiddenFieldColNumbers.includes(j)) {\n        if (headerRow != '') {\n          headerRow += ',';\n        }\n\n        let headerText = col.sTitle; // if applicable, fixup field name with relationName path\n\n        if (col.sPathLabel) {\n          headerText = col.sPathLabel + ' (' + headerText + ')';\n        }\n\n        headerRow += gp_CSVBoundData(gp_CSVCleanData(headerText)); // Add data set name and sfdc object right after the ID column\n\n        if (j === 1) {\n          headerRow += ',' + gp_CSVBoundData(gp_translations.Object_Name);\n          headerRow += ',' + gp_CSVBoundData(gp_translations.Data_Set_Name);\n        }\n\n        if ('fulladdress' === col.gpName || 'country' === col.gpName) {\n          // include lat/lng after address for every record\n          headerRow += ',\"Latitude\",\"Longitude\"';\n          lastAddressIndex = j;\n        }\n      }\n    }\n\n    if (lastAddressIndex === -1) {\n      // no address column found (!?), stick Lat/Lng at end of record\n      headerRow += ',\"Latitude\",\"Longitude\"';\n    } // Add header row to CSV string\n\n\n    csv += headerRow + newline; // Build data rows, get the correct data structure to loop over displayed or all\n\n    let dataArrayToLoop = oSettings.aiDisplay;\n\n    if (isSelectedRecords) {\n      //If we are exporting selected records loop over all data, not just displayed\n      dataArrayToLoop = aoData;\n    }\n\n    for (let j = 0; j < dataArrayToLoop.length; j++) {\n      let row = aoData[j];\n\n      if (!isSelectedRecords) {\n        row = aoData[oSettings.aiDisplay[j]];\n      } // default to recordId, but if this is a CSV dataset\n      // we won't have a recordId, but we'll have a uniqueId\n\n\n      let recordId = row[gp_ColumnInfo.recordId];\n\n      if (!recordId) {\n        recordId = row[gp_ColumnInfo.uniqueId];\n      }\n\n      const recordSelected = !applyToIds && isSelectedRecords && gp_selectedRecords[row[gp_ColumnInfo.uniqueId]];\n      const includedInApplyToIds = typeof applyToIds !== 'undefined' && applyToIds.includes(recordId);\n\n      if (!isSelectedRecords || recordSelected || includedInApplyToIds) {\n        let dataRow = ''; // If pin is numbered, export the number\n\n        let iconURL;\n\n        if (!isSelectedRecords) {\n          iconURL = aoData[dataArrayToLoop[j]][columnInfo.mapIconURL];\n        } else {\n          //selected records\n          iconURL = row[columnInfo.mapIconURL];\n        }\n\n        if (numberPins && iconURL.includes('text=')) {\n          const rowNum = iconURL.substring(iconURL.indexOf('text=') + 5, iconURL.length); //Make sure rowNom is a valid number\n\n          if (!isNaN(rowNum)) {\n            dataRow = '\"' + rowNum + '\"';\n          }\n        } // Loop through each column in the row\n\n\n        for (let k = 0; k < oSettings.aoColumns.length; k++) {\n          // Get column definition\n          const col = oSettings.aoColumns[k]; //if visible, but not set to be ignored\t\t\t\t\t\t\t OR\t\tit's in the list to always export \t\t\t\t\t   OR it is a hidden additional field\n\n          if (col.bVisible && !ignoreVisibleCols.includes(k) || !col.bVisible && exportHiddenCols.includes(k) || additionalHiddenFieldColNumbers.includes(k)) {\n            // Get data from Column\n            let colData = row[k];\n\n            if (typeof colData === 'object') {\n              colData = colData.label;\n            }\n\n            if (typeof colData === 'string') {\n              colData = gp_CSVCleanData(colData);\n            } else {\n              colData = colData + '';\n            }\n            /* Trim and clean the data */\n\n\n            colData = colData.replace(/^\\s+/, '').replace(/\\s+$/, '');\n\n            if (colData.includes('&')) {\n              colData = gp_htmlDecodeForCSV(colData);\n            }\n\n            if (dataRow != '') {\n              dataRow += ',';\n            }\n\n            dataRow += gp_CSVBoundData(colData); // Add data set name and sfdc object right after the ID column\n\n            if (k === 1) {\n              dataRow += ',' + gp_CSVBoundData(oSettings.gp_sfdcObject);\n              dataRow += ',' + gp_CSVBoundData(oSettings.gp_dataSetName);\n            }\n          }\n\n          if (k === lastAddressIndex) {\n            // insert lat/lng after address data\n            if (latIndex && lngIndex) {\n              dataRow += ',\"' + row[latIndex] + '\"';\n              dataRow += ',\"' + row[lngIndex] + '\"';\n            } else {\n              // placeholders if something goes wrong\n              dataRow += ',\"\",\"\"';\n            }\n          }\n        } // append record lat/lng if no address data in row\n\n\n        if (lastAddressIndex === -1) {\n          if (latIndex && lngIndex) {\n            dataRow += ',\"' + row[latIndex] + '\"';\n            dataRow += ',\"' + row[lngIndex] + '\"';\n          } else {\n            // placeholders if something goes wrong\n            dataRow += ',\"\",\"\"';\n          }\n        }\n\n        csv += dataRow + newline;\n      }\n    } // END OF Rows Loop\n    // Add a newline between tables\n\n\n    csv += newline;\n  } // END OF tables loop\n\n  /* Remove the last new line */\n\n\n  csv.slice(0, -1);\n  const today = new Date();\n  const fileName = 'MapExport_' + today.getFullYear() + (today.getMonth() + 1) + today.getDate() + '.csv';\n  gp_doCSVDownload(fileName, csv);\n  return true;\n}\n\nfunction gp_doCSVDownload(fileName, csv) {\n  // Check whether (modern) browser supports client-side download using FileSaver.js\n  var supportFileSaver = typeof new Blob() != 'undefined';\n\n  if (supportFileSaver) {\n    var data = new Blob([csv]);\n    saveAs(data, fileName); // as defined in filesaver.min.js\n  } else {\n    // browser won't help us, do the download server-side\n\n    /* Write CSV data to hidden form field and submit the form to the export CSV page */\n    document.querySelector('#gp_csvData').value = csv;\n    document.forms.gp_getCSV.submit();\n  }\n}\n\nfunction gp_downloadShapeDetails(applyToIds, idType) {\n  const payload = {\n    action: 'downloadShapeDetails',\n    data: {\n      applyToIds,\n      idType: idType ? idType : 'sfdcId'\n    }\n  };\n  asyncGpEmitter('GeoShapeCSVService', payload);\n} // Determines if a passed table is a csv table. Used to filter out csv layers from export\n\n\nfunction isCSVTable(table) {\n  const tableId = jQuery(table).attr('id');\n  const {\n    searchType\n  } = gp_dataSetSearches[tableId] || {};\n  return searchType === window.gpCsv;\n} //Read table data, create KML and send to server\n\n\nfunction gp_writeKML(applyToIds) {\n  const payload = {\n    action: 'track',\n    data: {\n      event: 'Export KML',\n      eventData: {\n        Selection: document.getElementById('applyActionTo').value\n      }\n    }\n  };\n  asyncGpEmitter('MixPanelService', payload);\n  gp_clearHiddenFields();\n  let kml = '';\n  const newline = navigator.userAgent.match(/Windows/) ? '\\r\\n' : '\\n';\n  const tab = '\\t';\n  const applyToVal = document.getElementById('applyActionTo').value;\n  let unsupportedRecordsFound = false;\n  let dataAddedToKml = false; // Get all data tables\n\n  const allTables = gp_getTablesToProcess({\n    disableAlerts: true,\n    applyAllTables: applyToIds ? true : false\n  });\n  const markerURLs = {};\n  const nonCSVTables = allTables.filter(table => {\n    if (isCSVTable(table)) {\n      unsupportedRecordsFound = true;\n      return false;\n    }\n\n    return true;\n  }); // Loop through each table and get the unique colors/symbols for the markers\n\n  nonCSVTables.forEach(table => {\n    // Get Table Settings Object on column info\n    const oSettings = jQuery(table).dataTable().fnSettings();\n    const gp_ColumnInfo = jQuery(table).data('columnInfo'); // Loop through the rows and get the various colors\n\n    oSettings.aiDisplay.forEach(display => {\n      const markerURL = oSettings.aoData[display]._aData[gp_ColumnInfo.mapIconURL];\n      markerURLs[gp_DOMPurify.sanitize(markerURL)] = '';\n    });\n  }); //Build the KML styles\n\n  for (const url in markerURLs) {\n    kml += '<Style id=\"Style_' + url + '\">' + newline;\n    kml += '<IconStyle>' + newline;\n    kml += '<Icon>' + newline;\n    kml += '<href><![CDATA[' + url + ']]></href>' + newline;\n    kml += '</Icon>' + newline;\n    kml += '<scale>0.5</scale>' + newline;\n    kml += '<hotSpot x=\"0.5\" y=\"0\" xunits=\"fraction\" yunits=\"fraction\"/>' + newline;\n    kml += '</IconStyle>' + newline;\n    kml += '<LabelStyle>' + newline;\n    kml += '<scale>0.8</scale>' + newline;\n    kml += '</LabelStyle>' + newline;\n    kml += '</Style>' + newline;\n  } // Loop through each table to do the placemarks\n\n\n  nonCSVTables.forEach(table => {\n    // Get Table Settings Object\n    const oSettings = jQuery(table).dataTable().fnSettings();\n    const gp_ColumnInfo = jQuery(table).data('columnInfo'); // Get the Table Data\n\n    const aoData = jQuery(table).dataTable().fnGetData();\n    kml += '<Folder>' + newline;\n    kml += '<name>' + gp_DOMPurify.sanitize(oSettings.gp_dataSetName) + '</name>' + newline; // Build data rows, get the correct data structure to loop over displayed or all\n\n    let dataArrayToLoop = oSettings.aiDisplay;\n\n    if (applyToVal === 'selectedRecords') {\n      //If we are exporting selected records loop over all data, not just displayed\n      dataArrayToLoop = aoData;\n    } // Loop through the rows\n\n\n    dataArrayToLoop.forEach(dataArray => {\n      if (!applyToIds && (applyToVal === 'selectedRecords' && gp_selectedRecords[dataArray[gp_ColumnInfo.uniqueId]] || applyToVal !== 'selectedRecords') || applyToIds && applyToIds.includes(dataArray[gp_ColumnInfo.recordId])) {\n        let row;\n\n        if (applyToIds) {\n          row = dataArray;\n        } else if (applyToVal !== 'selectedRecords') {\n          row = aoData[oSettings.aiDisplay[dataArrayToLoop.indexOf(dataArray)]];\n        } else {\n          row = dataArray;\n        }\n\n        dataAddedToKml = true;\n        kml += '<Placemark>' + newline;\n        kml += '<name><![CDATA[' + gp_DOMPurify.sanitize(row[gp_ColumnInfo.title]) + ']]></name>' + newline;\n        kml += '<description><![CDATA['; // Info Content\n\n        kml += '<div style=\"margin:10px 0;\">' + gp_DOMPurify.sanitize(row[gp_ColumnInfo.infoContent]) + '</div>';\n        kml += '<div style=\"margin:10px 0;\"><a href=\"javascript:window.open(\\'about:blank\\');\" onclick=\"window.open(\\'' + gp_DOMPurify.sanitize(gp_baseURL + '/' + row[gp_ColumnInfo.recordId]) + '\\');\" target=\"_blank\">' + gp_DOMPurify.sanitize(gp_translations.View_in_Salesforce) + '</a></div>'; // End the Placemark tag after each row\n\n        kml += ']]></description>' + newline;\n        kml += '<styleUrl>#Style_' + gp_DOMPurify.sanitize(row[gp_ColumnInfo.mapIconURL]) + '</styleUrl>';\n        kml += '<Point>' + newline;\n        kml += '<coordinates>' + parseFloat(row[gp_ColumnInfo.longitude]).toFixed(6) + ',' + parseFloat(row[gp_ColumnInfo.latitude]).toFixed(6) + ',0</coordinates>' + newline;\n        kml += '</Point>' + newline;\n        kml += '</Placemark>' + newline;\n      }\n    }); // End the Folder tag after each table\n\n    kml += '</Folder>' + newline;\n  }); //If browser suppports blob saveing also add the, TODO maybe use filesaver.js someday as this doesn't require posting to VF, may support larger KML exports\n  //if(typeof Blob != 'undefined'){\n\n  kml += '<Folder>' + newline;\n  kml += '<name>Shapes</name>' + newline;\n  const shapesForStyles = {};\n\n  function isVisibleStandardShape(shape) {\n    if (shape !== null && shape !== void 0 && shape.getMap() && (shape === null || shape === void 0 ? void 0 : shape.gpProperties.usageType) === 'Standard') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Object.values(polygonObjects).filter(polygon => isVisibleStandardShape(polygon)).forEach(polygon => {\n    //Save this shape so we can create a style for it, only need one shape per grouping so we use the group id\n    shapesForStyles[polygon.gpProperties.groupLayerId] = polygon; //Build out the polygon KML\n\n    let paths = [];\n\n    try {\n      //Circle and rectangle dont have getPaths()\n      paths = polygon.getPaths().getArray();\n    } catch (e) {} //If type is rectangle built the paths array\n\n\n    if (polygon.gpProperties.gpType === 'rectangle') {\n      const tempPath = new google.maps.MVCArray();\n      const polyBounds = polygon.getBounds(); //NW\n\n      tempPath.push(new google.maps.LatLng({\n        lat: polyBounds.getNorthEast().lat(),\n        lng: polyBounds.getSouthWest().lng()\n      })); //NE\n\n      tempPath.push(polyBounds.getNorthEast()); //SE\n\n      tempPath.push(new google.maps.LatLng({\n        lat: polyBounds.getSouthWest().lat(),\n        lng: polyBounds.getNorthEast().lng()\n      })); //SW\n\n      tempPath.push(polyBounds.getSouthWest());\n      paths = new google.maps.MVCArray();\n      paths.push(tempPath);\n      paths = paths.getArray();\n    } //If type is circle build the path array\n\n\n    if (polygon.gpProperties.gpType === 'circle') {\n      const tempPath = new google.maps.MVCArray();\n      const center = {\n        lat: polygon.center.lat(),\n        lng: polygon.center.lng()\n      };\n      const radius = polygon.radius;\n      const lat1 = center.lat * Math.PI / 180.0;\n      const lng1 = center.lng * Math.PI / 180.0;\n      const d = radius / 6371000; //Radius of the earth in meters\n\n      for (let x = 0; x <= 360; x++) {\n        const tc = x / 90 * Math.PI / 2;\n        let lat = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) * Math.sin(d) * Math.cos(tc));\n        lat = 180.0 * lat / Math.PI;\n        let lng;\n\n        if (Math.cos(lat1) == 0) {\n          lng = center.lng; //Endpoint a pole\n        } else {\n          lng = (lng1 - Math.asin(Math.sin(tc) * Math.sin(d) / Math.cos(lat1)) + Math.PI) % (2 * Math.PI) - Math.PI;\n        }\n\n        lng = 180.0 * lng / Math.PI;\n        const loc = new google.maps.LatLng({\n          lat: lat,\n          lng: lng\n        });\n        tempPath.push(loc);\n      }\n\n      paths = new google.maps.MVCArray();\n      paths.push(tempPath);\n      paths = paths.getArray();\n    } //If type is line build the path array\n\n\n    if (polygon.gpProperties.gpType === 'polyline') {\n      paths = new google.maps.MVCArray();\n      paths.push(polygon.getPath());\n      paths = paths.getArray();\n    }\n\n    const polygonKMLStrings = [];\n\n    function polygonHasInnerRings(path) {\n      return polygon.gpProperties.innerRings && polygon.gpProperties.innerRings[paths.indexOf(path)];\n    }\n\n    paths.filter(path => !polygonHasInnerRings(path)).forEach(path => {\n      dataAddedToKml = true;\n      let polygonKML = '';\n\n      if (polygon.gpProperties.gpType === 'polyline') {\n        polygonKML += '<LineString>' + newline;\n        polygonKML += tab + tab + '<coordinates>' + newline;\n        polygonKML += tab + tab + tab;\n        const pathArray = path.getArray();\n        pathArray.forEach(point => {\n          polygonKML += point.lng().toFixed(6) + ',' + point.lat().toFixed(6) + ',0 ';\n        });\n        polygonKML += newline;\n        polygonKML += tab + tab + '</coordinates>' + newline;\n        polygonKML += tab + '</LineString>' + newline;\n        polygonKMLStrings.push(polygonKML);\n      } else {\n        polygonKML += '<Polygon>' + newline;\n        polygonKML += tab + tab + '<outerBoundaryIs>' + newline;\n        polygonKML += tab + tab + tab + '<LinearRing>' + newline;\n        polygonKML += tab + tab + tab + tab + '<coordinates>' + newline;\n        polygonKML += tab + tab + tab + tab + tab;\n        const pathArray = path.getArray();\n        pathArray.forEach(point => {\n          polygonKML += point.lng().toFixed(6) + ',' + point.lat().toFixed(6) + ',0 ';\n        }); //Add the first point to the end to complete the ring\n\n        polygonKML += pathArray[0].lng().toFixed(6) + ',' + pathArray[0].lat().toFixed(6) + ',0 ' + newline;\n        polygonKML += tab + tab + tab + tab + '</coordinates>' + newline;\n        polygonKML += tab + tab + tab + '</LinearRing>' + newline;\n        polygonKML += tab + tab + '</outerBoundaryIs>' + newline;\n        polygonKML += '\t</Polygon>' + newline;\n        polygonKMLStrings.push(polygonKML);\n      }\n    }); //If there is more than one polygon\n\n    if (polygonKMLStrings.length > 1) {\n      kml += '<Placemark>' + newline;\n      kml += tab + '<styleUrl>#' + gp_DOMPurify.sanitize(polygon.gpProperties.groupLayerId) + '</styleUrl>' + newline;\n      kml += tab + '<name><![CDATA[' + gp_DOMPurify.sanitize(polygon.gpProperties.sfdcName) + ']]></name>' + newline;\n      kml += tab + '<description><![CDATA[' + gp_DOMPurify.sanitize(polygon.gpProperties.sfdcDescription) + ']]></description>' + newline;\n      kml += tab + '<MultiGeometry>';\n\n      for (let i = 0; i < polygonKMLStrings.length; i++) {\n        kml += tab + tab + polygonKMLStrings[i];\n      }\n\n      kml += tab + '</MultiGeometry>' + newline;\n      kml += '</Placemark>' + newline;\n    } else {\n      //Else single polygon\n      kml += '<Placemark>' + newline;\n      kml += tab + '<styleUrl>#' + gp_DOMPurify.sanitize(polygon.gpProperties.groupLayerId) + '</styleUrl>' + newline;\n      kml += tab + '<name><![CDATA[' + gp_DOMPurify.sanitize(polygon.gpProperties.sfdcName) + ']]></name>' + newline;\n      kml += tab + '<description><![CDATA[' + gp_DOMPurify.sanitize(polygon.gpProperties.sfdcDescription) + ']]></description>' + newline; // we build this polygonKMLStrings array up ourselves, and it doesn't contain\n      // any user defined data, so we don't need to put it through the sanitizer.\n      // The sanitizer was causing an issue with the formatting of the coordinates\n      // which meant the polygons wouldn't show when imported as KML.\n\n      kml += tab + polygonKMLStrings[0];\n      kml += '</Placemark>' + newline;\n    }\n  });\n  kml += '</Folder>' + newline;\n  Object.keys(shapesForStyles).forEach(key => {\n    const polygon = shapesForStyles[key]; //Google kml is stupid with colors as does alpha (transparence in hex) aabbggrr instead of common web of rrggbb\n\n    let color = polygon.fillColor || '99ccff';\n\n    if (color.indexOf('#') === 0) {\n      color = color.substring(1, 7);\n    }\n\n    let colorParts = color.match(/.{1,2}/g);\n    let poly_aabbggrr = colorParts[2] + colorParts[1] + colorParts[0]; //Calculate and set opacity\n\n    let opacity = polygon.fillOpacity || 0.5;\n    let decimal = parseInt(parseFloat(opacity) * 255);\n    let hex = decimal.toString(16);\n    poly_aabbggrr = hex + '' + poly_aabbggrr; // Get vals for the line\n\n    color = polygon.strokeColor || '000000';\n\n    if (color.indexOf('#') === 0) {\n      color = color.substring(1, 7);\n    }\n\n    colorParts = color.match(/.{1,2}/g);\n    let line_aabbggrr = colorParts[2] + colorParts[1] + colorParts[0]; //Calculate and set opacity\n\n    opacity = polygon.strokeOpacity || 0.9;\n    decimal = parseInt(parseFloat(opacity) * 255);\n    hex = decimal.toString(16);\n    line_aabbggrr = hex + '' + line_aabbggrr;\n    kml += '<Style id=\"' + gp_DOMPurify.sanitize(key) + '\">' + newline;\n    kml += tab + '<LineStyle>' + newline;\n    kml += tab + tab + '<width>' + gp_DOMPurify.sanitize(polygon.strokeWeight) + '</width>' + newline;\n    kml += tab + tab + '<color>' + gp_DOMPurify.sanitize(line_aabbggrr) + '</color>' + newline;\n    kml += tab + '</LineStyle>' + newline;\n    kml += tab + '<PolyStyle>' + newline;\n    kml += tab + tab + '<color>' + gp_DOMPurify.sanitize(poly_aabbggrr) + '</color>' + newline;\n    kml += tab + '</PolyStyle>' + newline;\n    kml += '</Style>' + newline;\n  }); // Check if any data was added to the kml to export\n\n  if (!dataAddedToKml) {\n    toastr.error('There is no data on the map to export');\n    return false;\n  }\n  /* Write KML data to hidden form field and submit the form to the export KML page */\n\n\n  document.getElementById('gp_kmlData').value = kml;\n  document.forms.gp_getKML.submit(); // Determine if there are any records that are not being exported\n\n  if (unsupportedRecordsFound) {\n    toastr.warning('One or more selected items did not qualify for the action performed. Action completed for qualified items only.');\n  }\n\n  return true;\n} //Wrap data up in double quotes and escape double quotes inside the data\n\n\nfunction gp_CSVBoundData(sData) {\n  var regex = new RegExp('\"', 'g');\n  sBoundary = '\"'; //Add a quote to each end of the string and replace any \" with two \"\"\n\n  return sBoundary + sData.replace(regex, '\"\"') + sBoundary;\n}\n\nfunction gp_CSVCleanData(sData) {\n  var sReturn;\n  /* Strip newlines, replace img tags with alt attr. and finally strip html... */\n\n  sReturn = sData.replace(/\\n/g, ' ');\n  sReturn = sReturn.replace(/<br\\s*\\/?>/gi, ' ');\n  sReturn = sReturn.replace(/<img.*?\\s+alt\\s*=\\s*(?:\"([^\"]+)\"|'([^']+)'|([^\\s>]+)).*?>/gi, '$1$2$3');\n  sReturn = sReturn.replace(/<.*?>/g, '');\n  return sReturn;\n} // Decode HTML entities\n\n\nfunction gp_htmlDecodeForCSV(sData) {\n  var aData = gp_ChunkData(sData, 2048),\n      n = document.createElement('div'),\n      i,\n      iLen,\n      iIndex,\n      sReturn = '',\n      sInner;\n  /* nodeValue has a limit in browsers - so we chunk the data into smaller segments to build\n   * up the string. Note that the 'trick' here is to remember than we might have split over\n   * an HTML entity, so we backtrack a little to make sure this doesn't happen\n   */\n\n  for (i = 0, iLen = aData.length; i < iLen; i++) {\n    /* Magic number 8 is because no entity is longer then strlen 8 in ISO 8859-1 */\n    iIndex = aData[i].lastIndexOf('&');\n\n    if (iIndex != -1 && aData[i].length >= 8 && iIndex > aData[i].length - 8) {\n      sInner = aData[i].substr(iIndex);\n      aData[i] = aData[i].substr(0, iIndex);\n    }\n\n    n.innerHTML = aData[i];\n    sReturn += n.childNodes[0].nodeValue;\n  }\n\n  return sReturn;\n} // Break a string up into an array of smaller strings\n\n\nfunction gp_ChunkData(sData, iSize) {\n  var asReturn = [];\n  var iStrlen = sData.length;\n\n  for (var i = 0; i < iStrlen; i += iSize) {\n    if (i + iSize < iStrlen) {\n      asReturn.push(sData.substring(i, i + iSize));\n    } else {\n      asReturn.push(sData.substring(i, iStrlen));\n    }\n  }\n\n  return asReturn;\n}\n/*************************\n * jQuery Route Data Tables functions\n *************************/\n\n\nfunction __JQUERY_DATA_TABLE_ROUTING_FUNCTIONS__() {} //Create the route tab for the directions\n\n\nfunction gp_createRouteTab(routeId) {\n  if (jQuery('#routeDirectionsTab').length == 0) {\n    var tabLabel = '<li id=\"routeDirectionsTab\">' + '<a href=\"#tabs-route\">' + '<span id=\"routeTabLabel\">' + gp_translations.Route_Detail + '</span>' + '<img id=\"routeDirectionsIcon\" src=\"' + directionsURL + '\"/>' + '<img class=\"tabShowHideIcon tabHideIcon\" id=\"removeRouteIcon\" src=\"' + blackXiconURL + '\" routeId=\"' + routeId + '\" title=\"' + gp_translations.Remove_route_from_map + '\"/>' + '<img class=\"tabShowHideIcon tabShowIcon\" id=\"showRouteIcon\" src=\"' + blackPlusIconURL + '\" routeId=\"' + routeId + '\" title=\"' + gp_translations.Show_route_on_map + '\"/>' + '</a>' + '</li>';\n    jQuery('#gp_dataTableTabs ul').append(gp_DOMPurify.sanitize(tabLabel));\n  } else {\n    // update the routeId on the existing elements\n    jQuery('#removeRouteIcon').attr('routeId', routeId);\n    jQuery('#showRouteIcon').attr('routeId', routeId);\n  }\n\n  if (jQuery('.routeDirectionsTabContent').length == 0) {\n    //Create the tab content which is the datatable\n    var tabContent = '<div class=\"routeDirectionsTabContent\" id=\"tabs-route\">' + '<div id=\"removeRouteButtons\">' + '<input id=\"showRouteBtn\" routeId=\"' + routeId + '\" type=\"button\" class=\"btn\" value=\"' + gp_translations.Show_Route + '\"/>' + '<input id=\"removeRouteTabBtn\" routeId=\"' + routeId + '\" type=\"button\" class=\"btn\" value=\"' + gp_translations.Remove_Route_Tab + '\"/>' + '</div>' + '<div id=\"routeNarrativeDIVWrapper\">' + '<div id=\"routeNarrativeDIV\"></div>' + '</div>' + '</div>';\n    jQuery('#gp_dataTableTabs').append(gp_DOMPurify.sanitize(tabContent));\n  } else {\n    // update the routeId on the existing elements\n    jQuery('#showRouteBtn').attr('routeId', routeId);\n    jQuery('#removeRouteTabBtn').attr('routeId', routeId);\n  } //Remove any hidden tab styles that ay be present\n\n\n  jQuery('#routeTabLabel').removeClass('tabDataHidden'); //Hide the remove route buttons and show the route narrative\n\n  jQuery('#removeRouteButtons').hide();\n  jQuery('#routeNarrativeDIVWrapper').show(); //Refresh the tab panel so jQuery UI relfects the newly added tab, fist store the scroll offset as refresh could cause scroll bars to jump\n\n  jQuery('#gp_dataTableTabs').tabs('refresh'); //Hide the no data message\n\n  jQuery('#gp_dataTablesNoData').hide(); //Make sure the route tab has focus by \"clicking\" it, only do this if there are no other tabs\n\n  if (jQuery('.dataSetResultTableTab').length == 0) {\n    jQuery('#routeDirectionsTab a').click();\n  } //Show the table tabs\n\n\n  jQuery('#gp_dataTables').show(); //Set the left and right padding for the tabs, varies due to translations\n\n  var $tabsList = jQuery('#gp_dataTableTabs ul:first');\n  $tabsList.css({\n    'padding-left': jQuery('#mappedDataTitle').width() + 17,\n    'padding-right': jQuery('#mappedDataButtons').width() + 13\n  });\n} //Remove the route detail tab\n\n\nfunction gp_removeRouteTab() {\n  //Check to see if the route tab is the currently selected tab\n  var wasRouteTabSelected = jQuery('#routeDirectionsTab').hasClass('ui-tabs-active');\n  jQuery('#routeDirectionsTab').remove();\n  jQuery('.routeDirectionsTabContent').remove(); //If there are no other tabs, show the no data message\n\n  if (jQuery('.dataSetResultTableTab').length == 0) {\n    jQuery('#gp_dataTablesNoData').show();\n    jQuery('#gp_dataTables').hide();\n  } else if (wasRouteTabSelected == true) {\n    //Select the first tab if the open tab as the route tab\n    jQuery('.dataSetResultTableTab:first a').click();\n  }\n} // Add to Route from the Data Table\n\n\nfunction gp_addToRouteFromDataTable(markerId, dataSetSearchId) {\n  const marker = gp_markers[markerId];\n  const {\n    sObject: obj,\n    collectionName,\n    gp_geocodeQuality\n  } = marker;\n  const dataSetSearch = gp_dataSetSearches[collectionName];\n  const {\n    searchType,\n    objectName,\n    columnLabels,\n    qo\n  } = dataSetSearch;\n  const {\n    moNew\n  } = qo || {};\n  const isCSVLayer = searchType === window.gpCsv;\n  let csvFieldMapping;\n\n  if (isCSVLayer) {\n    csvFieldMapping = {\n      ReadStreetField: obj[columnLabels.streetLabel]\n    };\n  }\n\n  var routeStop = {\n    id: guid(),\n    source: 'sfdc',\n    sourceId: obj.id,\n    name: '',\n    //set below\n    street: isCSVLayer ? obj[columnLabels.streetLabel] : getDescendantProp(obj, moNew.ReadStreetField),\n    city: isCSVLayer ? obj[columnLabels.cityLabel] : getDescendantProp(obj, moNew.ReadCityField),\n    state: isCSVLayer ? obj[columnLabels.stateLabel] : getDescendantProp(obj, moNew.ReadStateField),\n    postalCode: isCSVLayer ? obj[columnLabels.postalCodeLabel] : getDescendantProp(obj, moNew.ReadPostalField),\n    country: isCSVLayer ? obj[columnLabels.countryLabel] : getDescendantProp(obj, moNew.ReadCountryField),\n    countryISO: isCSVLayer ? '' : getDescendantProp(obj, moNew.GpCountryIsoField),\n    lat: isCSVLayer ? obj.gp_lat : getDescendantProp(obj, moNew.GpLatitudeField),\n    lng: isCSVLayer ? obj.gp_lng : getDescendantProp(obj, moNew.GpLongitudeField),\n    geocodeQuality: isCSVLayer ? gp_geocodeQuality : getDescendantProp(obj, moNew.GeocodeQualityField),\n    typeOfRecord: 'routeStop',\n    sfdcId: obj.id,\n    recordTypeId: marker.recordTypeId,\n    mapObjectName: isCSVLayer ? objectName : moNew.Name,\n    mapObjectSobjectName: isCSVLayer ? objectName : moNew.SobjectName\n  }; //Populate list of fields\n\n  try {\n    if (!isCSVLayer) {\n      routeStop.fieldNames = [];\n      var qoFields = qo.dataSetFields;\n      qoFields.forEach(function (field) {\n        routeStop.fieldNames.push(field.field);\n      });\n    }\n  } catch (e) {\n    console.log(e);\n  } //Set name value on the routeStop\n\n\n  if (!marker.gp_title2) {\n    routeStop.name = marker.gp_title;\n  } else {\n    routeStop.name = marker.gp_title + ' | ' + marker.gp_title2;\n  } //Add an item to the route in our angular routecontroller\n\n\n  var error = angular.element(jQuery('#routePanel')).scope().addToRouteFromExternal(routeStop);\n\n  if (!error) {\n    //Show success growl message\n    jQuery.extend(toastr.options, {\n      timeOut: 3000\n    });\n    toastr.success(gp_DOMPurify.sanitize('<i ignore>' + routeStop.name + '</i> ' + gp_translations.was_succesfully_added_to_Route)); // update route panel\n\n    var rScope = angular.element(jQuery('#routePanel')).scope();\n\n    if (rScope && rScope.refreshRouteStopFields) {\n      setTimeout(rScope.refreshRouteStopFields(), 0);\n    } // if user prefers, close info window originating the add\n\n\n    if (gp_userSettings.settings__c[nameSpacePrefix + 'Close_Info_Window_on_Add_to_Route__c'] == true) {\n      if (gp_infoWindow && gp_infoWindow.markerId === markerId) {\n        gp_closeInfoWindow(false);\n      }\n    }\n  } else {\n    jQuery.extend(toastr.options, {\n      timeOut: 60000\n    });\n    toastr.error(gp_DOMPurify.sanitize(error));\n  }\n}\n\nfunction gp_addToRouteRightClick() {\n  //Create geocode request with lat and long for reverse geocode\n  var latlng = new google.maps.LatLng(rightClickLatLng.lat, rightClickLatLng.lng); //Do the reverse geocode\n\n  var geocoder = new google.maps.Geocoder();\n  geocoder.geocode({\n    latLng: latlng\n  }, function (results, status) {\n    if (status == google.maps.GeocoderStatus.OK) {\n      //Hide the context menu.\n      jQuery('#mapContextMenu').hide(); //Parse google geocode\n\n      var address = gp_parseGoogleGeocode(results[0]); //build a poi object\n\n      routePOI = {\n        lat: results[0].geometry.location.lat(),\n        lng: results[0].geometry.location.lng(),\n        countryISO: address.country,\n        title: address.title,\n        street: address.street,\n        city: address.city,\n        state: address.state,\n        postalCode: address.postalCode,\n        country: address.country,\n        geocodeQuality: 'CUSTOM',\n        usesCustomerGeocode: '',\n        recordId: ''\n      }; //Add the poi object to the route\n\n      gp_addToRouteSearchOrCenterPOI(routePOI, 'rightClick');\n    } else {\n      alert(gp_DOMPurify.sanitize(gp_translations.Unable_to_add_location));\n\n      if (console && console.log) {\n        console.log(status);\n      }\n    }\n  });\n  const payload = {\n    action: 'trackRightClick',\n    data: {\n      action: 'Add to Route'\n    }\n  };\n  asyncGpEmitter('MixPanelService', payload);\n}\n\nfunction gp_addToRouteSearchOrCenterPOI(poi, type) {\n  if (poi) {\n    var routeStop = {\n      id: guid(),\n      source: 'sfdc',\n      sourceId: poi.recordId,\n      recordTypeId: poi.recordTypeId,\n      name: poi.title,\n      street: poi.street,\n      city: poi.city,\n      state: poi.state,\n      postalCode: poi.postalCode,\n      country: poi.country,\n      countryISO: poi.countryISO,\n      lat: poi.lat,\n      lng: poi.lng,\n      geocodeQuality: poi.geocodeQuality,\n      typeOfRecord: type\n    }; //Add an item to the route in our angular routecontroller\n\n    var error = angular.element(jQuery('#routePanel')).scope().addToRouteFromExternal(routeStop);\n\n    if (!error) {\n      //Show confirmation message\n      if (!(type == 'search' || type == 'rightClick')) {\n        //Center point message\n        jQuery.extend(toastr.options, {\n          timeOut: 3000\n        });\n        toastr.success('<i ignore>' + gp_DOMPurify.sanitize(poi.title) + '</i> ' + 'was successfully added to the Current Route list.');\n      }\n    } else {\n      jQuery.extend(toastr.options, {\n        timeOut: 60000\n      });\n      toastr.error(gp_DOMPurify.sanitize(error));\n    } // if user prefers, close info window originating the add\n\n\n    if (gp_userSettings.settings__c[nameSpacePrefix + 'Close_Info_Window_on_Add_to_Route__c'] == true) {\n      if (gp_infoWindow && gp_infoWindow.markerId === poi.recordId || // record marker\n      gp_infoWindow.markerId === 'centerPOI' && poi.uniqueId === 'centerPOI' || // Map record center pin\n      gp_infoWindow.markerId == 'gp_mapSearchPoi' && poi.recordId == '' && gp_infoWindow.content.includes(poi.title) || // 'My Locations' pin\n      gp_infoWindow.markerId == 'gp_mapCenterPoi' && poi.recordId == '' // \"search nearby from center\" ctr pin\n      ) {\n          gp_closeInfoWindow(false);\n        }\n    }\n  }\n} // Adds all data table data to the route\n\n\nfunction gp_addAllToRoute(idArray) {\n  const allTables = gp_getTablesToProcess();\n\n  if (allTables.length === 0) {\n    return false;\n  }\n\n  const recordsToAdd = [];\n  let unsupportedRecordsFound = false;\n  let applyToVal = document.getElementById('applyActionTo').value;\n  const idMap = [];\n\n  if (typeof idArray !== 'undefined') {\n    if (idArray.length > 0) {\n      applyToVal = 'idArray';\n\n      for (let i = 0; i < idArray.length; i++) {\n        idMap[idArray[i]] = 1;\n      }\n    } else {\n      toastr.info('There are no records to add to the route.');\n      return true; // defined work-list is empty; nothing to do\n    }\n  }\n\n  geopointeAjaxStart('body', gp_translations.Loading_Route + '...', 200); // Loop thru all tables\n\n  allTables.filter(table => {\n    if (isCSVTable(table) && document.getElementById('applyActionTo').value !== 'selectedRecords') {\n      unsupportedRecordsFound = true;\n      return false;\n    }\n\n    return true;\n  }).forEach(table => {\n    const tableId = jQuery(table).attr('id'); //Use the column info object attached to the data table as each table could have different number of columns\n\n    const gp_ColumnInfo = jQuery(table).data('columnInfo');\n    const oSettings = jQuery(table).dataTable().fnSettings(); // Get the Table Data\n\n    const aoData = jQuery(table).dataTable().fnGetData();\n    let dataArrayToLoop = oSettings.aiDisplay;\n\n    if (document.getElementById('applyActionTo').value === 'selectedRecords') {\n      //If we are exporting selected records loop over all data, not just displayed\n      dataArrayToLoop = aoData;\n    }\n\n    for (let j = 0; j < dataArrayToLoop.length; j++) {\n      let thisRow;\n\n      if (document.getElementById('applyActionTo').value !== 'selectedRecords') {\n        thisRow = aoData[dataArrayToLoop[j]];\n      } else {\n        thisRow = aoData[j];\n\n        if (isCSVTable(table) && gp_selectedRecords[thisRow[gp_ColumnInfo.uniqueId]]) {\n          unsupportedRecordsFound = true;\n        }\n      }\n\n      if (!isCSVTable(table) && (applyToVal === 'idArray' && idMap[thisRow[gp_ColumnInfo.recordId]] || applyToVal === 'selectedRecords' && gp_selectedRecords[thisRow[gp_ColumnInfo.uniqueId]] || applyToVal !== 'selectedRecords' && applyToVal !== 'idArray')) {\n        var routeStop = {\n          id: guid(),\n          source: 'sfdc',\n          sourceId: thisRow[gp_ColumnInfo.recordId],\n          name: '',\n          //set below\n          street: thisRow[gp_ColumnInfo.street],\n          city: thisRow[gp_ColumnInfo.city],\n          state: thisRow[gp_ColumnInfo.state],\n          postalCode: thisRow[gp_ColumnInfo.postalCode],\n          country: thisRow[gp_ColumnInfo.country],\n          countryISO: thisRow[gp_ColumnInfo.countryISO],\n          lat: thisRow[gp_ColumnInfo.latitude],\n          lng: thisRow[gp_ColumnInfo.longitude],\n          geocodeQuality: thisRow[gp_ColumnInfo.geocodeQuality],\n          typeOfRecord: 'routeStop',\n          sfdcId: thisRow[gp_ColumnInfo.recordId],\n          recordTypeId: thisRow[gp_ColumnInfo.recordTypeId],\n          mapObjectName: gp_dataSetSearches[tableId].qo.moNew.Name,\n          mapObjectSobjectName: typeof gp_objNameByKeyPref != 'undefined' && typeof gp_objNameByKeyPref[thisRow[gp_ColumnInfo.recordId].substring(0, 3)] != 'undefined' ? gp_objNameByKeyPref[thisRow[gp_ColumnInfo.recordId].substring(0, 3)].toLowerCase() : ''\n        }; //Populate list of fields\n\n        try {\n          routeStop.fieldNames = [];\n          const qoFields = gp_dataSetSearches[gp_markers[thisRow[gp_ColumnInfo.uniqueId]].collectionName].qo.dataSetFields;\n\n          if (qoFields) {\n            qoFields.forEach(function (field) {\n              routeStop.fieldNames.push(field.field);\n            });\n          }\n        } catch (e) {\n          console.log(e);\n        } //Set name value on the routeStop\n\n\n        if (thisRow[gp_ColumnInfo.title2] == '') {\n          routeStop.name = gp_htmlDecode(thisRow[gp_ColumnInfo.title]);\n        } else {\n          routeStop.name = gp_htmlDecode(thisRow[gp_ColumnInfo.title]) + ' | ' + gp_htmlDecode(thisRow[gp_ColumnInfo.title2]);\n        }\n\n        recordsToAdd.push(routeStop);\n      }\n    }\n  });\n  const rScope = angular.element(jQuery('#routePanel')).scope();\n\n  if (gp_routes.routeLimitHit(rScope.activeRoute.routeStops.length, recordsToAdd.length, false)) {\n    jQuery.extend(toastr.options, {\n      timeOut: 4000\n    });\n    toastr.warning(gp_DOMPurify.sanitize(gp_translations.There_are_too_many_points_mapped_to_add));\n    geopointeAjaxEnd();\n    return false;\n  } else if (recordsToAdd.length !== 0) {\n    //Add stops to the route in our angular routeController\n    rScope.addToRouteFromExternal(recordsToAdd);\n\n    if (rScope.refreshRouteStopFields) {\n      setTimeout(rScope.refreshRouteStopFields(), 0);\n    }\n  } else {\n    geopointeAjaxEnd();\n    toastr.error('One or more selected items did not qualify for the action performed');\n    return false;\n  }\n\n  const payload = {\n    action: 'trackRouteAddAll',\n    data: {\n      stopsAdded: recordsToAdd.length,\n      selection: document.getElementById('applyActionTo').value\n    }\n  };\n  asyncGpEmitter('MixPanelService', payload);\n  jQuery.extend(toastr.options, {\n    timeOut: 3000\n  }); // Display a warning if some records (CSV records) were not exported\n\n  if (unsupportedRecordsFound) {\n    toastr.warning('One or more selected items did not qualify for the action performed. Action completed for qualified items only.');\n  } else {\n    toastr.success(gp_DOMPurify.sanitize(gp_translations.All_Records_were_successfully_added_to_the_Current_Route_list));\n  }\n\n  geopointeAjaxEnd();\n  return true;\n} //Accepts the routingPOIs object from map controller and adds them to the data table\n\n\nfunction gp_addToRouteFromRPOIs(routingPOIs) {\n  if (routingPOIs != null) {\n    geopointeAjaxStart('body', gp_translations.Loading_Route + '...', 200);\n    var routeStops = [];\n    jQuery.each(routingPOIs, function (key, value) {\n      // change null to '' for all properties\n      jQuery.each(value, function (key, propvalue) {\n        if (propvalue == null) {\n          value[key] = '';\n        }\n      });\n\n      if (value.stopVia == '') {\n        value.stopVia = 's';\n      }\n\n      routeStops.push({\n        id: guid(),\n        source: value.source,\n        sourceId: value.sourceId,\n        recordTypeId: value.recordTypeId,\n        name: value.title,\n        street: value.street,\n        city: value.city,\n        state: value.state,\n        postalCode: value.postalCode,\n        country: value.country,\n        countryISO: value.countryISO,\n        lat: value.lat,\n        lng: value.lng,\n        geocodeQuality: value.geocodeQuality,\n        typeOfRecord: 'routeStop'\n      });\n    }); //Add stops to the route in our angular routeController\n\n    var error = angular.element(jQuery('#routePanel')).scope().addToRouteFromExternal(recordsToAdd);\n    if (error) toastr.error(gp_DOMPurify.sanitize(error));\n  }\n} // Add an external POI to the route list\n\n\nfunction gp_addToRouteExternalPOI(name, street, city, state, zip, country, lat, lng, src, srcId) {\n  // If a route already has a start location, current location can't be added, and vice-versa (but right now 10/18, no way to add a start location)\n  // This may get refactored when we support adding a start location\n  var rcScope;\n\n  if (srcId == 'gp_currentLocation') {\n    rcScope = angular.element('.routeController').scope();\n\n    if (rcScope && rcScope.activeRoute && rcScope.activeRoute.routeStops[0].routeStopType == 'start') {\n      jQuery.extend(toastr.options, {\n        timeOut: 60000\n      });\n      toastr.warning('To start this route from your current position, remove Start Location then do Add To Route from the Current Location dot on the map.');\n      return;\n    }\n  }\n\n  var routeStop = {\n    id: 'gp_currentLocation' === srcId ? 'currentLocation' : guid(),\n    source: src,\n    sourceId: srcId,\n    name: name,\n    street: street,\n    city: city,\n    state: state,\n    postalCode: zip,\n    country: country,\n    countryISO: country,\n    lat: lat,\n    lng: lng,\n    geocodeQuality: 'CUSTOM',\n    typeOfRecord: 'routeStop'\n  }; //Add stops to the route in our angular routeController\n\n  var error = angular.element(jQuery('#routePanel')).scope().addToRouteFromExternal(routeStop);\n\n  if (!error) {\n    if ('currentLocation' === routeStop.id && rcScope) {\n      rcScope.activeRoute.currentLocationWasRemoved = false;\n    } else {\n      jQuery.extend(toastr.options, {\n        timeOut: 3000\n      });\n      toastr.success(gp_DOMPurify.sanitize('<i ignore>' + routeStop.name + '</i> ' + gp_translations.was_succesfully_added_to_Route));\n    }\n  } else {\n    jQuery.extend(toastr.options, {\n      timeOut: 60000\n    });\n    toastr.error(gp_DOMPurify.sanitize(error));\n  } // if user prefers, close info window originating the add\n\n\n  if (gp_userSettings.settings__c[nameSpacePrefix + 'Close_Info_Window_on_Add_to_Route__c'] == true) {\n    if (gp_infoWindow) {\n      // place can only addToRoute from its info window, so whichever is open should close\n      gp_closeInfoWindow(false);\n    }\n  }\n}\n\nfunction gp_addToRouteCalendarPOI(poi) {\n  // If a route already has a start location, current location can't be added, and vice-versa (but right now 10/18, no way to add a start location)\n  // This may get refactored when we support adding a start location\n  var rcScope;\n  var routeStop = {\n    id: guid(),\n    recordId: poi.recordId,\n    sfdcId: poi.sfdcId,\n    name: poi.name,\n    street: poi.street,\n    city: poi.city,\n    state: poi.state,\n    postalCode: poi.zip,\n    country: poi.country,\n    countryISO: poi.country,\n    lat: poi.lat,\n    lng: poi.lng,\n    geocodeQuality: 'CUSTOM',\n    typeOfRecord: 'routeStop'\n  }; //Add stops to the route in our angular routeController\n\n  var error = angular.element(jQuery('#routePanel')).scope().addToRouteFromExternal(routeStop);\n\n  if (!error) {\n    if ('currentLocation' === routeStop.id && rcScope) {\n      rcScope.activeRoute.currentLocationWasRemoved = false;\n    } else {\n      jQuery.extend(toastr.options, {\n        timeOut: 3000\n      });\n      toastr.success(gp_DOMPurify.sanitize('<i ignore>' + routeStop.name + '</i> ' + gp_translations.was_succesfully_added_to_Route));\n    }\n  } else {\n    jQuery.extend(toastr.options, {\n      timeOut: 60000\n    });\n    toastr.error(gp_DOMPurify.sanitize(error));\n  } // if user prefers, close info window originating the add\n\n\n  if (gp_userSettings.settings__c[nameSpacePrefix + 'Close_Info_Window_on_Add_to_Route__c'] == true) {\n    if (gp_infoWindow) {\n      // place can only addToRoute from its info window, so whichever is open should close\n      gp_closeInfoWindow(false);\n    }\n  }\n} //Method that can be called after google script is loaded async for gp_addToRouteMyLocation() method\n\n\nvar gpTempLocationId;\n\nfunction gp_addToRouteMyLocationAsyncScript() {\n  gp_addToRouteMyLocation(gpTempLocationId);\n}\n\nfunction gp_addToRouteMyLocation(locationId) {\n  //Get the address from the location Id\n  var location = _.find(angular.element('.dataSetController').scope().locations, {\n    id: locationId\n  }) || {}; //If lat/lng are present on the location, use these.\n\n  if (location.latitude && location.longitude) {\n    //Build a route poi object\n    routePOI = {\n      lat: Number(location.latitude),\n      lng: Number(location.longitude),\n      countryISO: location.country,\n      title: location.name,\n      street: location.street,\n      city: location.city,\n      state: location.state,\n      postalCode: location.postalCode,\n      country: location.country,\n      geocodeQuality: 'CUSTOM',\n      usesCustomerGeocode: '',\n      recordId: ''\n    }; //Add the poi object to the route\n\n    gp_addToRouteSearchOrCenterPOI(routePOI, 'location');\n  } else {\n    //If the google javascript api is not loaded, load it, and call this function again after it has loaded\n    if (typeof google == 'undefined') {\n      //Store the argument of this method is a global var that can be used in script load call back\n      gpTempLocationId = locationId;\n      gp_loadGoogScript('gp_addToRouteMyLocationAsyncScript');\n      return false;\n    } //Do a geocode to get the lat lng\n\n\n    searchReq = {\n      address: location.singleLineAddress\n    }; //Do a reverse geocode to get updated information and lat/lng\n\n    var geocoder = new google.maps.Geocoder();\n    geocoder.geocode(searchReq, function (results, status) {\n      if (status == google.maps.GeocoderStatus.OK) {\n        //Parse google geocode\n        var address = gp_parseGoogleGeocode(results[0]); //Set the title as the location name\n\n        address.title = location.name; //Build a route poi object\n\n        routePOI = {\n          lat: results[0].geometry.location.lat(),\n          lng: results[0].geometry.location.lng(),\n          countryISO: address.country,\n          title: address.title,\n          street: address.street,\n          city: address.city,\n          state: address.state,\n          postalCode: address.postalCode,\n          country: address.country,\n          geocodeQuality: 'CUSTOM',\n          usesCustomerGeocode: '',\n          recordId: ''\n        }; //Add the poi object to the route\n\n        gp_addToRouteSearchOrCenterPOI(routePOI, 'location');\n      } else if (status == google.maps.GeocoderStatus.ZERO_RESULTS) {\n        jQuery.extend(toastr.options, {\n          timeOut: 5000\n        });\n        toastr.error(gp_DOMPurify.sanitize(gp_translations.Unable_to_locate_accurate_position_for + ' ' + location.name + ' ' + gp_translations.and_it_could_not_be_added_to_the_route));\n      } else {\n        alert(gp_DOMPurify.sanitize(gp_translations.Unable_to_route_location));\n\n        if (console && console.log) {\n          console.log(status);\n        }\n      }\n    });\n  }\n} // Array Remove - By John Resig (MIT Licensed)\n\n\nArray.prototype.remove = function (from, to) {\n  var rest = this.slice((to || from) + 1 || this.length);\n  this.length = from < 0 ? this.length + from : from;\n  return this.push.apply(this, rest);\n};\n/*************************\n * Share Map Functions\n *************************/\n\n\nfunction __SHARED_MAP_FUNCTIONS__() {}\n\nfunction gp_clearHiddenFields() {\n  // Clear the hidden data so we don't keep sending it to server\n  jQuery(gp_UIElem.hidden_routeLocXML).val('');\n} // Finish POI Object\n\n\nfunction gp_finishPOIObject(iPOI) {\n  var oPOI = iPOI; // change null to '' for all properties 20ms\n\n  for (var key in oPOI) {\n    if (oPOI[key] == null) {\n      oPOI[key] = '';\n    }\n  }\n\n  if (oPOI.lat == null) {\n    oPOI.isBlankLat = true;\n  } else {\n    oPOI.isBlankLat = false;\n  }\n\n  if (oPOI.lng == null) {\n    oPOI.isBlankLng = true;\n  } else {\n    oPOI.isBlankLng = false;\n  }\n\n  oPOI.formattedAddr = '';\n\n  if (oPOI.street != '') {\n    oPOI.formattedAddr += \"\".concat(gp_escapeHtml(oPOI.street), \"<br/>\");\n  }\n\n  if (oPOI.city != '') {\n    oPOI.formattedAddr += gp_escapeHtml(oPOI.city);\n  }\n\n  if (oPOI.city != '' && oPOI.state != '') {\n    oPOI.formattedAddr += ', ';\n  }\n\n  if (oPOI.state != '') {\n    oPOI.formattedAddr += \" \".concat(gp_escapeHtml(oPOI.state));\n  }\n\n  if (oPOI.postalCode != '') {\n    oPOI.formattedAddr += \" \".concat(gp_escapeHtml(oPOI.postalCode));\n  }\n\n  if (oPOI.country != '') {\n    oPOI.formattedAddr += \"<br/>\".concat(oPOI.country);\n  }\n\n  oPOI.formattedAddr = gp_DOMPurify.sanitize(oPOI.formattedAddr);\n\n  if (oPOI.mapIconURL == '') {\n    oPOI.isBlankMapIconURL = true;\n  }\n\n  if (oPOI.mapIconWidth == '' || oPOI.mapIconHeight == '') {\n    oPOI.isBlankMapIconSize = true;\n  }\n\n  oPOI.distanceFromCenter = '';\n\n  if (oPOI.distanceFromCenterRaw) {\n    oPOI.distanceFromCenter = '' + Math.round(oPOI.distanceFromCenterRaw * 100) / 100 + '';\n  }\n\n  oPOI.distanceInfo = '';\n\n  if (oPOI.distanceFromCenterRaw) {\n    var unitsLabel = gp_DOMPurify.sanitize(gp_translations.Kilometers.toLowerCase());\n\n    if (oPOI.distanceUnits[0] == 'm') {\n      unitsLabel = gp_DOMPurify.sanitize(gp_translations.Miles.toLowerCase());\n    }\n\n    oPOI.distanceInfo = \"\".concat(gp_escapeHtml(oPOI.distanceFromCenter), \" \").concat(unitsLabel);\n  }\n\n  oPOI.baseInfoContentHTMLSanitized = gp_buildBaseInfoContent(oPOI); // SECURITY: gp_buildBaseInfoContent returns sanitized html\n\n  return oPOI;\n} // Stored in Data Table for use in things like KML export, TODO performance this is really bad, it's building a crap ton of xml that is only used on export of KML\n// SECURITY: Returns sanitized html string\n\n\nfunction gp_buildBaseInfoContent(thisPOI) {\n  var tmpInfoContentHTML = '';\n\n  if (thisPOI.title2 != '') {\n    tmpInfoContentHTML += '<b style=\"font-size: 1.1em;\">' + thisPOI.title2 + '</b><br/>';\n  }\n\n  if (thisPOI.street != '') {\n    tmpInfoContentHTML += thisPOI.street + '<br/>';\n  }\n\n  if (thisPOI.city != '') {\n    tmpInfoContentHTML += thisPOI.city;\n  }\n\n  if (thisPOI.city != '' && thisPOI.state != '') {\n    tmpInfoContentHTML += ', ';\n  }\n\n  if (thisPOI.state != '') {\n    tmpInfoContentHTML += ' ' + thisPOI.state;\n  }\n\n  if (thisPOI.postalCode != '') {\n    tmpInfoContentHTML += ' ' + thisPOI.postalCode;\n  }\n\n  if (thisPOI.country != '') {\n    tmpInfoContentHTML += '<br/>' + thisPOI.country;\n  }\n\n  if (thisPOI.distanceInfo != '') {\n    tmpInfoContentHTML += thisPOI.distanceInfo;\n  }\n\n  if (thisPOI.geocodeQuality != '') {\n    tmpInfoContentHTML += '<br/><b>' + gp_translations.Geocode_Quality + '</b>: ' + thisPOI.geocodeQuality;\n  }\n\n  if (typeof thisPOI.additionalFields != 'undefined') {\n    if (thisPOI.additionalFields != null) {\n      //if current record isocode is equal to the user settings isocode then true\n      if (thisPOI.sObject && thisPOI.sObject.currencyisocode) {\n        var excludeCurrencyCheck = thisPOI.sObject.currencyisocode == gp_userSettings.userInfo.userCurrency.isoCode;\n      }\n\n      tmpInfoContentHTML += '<hr/>';\n      jQuery.each(thisPOI.additionalFields, function (key, value) {\n        //if record and user setting iscodes match and current field is a converted value then hide from infoWindow\n        if (excludeCurrencyCheck && gp_isConvCurrAlias(value.name)) value.inInfo = false;\n        tmpInfoContentHTML += '<b>' + value.label + '</b>: ' + value.value + '<br/>';\n      });\n    }\n  }\n\n  return gp_DOMPurify.sanitize(tmpInfoContentHTML);\n} //Show Drive Distance Column\n\n\nfunction gp_showDriveDistanceColumn(tableId, units) {\n  if (typeof gp_radialSearchCenter == 'undefined') return;\n  var oTable = jQuery('#' + tableId).dataTable();\n  var aoData = jQuery('#' + tableId).dataTable().fnGetData();\n  var gp_ColumnInfo = jQuery('#' + tableId).data('columnInfo');\n  var oSettings = oTable.fnSettings();\n  if (oSettings.aiDisplay.length == 0) return;\n  if (gp_ColumnInfo.distanceDrive) oTable.fnSetColumnVis(gp_ColumnInfo.distanceDrive, true, false);\n  if (gp_ColumnInfo.timeDrive) oTable.fnSetColumnVis(gp_ColumnInfo.timeDrive, true, false);\n} // Perform Route Matrix Search\n\n\nfunction gp_calcDriveTimes(tableId, calcTime) {\n  //tableId is same as collectionName\n  if (calcTime && !gp_orgSettings.settings.datatableDriveTimeEnabled) return; // this should never happen, but if somebody figured out how to call this without our permission enabled, we prefer not to pay for it.\n\n  var units = gp_dataSetSearches[tableId].nearbySearchDistanceUnits;\n  var oTable = jQuery('#' + tableId).dataTable();\n  var aoData = jQuery('#' + tableId).dataTable().fnGetData();\n  var gp_ColumnInfo = jQuery('#' + tableId).data('columnInfo'); //Getting the visible rows with datatables seems impossible, so we use jQuery to get the visible rows and capture the record Ids\n\n  var markerIds = [];\n  jQuery('#' + tableId + ' tr:visible').find('.directionsMarkerId').each(function (e) {\n    markerIds.push(jQuery(this).text());\n  }); //var directionRequests = 0;\n\n  var recordsToUpdateByRowIndexChunked = [];\n  var chunkSize = 0;\n  var recordsToUpdateByRowIndex = {}; //Loop through the datatable and split rows into groups of 24, need to save one for the center point\n\n  for (var i = 0; i < aoData.length; i++) {\n    var row = aoData[i];\n\n    if (markerIds.indexOf(row[gp_ColumnInfo.uniqueId]) > -1) {\n      //check to see if drive distance is already populated\n      var distance = calcTime ? row[gp_ColumnInfo.timeDrive] : row[gp_ColumnInfo.distanceDrive];\n\n      if (distance == null || typeof distance == 'undefined' || distance == '' || distance == '-') {\n        recordsToUpdateByRowIndex[i] = row;\n        chunkSize++;\n      }\n    }\n\n    if (chunkSize == 24) {\n      recordsToUpdateByRowIndexChunked.push(recordsToUpdateByRowIndex);\n      recordsToUpdateByRowIndex = {};\n      chunkSize = 0;\n    }\n  }\n\n  if (chunkSize > 0) {\n    recordsToUpdateByRowIndexChunked.push(recordsToUpdateByRowIndex);\n  }\n\n  if (calcTime) {\n    var distMxService = new google.maps.DistanceMatrixService();\n    var totalChunks = recordsToUpdateByRowIndexChunked.length;\n    var perChunkDelay = totalChunks > 3 ? 1000 : 0; // try not to annoy Google with large pages\n\n    var currentChunk = 0;\n    var finishedChunk;\n    var driveTimeStart = gp_dataSetSearches[tableId].nearbyStartTime;\n    var mSecPerWeek = 604800000; // distanceMatrix requires startTime to be in the future\n    // spin icon while updating rows\n\n    jQuery('#calcDriveTimeIcon' + tableId).addClass('fa-spin');\n    finishedChunk = 0;\n    recordsToUpdateByRowIndexChunked.forEach(function (recordsToUpdateByIndex) {\n      var driveTimeIndexToTableIndex = {};\n      var count = 0;\n      var driveTimeReq = {\n        destinations: [],\n        origins: [],\n        travelMode: 'DRIVING',\n        drivingOptions: {\n          departureTime: driveTimeStart ? new Date(driveTimeStart + mSecPerWeek) : new Date(),\n          trafficModel: google.maps.TrafficModel.BEST_GUESS\n        }\n      };\n      driveTimeReq.origins.push(new google.maps.LatLng(gp_radialSearchCenter.lat, gp_radialSearchCenter.lng));\n\n      for (const key in recordsToUpdateByIndex) {\n        var row = recordsToUpdateByIndex[key];\n        driveTimeReq.destinations.push(new google.maps.LatLng(row[gp_ColumnInfo.latitude], row[gp_ColumnInfo.longitude]));\n        driveTimeIndexToTableIndex[count] = key;\n        count++;\n      }\n\n      setTimeout(function () {\n        var driveTimeRes = distMxService.getDistanceMatrix(driveTimeReq, function (resp, stat) {\n          if ('OK' !== stat) {\n            console.log('RES: ', resp);\n            jQuery.extend(toastr.options, {\n              timeOut: 60000\n            });\n\n            if ('OVER_QUERY_LIMIT' === stat) {\n              toastr.warning('The drive time server seems busy - try again in a few moments.');\n            } else {\n              toastr.error(gp_DOMPurify.sanitize('There was an error processing the drive time request ' + stat));\n            }\n          } else {\n            var durationRows = resp.rows[0].elements;\n\n            for (var ix = 0; ix < durationRows.length; ix++) {\n              var row = durationRows[ix];\n              if ('ZERO_RESULTS' === row.status || null == row.duration) continue;\n              oTable.fnUpdate({\n                label: row.duration.text,\n                value: row.duration.value,\n                toString: function toString() {\n                  return this.label;\n                }\n              }, parseInt(driveTimeIndexToTableIndex[ix]), gp_ColumnInfo.timeDrive, false, false);\n            }\n          }\n        }); // stop spinning icon when last update is finished\n\n        if (++finishedChunk >= totalChunks) {\n          jQuery('#calcDriveTimeIcon' + tableId).removeClass('fa-spin');\n        }\n      }, perChunkDelay * currentChunk++);\n    });\n  } else {\n    recordsToUpdateByRowIndexChunked.forEach(function (recordsToUpdateByIndex) {\n      var distanceIndexToTableIndex = {};\n      var count = 0;\n      var distanceURL = GEOPOINTE_API + '/v1/routing/table/v1/driving/' + gp_radialSearchCenter.lng + ',' + gp_radialSearchCenter.lat + ';'; //lng,lat;lng,lat;lng,lat\n\n      for (const key in recordsToUpdateByIndex) {\n        var row = recordsToUpdateByIndex[key];\n        distanceURL += row[gp_ColumnInfo.longitude] + ',' + row[gp_ColumnInfo.latitude] + ';';\n        distanceIndexToTableIndex[count] = key;\n        count++;\n      } //Remove the last ;\n\n\n      distanceURL = distanceURL.substring(0, distanceURL.length - 1);\n      distanceURL += '?sources=0&annotations=distance'; //The first lng/lat is the source, everything else is destination\n\n      fetch(distanceURL).then(response => response.json()).then(response => {\n        if (response.code != 'Ok') {\n          throw gp_DOMPurify.sanitize(response.message);\n        }\n\n        const distanceRows = response.distances[0];\n        distanceRows.shift(); //Remove the first element as that 0 distance to centerpoint\n\n        for (var i = 0; i < distanceRows.length; i++) {\n          let distance = distanceRows[i];\n          if (distance == null) continue;\n          if (units == 'km') distance = (distance / 1000).toFixed(2);else distance = (distance * 0.000621371).toFixed(2); // distance comes back in meters.  convert to miles\n\n          oTable.fnUpdate(distance, parseInt(distanceIndexToTableIndex[i]), gp_ColumnInfo.distanceDrive, false, false);\n        }\n      }).catch(error => {\n        console.error(error);\n        jQuery.extend(toastr.options, {\n          timeOut: 60000\n        });\n        toastr.error(gp_DOMPurify.sanitize(gp_translations.There_was_an_error_processing_the_Drive_Distance_request + ' ' + error));\n      });\n    });\n  }\n\n  return false;\n} // Take user to the location selected\n\n\nfunction gp_goToMyLocationWrapper(layer, zoom) {\n  if (zoom) {\n    var latLng = new google.maps.LatLng(layer.markerInfo.lat, layer.markerInfo.lng);\n    gp_map.panTo(latLng);\n\n    if (gp_getZoomLevel() < 13) {\n      gp_map.setZoom(13);\n    }\n  }\n}\n\nfunction gp_addToMyLocationsRightClick() {\n  //If the google javascript api is not loaded, load it for this search, and call this function again after it has loaded\n  if (typeof google == 'undefined') {\n    gp_loadGoogScript('gp_addToMyLocationsRightClick');\n    return false;\n  } //Create geocode request with lat and long for reverse geocode\n\n\n  var latlng = new google.maps.LatLng(rightClickLatLng.lat, rightClickLatLng.lng); //Do the reverse geocode\n\n  var geocoder = new google.maps.Geocoder();\n  geocoder.geocode({\n    latLng: latlng\n  }, function (results, status) {\n    if (status == google.maps.GeocoderStatus.OK) {\n      //Hide the right click context menu.\n      jQuery('#mapContextMenu').hide(); //Parse google geocode\n\n      var address = gp_parseGoogleGeocode(results[0]);\n      address.lat = rightClickLatLng.lat;\n      address.lng = rightClickLatLng.lng; //Add to location\n\n      gp_addToMyLocations(address);\n    } else {\n      alert(gp_DOMPurify.sanitize(gp_translations.Unable_to_add_location));\n\n      if (console && console.log) {\n        console.log(status);\n      }\n    }\n  });\n  const payload = {\n    action: 'trackRightClick',\n    data: {\n      action: 'Add to My Locations'\n    }\n  };\n  asyncGpEmitter('MixPanelService', payload);\n} //Function that adds an address to My Locations\n\n\nfunction gp_addAddressToMyLocations(event, name, street, city, state, postalCode, country, lat, lng) {\n  event.preventDefault(); // Prevent normal link behavior\n\n  var addressParts = [];\n  if (street) addressParts.push(street);\n  if (city) addressParts.push(city);\n  if (state) addressParts.push(state);\n  if (postalCode) addressParts.push(postalCode);\n  if (country) addressParts.push(country);\n  gp_addToMyLocations({\n    name: name,\n    singleLineAddress: addressParts.join(', '),\n    street: street,\n    city: city,\n    state: state,\n    postalCode: postalCode,\n    country: country,\n    lat: lat,\n    lng: lng\n  });\n}\n\nfunction gp_addToMyLocations(address, update) {\n  //Receives a parsed google address geocode\n  //Ask the user for a location name\n  var folderService = angular.element('.dataSetController').injector().get('folderService');\n  folderService.getFolders(function (folders) {\n    var saveFolderId = folderService.getPersonalFolder().id;\n    var buttonText = 'Save';\n\n    if (update) {\n      saveFolderId = address.folderId;\n      buttonText = 'Update';\n    }\n\n    var foldersHtml = '<a class=\"modal-style\" id=\"gp_myLocationFolderId\" data-id=\"' + saveFolderId + '\">' + folderService.getFolderNameById(saveFolderId) + '</a>';\n    var body = '<div class=\"gp-modal-content location-modal\">' + '<div class=\"location-modal-item modal-text-right\">' + '<div>' + 'Location Name ' + '</div>' + '<div>' + 'Folder ' + '</div>' + '<div>' + 'Address ' + '</div>' + '</div>' + '<div class=\"location-modal-item\">' + '<div>' + '<input id=\"newLocationName\" type=\"text\" value=\"' + address.name + '\" size=\"50\" style=\"width: 355px;\"/> ' + '</div>' + '<div class=\"location-modal-item-text\">' + foldersHtml + '</div>' + '<div class=\"location-modal-item-text\" title=\"' + address.singleLineAddress + '\">' + address.singleLineAddress + '</div>' + '</div>' + '</div>' + '<div class=\"gp-modal-footer\">' + '<input id=\"myLocationModalCancel\" type=\"button\" class=\"gp-btn btn-lg btn-primary modalButtonRight\" value=\"Cancel\"/>' + '<input id=\"myLocationModalSave\" type=\"button\" class=\"gp-btn btn-lg btn-primary modalButtonRight\" value=\"' + buttonText + '\"/>' + '<div class=\"clear\"></div>' + '</div>'; //Remove any existing save dialogs\n\n    jQuery('.gp_myLocationDialog').remove();\n    jQuery('<div class=\"gp_myLocationDialog\"></div>').append(gp_DOMPurify.sanitize(body)).dialog({\n      modal: true,\n      resizable: false,\n      draggable: false,\n      width: '515px',\n      title: gp_DOMPurify.sanitize(gp_translations.Save_Location),\n      dialogClass: 'dataSetEditModalWrapper gp-modal',\n      position: {\n        my: 'bottom',\n        at: 'center',\n        of: window\n      },\n      open: function open() {\n        setGPmodalContentHeight(jQuery(this)); //Create Enter event listner\n\n        jQuery('#newLocationName').keypress(function (e) {\n          if (e.keyCode == 13) {\n            //Click the first button in this modal, which is the OK button\n            jQuery('#myLocationModalSave').click();\n          }\n        }); // Save Button Click Listener\n\n        jQuery('#myLocationModalSave').click(function (e) {\n          var locationName = jQuery('#newLocationName').val();\n          var folderId = jQuery('#gp_myLocationFolderId').attr('data-id');\n\n          if (locationName) {\n            address.name = locationName;\n            address.folderId = folderId; //Convert the object to a JSON string\n\n            var locationJSON = JSON.stringify(address);\n            var dataSetControllerScope = angular.element('.dataSetController').scope();\n            dataSetControllerScope.locationsService.insertLocation(locationJSON).then(function (locations) {\n              dataSetControllerScope.locations = locations;\n              dataSetControllerScope.$digest();\n              dataSetControllerScope.$broadcast('folderListChanged');\n\n              if (address.id && gp_layers[address.id]) {\n                dataSetControllerScope.locationsService.clearLayer(address);\n                var marker = dataSetControllerScope.locationsService.createMarker(address);\n                dataSetControllerScope.locationsService.addLayer(marker);\n              } //Close this dialog\n\n\n              jQuery('.gp_myLocationDialog').remove();\n            }).catch(function (errMsg) {\n              gp_alert(gp_DOMPurify.sanitize(errMsg));\n            });\n          }\n        }); // Cancel Button Click Listener\n\n        jQuery('#myLocationModalCancel').click(function (e) {\n          jQuery('.gp_myLocationDialog').remove();\n        });\n      }\n    });\n    jQuery('#gp_myLocationFolderId').on('click', function () {\n      angular.element('#main-folder-list').scope().openFolderSelect().then(function (parentFolder) {\n        jQuery('#gp_myLocationFolderId').text(gp_DOMPurify.sanitize(parentFolder.name));\n        jQuery('#gp_myLocationFolderId').attr('data-id', parentFolder.id);\n      });\n    });\n  });\n} // Opens a jQuery Dialog with the record's related lists\n\n\nfunction gp_displayRelatedRecords(recordId, sfdcObject, recordTypeId) {\n  jQuery('#relatedListsDialog').remove();\n  let html = '';\n  let relatedLists = [];\n  let results;\n  let tmpDesc;\n  let layout = gp_userSettings.layouts[\"\".concat(sfdcObject, \"_\").concat(recordTypeId)];\n  let layoutId; // map of related lists that are black listed that shouldn't be shown\n  // e.g. Campaign related list on account object is not a direct relationship\n  // so the SOQL query as it stands would fail. We may look to fix this in\n  // the future.\n\n  const blackListedRelatedListMap = {\n    account: ['Campaign']\n  }; // Get layout\n\n  if (typeof layout === 'undefined') {\n    try {\n      // v31.0 and afterwards, if we include the recordId(s),\n      // then the describeLayout call doesn't work properly\n      tmpDesc = sforce.connection.describeLayout(sfdcObject);\n    } catch (e) {\n      toastr.error(gp_DOMPurify.sanitize(gp_translations.API_Access_is_not_enabled_for_your_user_account));\n      return;\n    }\n\n    if (typeof tmpDesc.layouts.id === 'string') {\n      // record types do not exist, just one layout returned\n      layout = tmpDesc.layouts;\n    } else {\n      // record types exist.  Need to loop through the mappings,\n      // then through the layouts to get the correct layout\n      for (const recordTypeMapping of tmpDesc.recordTypeMappings) {\n        if (recordTypeMapping.recordTypeId === recordTypeId) {\n          layoutId = recordTypeMapping.layoutId;\n          break;\n        }\n      }\n\n      if (typeof layoutId === 'undefined') {\n        toaster.error(gp_DOMPurify.sanitize(gp_translations.There_was_an_error_processing_your_request_If_this_issue) + ' <a href=\"mailto:help@geopointe.com\">help@geopointe.com</a>.<span notranslate> Error reference code GJS2009.</span>');\n        return;\n      }\n\n      for (const l of tmpDesc.layouts) {\n        if (l.id === layoutId) {\n          layout = l;\n          break;\n        }\n      }\n\n      if (typeof layout === 'undefined') {\n        toastr.error(gp_DOMPurify.sanitize(gp_translations.There_was_an_error_processing_your_request_If_this_issue) + ' <a href=\"mailto:help@geopointe.com\">help@geopointe.com</a>.<span notranslate> Error reference code GJS2021.</span>');\n        return;\n      }\n    }\n  }\n\n  try {\n    // Populate array of related lists\n    relatedLists = layout.getArray('relatedLists').filter(relatedList => {\n      var _gp_userSettings$user, _blackListedRelatedLi;\n\n      if ((gp_userSettings === null || gp_userSettings === void 0 ? void 0 : (_gp_userSettings$user = gp_userSettings.userInfo) === null || _gp_userSettings$user === void 0 ? void 0 : _gp_userSettings$user.userLicenseName) === 'Salesforce Platform') {\n        if (relatedList.sobject === 'OpenActivity' || relatedList.sobject === 'ActivityHistory') {\n          return false;\n        }\n      }\n\n      if ((_blackListedRelatedLi = blackListedRelatedListMap[sfdcObject]) !== null && _blackListedRelatedLi !== void 0 && _blackListedRelatedLi.includes(relatedList.sobject)) {\n        return false;\n      }\n\n      return true;\n    }); // List the array into smaller arrays of 20 each as we can only query 20 related lists at a time\n\n    const arrayOfRelatedListArrays = _.chunk(relatedLists, 20); // Generate SOQL for each set of 20 related lists\n\n\n    const soqlArray = [];\n    const regexTic = /'/g;\n    const regexSpace = /'/g;\n    arrayOfRelatedListArrays.forEach(rls => {\n      let soql = 'SELECT Id';\n\n      _.forEach(rls, rl => {\n        let fields = [];\n        let columns = rl.getArray('columns');\n\n        if (columns.length === 0) {\n          return;\n        }\n\n        soql += ', (SELECT ';\n        columns.forEach((value, key) => {\n          if (key > 0) {\n            soql += ',';\n          } //__c. replacement is for describe bug http://success.salesforce.com/issues_view?id=a1p30000000SYkZAAW\n\n\n          soql += value.name.replace('__c.', '__r.'); // Escape single quotes and eliminate spaces\n\n          fields.push(value.name.replace(regexTic, \"\\\\'\").replace(regexSpace, ''));\n        });\n\n        if (Array.isArray(fields) && !fields.includes('Id') && fields.length) {\n          soql += ',Id';\n        } else {\n          return;\n        }\n\n        if (rl.sobject === 'AccountContactRelation') {\n          soql += ',ContactId,AccountId';\n        } else if (rl.sobject === 'AccountTeamMember') {\n          soql += ',UserId';\n        } else if (rl.sobject === 'OpportunityContactRole') {\n          soql += ',ContactId';\n        } // Escape single quotes and eliminate spaces\n\n\n        soql += ' FROM ' + rl.name.replace(regexTic, \"\\\\'\").replace(regexSpace, '');\n\n        if (rl.sobject === 'OpenActivity') {\n          soql += ' ORDER BY ActivityDate ASC, LastModifiedDate DESC';\n        } else if (rl.sobject === 'ActivityHistory') {\n          soql += ' ORDER BY ActivityDate DESC, LastModifiedDate DESC';\n        } else {\n          rl.getArray('sort').forEach((value, key) => {\n            if (key === 0) {\n              soql += ' ORDER BY ';\n            } else {\n              soql += ',';\n            } // Escape single quotes and eliminate spaces\n\n\n            soql += value.column.replace(regexTic, \"\\\\'\").replace(regexSpace, '');\n\n            if (value.ascending === 'true') {\n              soql += ' ASC';\n            } else {\n              soql += ' DESC';\n            }\n          });\n        }\n\n        soql += ' LIMIT 11)';\n      }); // Escape single quotes and eliminate spaces\n\n\n      soql += ' FROM ' + sfdcObject.replace(regexTic, \"\\\\'\").replace(regexSpace, '') + \" WHERE Id ='\" + recordId.replace(regexTic, \"\\\\'\").replace(regexSpace, '') + \"' LIMIT 1\";\n      soqlArray.push(soql);\n    }); // Tab markup\n\n    if (arrayOfRelatedListArrays.length === 0) {\n      html += gp_DOMPurify.sanitize(gp_translations.This_record_has_no_related_data_on_its_Page_Layout);\n    } else {\n      // Query the related lists\n      soqlArray.forEach(soql => {\n        if (!results) {\n          // First query\n          results = sforce.connection.query(soql);\n        } else {\n          // Subsequent queries, add results to original result object\n          const res = sforce.connection.query(soql);\n          Object.assign(results.records, res.records);\n        }\n      });\n      let lis = \"\";\n      let divs = \"\";\n      html += \"<div id=\\\"relatedListsTabs\\\" style=\\\"display: none; font-size: 9pt; font-family: Arial;\\\"><ul notranslate>\";\n      relatedLists.forEach((relatedList, index) => {\n        lis += \"<li data-gptabindex=\\\"\".concat(index, \"\\\"><a href=\\\"#relatedListsTabs-\").concat(index + 1, \"\\\">\").concat(gp_DOMPurify.sanitize(relatedList.label), \"</a></li>\");\n        divs += \"<div id=\\\"relatedListsTabs-\".concat(index + 1, \"\\\"></div>\");\n      });\n      html += \"\".concat(lis, \"</ul>\").concat(divs, \"</div>\");\n    }\n  } catch (e) {\n    html = \"<p>\".concat(gp_DOMPurify.sanitize(gp_translations.There_was_an_error_processing_your_request_If_this_issue), \"<a href=\\\"mailto:help@geopointe.com\\\">help@geopointe.com</a>.</p>\");\n\n    if (console && console.log) {\n      console.log('*** ERROR: ', e);\n    }\n  }\n\n  let url = ''; // Add url prefix, typically for Communities if it is present\n\n  if (gp_orgSettings.urlPrefix) {\n    url = gp_orgSettings.urlPrefix + '/' + recordId;\n  } else {\n    url = '/' + recordId;\n  }\n\n  jQuery('<div id=\"relatedListsDialog\" class=\"pbBody\"></div>').append(html) // html is already sanitized\n  .append(gp_DOMPurify.sanitize(\"<p style=\\\"margin: 10px; font-size: .9em;\\\" >\\n\\t\\t\\t<img src=\\\"\".concat(gpImg.link_newwindow, \"\\\"/>&nbsp;\\n\\t\\t\\t<a href=\\\"\").concat(url, \"\\\" target=\\\"_blank\\\" style=\\\"cursor:pointer; text-decoration:underline;\\\">\").concat(gp_translations.Go_to_Parent_Record, \"</a>\\n\\t\\t</p>\"))).append(gp_DOMPurify.sanitize('<p style=\"margin: 0 10px; font-size: .8em; font-style: italic;\" >' + gp_translations.The_tabs_and_fields_shown_here_are_driven_by_the_configuration + '</p>')).dialog({\n    modal: true,\n    draggable: true,\n    width: '1000px',\n    position: {\n      my: 'center top-250',\n      at: 'center',\n      of: window\n    },\n    title: 'Related Data',\n    buttons: {\n      Close: function Close() {\n        jQuery(this).dialog('close');\n      }\n    },\n    open: function open(event, ui) {\n      jQuery('#relatedListsTabs').tabs({\n        selected: 0,\n        create: function create(event, ui) {\n          loadTabContent(ui.tab, ui.panel);\n        },\n        activate: function activate(event, ui) {\n          loadTabContent(ui.newTab, ui.newPanel);\n        }\n      });\n      jQuery('#relatedListsTabs').show();\n    }\n  });\n\n  function loadTabContent(tab, panel) {\n    if (!jQuery(panel).html() == '') return false;\n\n    try {\n      var rl = relatedLists[jQuery(tab).attr('data-gptabindex')];\n      var html = '';\n      var noResultsText = gp_translations.No_records_were_found;\n      var records = [];\n      var labels = [];\n      var fields = [];\n      var formats = [];\n      jQuery.each(rl.getArray('columns'), function (key, value) {\n        labels.push(value.label);\n        fields.push(value.name);\n        formats.push(value.format);\n      });\n\n      if (results.records[rl.name] != null) {\n        records = results.records[rl.name].getArray('records');\n      }\n\n      html += '<table width=\"100%\" class=\"list display\"><thead><tr class=\"headerRow\">';\n      jQuery.each(labels, function (key, value) {\n        html += '<th class=\"dataCell\"><b>' + gp_cleanStringForHTML(value) + '</b></th>';\n      });\n      html += '</tr></thead><tbody>';\n\n      if (records.length > 0) {\n        var langTag = gp_getUsersLangTag();\n        jQuery.each(records, function (key, value) {\n          html += '<tr class=\"dataRow\">';\n          jQuery.each(fields, function (key2, value2) {\n            //__c. replacement is for describe bug http://success.salesforce.com/issues_view?id=a1p30000000SYkZAAW\n            value2 = value2.replace('toLabel', '').replace('convertCurrency', '').replace('(', '').replace(')', '').replace('__c.', '__r.');\n\n            try {\n              var linkKey = 0;\n              var linkVal = value.Id;\n\n              if (rl.sobject == 'NoteAndAttachment') {\n                linkKey = 1;\n              }\n\n              if (rl.sobject == 'AccountContactRelation' && sfdcObject == 'account') {\n                linkVal = value.ContactId;\n              }\n\n              if (rl.sobject == 'AccountContactRelation' && sfdcObject == 'contact') {\n                linkVal = value.AccountId;\n              }\n\n              if (rl.sobject == 'AccountTeamMember') {\n                linkVal = value.UserId;\n              }\n\n              if (rl.sobject == 'OpportunityContactRole') {\n                linkVal = value.ContactId;\n              }\n\n              if (rl.sobject == 'OpportunityCompetitor' || rl.name.indexOf('Histories') != -1 || rl.sobject == 'EmailStatus' || rl.sobject == 'ProcessInstanceHistory') {\n                linkKey = 1000;\n              }\n\n              if (rl.sobject == 'ActivityHistory') {\n                linkKey = 0;\n              }\n\n              var tmp = '<td class=\"dataCell\">';\n              let reletatedRecordVal = value[value2];\n\n              if (!reletatedRecordVal && typeof value2 === 'string') {\n                reletatedRecordVal = getDescendantProp(value, value2);\n              }\n\n              if (typeof reletatedRecordVal === 'undefined' || reletatedRecordVal == null) {\n                tmp += '&nbsp;';\n              } else {\n                if (key2 == linkKey) {\n                  tmp += '<a href=\"/' + gp_DOMPurify.sanitize(linkVal) + '\" target=\"_blank\" style=\"cursor:pointer; text-decoration:underline;\">';\n                }\n\n                tmp += gp_displayRelatedRecordsValue(gp_cleanStringForHTML(gp_DOMPurify.sanitize(reletatedRecordVal)), formats[key2], langTag);\n\n                if (key2 == linkKey) {\n                  tmp += '</a>';\n                }\n              }\n\n              tmp += '</td>';\n              html += tmp;\n            } catch (e) {\n              html += '<td class=\"dataCell\">&nbsp;</td>';\n            }\n          });\n          html += '</tr>';\n        });\n      } else {\n        html += gp_DOMPurify.sanitize('<tr><td colspan=\"' + labels.length + '\">' + noResultsText + '</td></tr>');\n      }\n\n      html += '</tbody></table>';\n\n      if (records.length > 10) {\n        html += gp_DOMPurify.sanitize(\"<p>\".concat(gp_translations.There_are_more_related_records_than_displayed_here, \"<br/><br/><a href=\\\"/\").concat(recordId, \"\\\" target=\\\"_blank\\\">View Parent Record</a></p>\"));\n      }\n\n      jQuery(panel).html(html); // SECURITY: html is already sanitized\n    } catch (e) {\n      console.log(e);\n      jQuery(panel).html('<p>' + gp_DOMPurify.sanitize(gp_translations.Error_loading_related_data) + '</p>');\n    }\n  }\n}\n\nfunction gp_getUsersLangTag() {\n  var rv = 'en';\n  if (gp_userSettings && gp_userSettings.userInfo && gp_userSettings.userInfo.locale) // The userInfo locale will hold the SF formatted language info, e.g. en_US.  We'll try to convert it to a standard language tag, e.g. en-US\n    rv = gp_userSettings.userInfo.locale.replace(/_/g, '-');else if (navigator.language) rv = navigator.language;else if (navigator.browserLanguage) rv = navigator.browserLanguage;else return 'en'; // default to English\n\n  try {\n    new Date().toLocaleString(rv);\n    return rv;\n  } catch (e) {\n    return 'en'; // default to English\n  }\n}\n\nfunction gp_displayRelatedRecordsValue(val, format, langTag) {\n  if (val.indexOf('http') == 0 || val.indexOf('https') == 0) {\n    //Starts with http/s\n    return gp_DOMPurify.sanitize(\"<a href=\\\"\".concat(val, \"\\\" target=\\\"_blank\\\">\").concat(val, \"</a>\"));\n  }\n\n  if (val.startsWith('&lt;')) {\n    return jQuery('<span>').html(val).text();\n  }\n\n  if (val == 'true') {\n    return \"<img src='\" + gp_DOMPurify.sanitize(gpImg.checkbox_checked) + \"' alt='true' />\";\n  }\n\n  if (val == 'false') {\n    return \"<img src='\" + gp_DOMPurify.sanitize(gpImg.checkbox_unchecked) + \"' alt='false' />\";\n  }\n\n  if (format == 'date') {\n    // Salesforce SOAP API returns the format of date for datetime fields, check of the value is a dateTime and do the dateTime formatting instead of the date formatting.\n    const isoDateTime = /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/;\n\n    if (val.match(isoDateTime)) {\n      const dateTime = sforce.internal.stringToDateTime(val);\n      return \"\".concat(dateTime.toLocaleDateString(langTag), \" \").concat(dateTime.toLocaleTimeString(langTag));\n    }\n\n    return sforce.internal.stringToDate(val).toLocaleDateString(langTag);\n  }\n\n  if (format == 'datetime') {\n    const dateTime = sforce.internal.stringToDateTime(val);\n    return \"\".concat(dateTime.toLocaleDateString(langTag), \" \").concat(dateTime.toLocaleTimeString(langTag));\n  }\n\n  return val;\n} // Initializes a color picker\n\n\nfunction gp_initColorPicker(id, type) {\n  jQuery(type + '[id*=\"' + id + '\"]').minicolors({\n    defaultValue: '#1797C0',\n    letterCase: 'uppercase',\n    theme: 'geopointe',\n    changeDelay: 200,\n    change: function change(hex, opacity) {\n      //Special handling for map page to keep the two color inputs in sync\n      if (jQuery(this).attr('id') == 'editDataSetColor') {\n        jQuery(\"input[id$='gp_selectedcolor']\").minicolors('destroy').attr('maxlength', 7);\n        jQuery(\"input[id$='gp_selectedcolor']\").val(jQuery('#editDataSetColor').val());\n        gp_initColorPicker('gp_selectedcolor', 'input');\n      } else {\n        jQuery('#editDataSetColor').minicolors('destroy').attr('maxlength', 7);\n        jQuery('#editDataSetColor').val(jQuery(\"input[id$='gp_selectedcolor']\").val());\n        gp_initColorPicker('editDataSetColor', 'input');\n      }\n    }\n  });\n} //Function called to reset certain variables whenever a user many adjusts the position of the map\n\n\nfunction gp_mapManualMove() {//gp_centerPointKeepAddress = false;\n}\n/*************************\n * MixPanel\n *************************/\n\n\nfunction __MIXPANEL_FUNCTIONS__() {} // gp_trackChangeOwner, gp_trackPardotEngage, gp_trackAddToCampaign, gp_trackUpdateField\n// kept as standalone functions as they are used in list actions and can't easily\n// be refactored - when list actions moves to new angular action.service these\n// will be able to be removed and the angular mixpanel.service can be used for these event\n// tracking calls.\n\n\nfunction gp_trackChangeOwner() {\n  gp_track('Change Owner', {\n    Selection: document.getElementById('applyActionTo').value\n  });\n}\n\nfunction gp_trackPardotEngage() {\n  gp_track('Pardot Engage', {\n    Selection: document.getElementById('applyActionTo').value\n  });\n}\n\nfunction gp_trackAddToCampaign() {\n  gp_track('Add To Campaign', {\n    Selection: document.getElementById('applyActionTo').value\n  });\n}\n\nfunction gp_trackUpdateField() {\n  gp_track('Update Field', {\n    Selection: document.getElementById('applyActionTo').value\n  });\n}\n/**\n * Data Layer related tracking left for now - should remove when we\n * remove all data layer related code (GP-971)\n */\n\n\nfunction gp_trackDataLayerSearch(dataLayer, searchType, hasCredits) {\n  var humanReadableSearchTypes = {\n    all: 'Entire Data Layer',\n    nearbyRadial: 'Nearby Radial',\n    nearbyShape: 'Nearby Shape',\n    bounds: 'Viewable Area',\n    shape: 'Shape'\n  };\n  var trackObject = {};\n  trackObject['Search Type'] = humanReadableSearchTypes[searchType];\n  trackObject['Layer Type'] = dataLayer.label;\n  trackObject['Number of Filters'] = dataLayer.filters.length;\n  trackObject['Number of Open Data Layer Searches'] = _.filter(gp_layers, ['type', 'dataLayer']).length;\n  trackObject['Has Credits'] = hasCredits;\n\n  if (dataLayer.markerType === 'dynamic') {\n    trackObject['Color Markers'] = _.find(dataLayer.fields, ['value', dataLayer.colorByField]).label;\n  }\n\n  if (searchType === 'bounds') {\n    trackObject['Zoom Level'] = gp_getZoomLevel();\n  }\n\n  if (searchType === 'nearbyRadial' || searchType === 'nearbyShape') {\n    trackObject.Range = jQuery(\"input[id$='radialSearchRange']\").val();\n    trackObject.Units = jQuery(\"select[id$='radialSearchUnit']\").val();\n  }\n\n  gp_track('Map Data Layer Search', trackObject);\n}\n\nfunction gp_trackDataLayerModalOpen(hasCredits) {\n  gp_track('Open Data Layer Import', {\n    'Has Credits': hasCredits\n  });\n}\n\nfunction gp_trackDataLayerImport(dataLayerLabel, sfdcObject, numImported) {\n  gp_track('Data Layer Import', {\n    'Layer Type': dataLayerLabel,\n    'Target Object': sfdcObject,\n    'Import Count': numImported\n  });\n}\n\nfunction gp_track(evt, eventData) {\n  const payload = {\n    action: 'track',\n    data: {\n      event: evt,\n      eventData\n    }\n  };\n  asyncGpEmitter('MixPanelService', payload);\n}\n/*************************\n * DOM functions\n *************************/\n\n\nfunction __UTIL_FUNCTIONS__() {}\n\nif (typeof String.prototype.startsWith !== 'function') {\n  String.prototype.startsWith = function (prefix) {\n    return this.indexOf(prefix) === 0;\n  };\n}\n\nif (typeof String.prototype.endsWith !== 'function') {\n  String.prototype.endsWith = function (suffix) {\n    return this.indexOf(suffix, this.length - suffix.length) !== -1;\n  };\n}\n\nObject.getSize = function (obj) {\n  var size = 0,\n      key;\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) size++;\n  }\n\n  return size;\n};\n\nfunction gp_milesToMeters(miles) {\n  return miles * 1.609 * 1000;\n}\n\nfunction gp_kmToMeters(km) {\n  return km * 1000;\n}\n\nfunction gp_addCommasToNumber(nStr) {\n  nStr += '';\n  x = nStr.split('.');\n  x1 = x[0];\n  x2 = x.length > 1 ? '.' + x[1] : '';\n  var rgx = /(\\d+)(\\d{3})/;\n\n  while (rgx.test(x1)) {\n    x1 = x1.replace(rgx, '$1' + ',' + '$2');\n  }\n\n  return x1 + x2;\n} // Encode and Decode HTML functions TODO perf, really slow\n\n\nfunction gp_htmlDecode(value) {\n  return gp_DOMPurify.sanitize(jQuery('<div/>').html(value).text());\n}\n\nfunction gp_cleanStringForHTML(str) {\n  if (typeof str == 'undefined') {\n    return '';\n  }\n\n  var retVal = str + '';\n  return retVal.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#039;');\n}\n\nfunction gp_uncleanStringForHTML(str) {\n  if (typeof str == 'undefined') {\n    return '';\n  }\n\n  var retVal = str + '';\n  return retVal.replace(/&amp;/gi, '&').replace(/&lt;/gi, '<').replace(/&gt;/gi, '>').replace(/&quot;/gi, '\"').replace(/&#039;/gi, \"'\");\n}\n\nfunction gp_cleanNewLines(str) {\n  if (typeof str == 'undefined') {\n    return '';\n  }\n\n  var retVal = str + '';\n  return retVal.replace(/\\n/gi, ' ').replace(/\\r/gi, ' ');\n} // Presses the button passed into the function when the enter key is pressed\n\n\nfunction gp_DoClick(event, buttonName) {\n  event = event || window.event;\n\n  if (event.keyCode == 13 || event.which == 13) {\n    var btn = document.getElementById(buttonName);\n\n    if (btn != null) {\n      btn.click();\n      gp_stopSubmit = true; // stop the submit action from taking place\n    }\n\n    return false;\n  }\n\n  return true;\n}\n/*************************\n * Custom Ajax Modal methods\n *************************/\n\n/**\n * creates loading modal\n * @param {string} selector query selector string for the element. This is where we will creat the modal over.\n * @param {string} title loading message to display. defaults to Loading...\n */\n\n\nfunction geopointeAjaxStart(selector) {\n  let title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Loading...';\n  const isBody = selector === 'body'; //Find the element where the modal box should go inside of\n\n  const container = document.querySelector(selector); //Get the width of the container\n\n  const containerWidth = getOuterWidth(container); // Set the height to 100% of the parent\n\n  let containerHeight = '100%'; // If container is body make height of modal the entire document\n  // 100% does not cover the whole body so we need to get the height in px\n\n  if (isBody) {\n    containerHeight = \"\".concat(document.body.scrollHeight, \"px\");\n  }\n\n  const modalDiv = document.createElement('div');\n  modalDiv.classList.add('geopointeAjaxModal');\n  modalDiv.style.height = containerHeight;\n  modalDiv.style.width = \"\".concat(containerWidth, \"px\");\n  modalDiv.style.top = isBody ? 0 : container.offsetTop;\n  modalDiv.style.left = isBody ? 0 : container.offsetLeft;\n  container.insertBefore(modalDiv, container.firstChild); //Create a div that has the image loading icon and supplied text\n\n  let spinner = \"\\n       <div class=\\\"geopointeAjaxTitle\\\">\\n        \".concat(title, \"\\n        </div>\\n        <div class=\\\"spinner-container slds-is-relative\\\">\\n          <div role=\\\"status\\\" class=\\\"slds-spinner slds-spinner_small slds-spinner_brand\\\">\\n            <span class=\\\"slds-assistive-text\\\">Loading</span>\\n            <div class=\\\"slds-spinner__dot-a\\\"></div>\\n            <div class=\\\"slds-spinner__dot-b\\\"></div>\\n          </div>\\n        </div>\\n        <div class=\\\"geopointeAjaxImgPercent\\\"></div>\\n     \");\n\n  if (typeof gp_DOMPurify !== 'undefined') {\n    spinner = gp_DOMPurify.sanitize(spinner);\n  }\n\n  const modalImg = document.createElement('div');\n  modalImg.classList.add('geopointeAjaxStatus', 'slds-scope');\n  modalImg.innerHTML = spinner;\n  container.insertBefore(modalImg, container.firstChild);\n  const css = {\n    position: 'absolute',\n    top: 'calc(50% - 75px)',\n    left: \"calc(50% - \".concat(getOuterWidth(modalImg, true) / 2, \"px)\")\n  };\n\n  if (isBody) {\n    css.position = 'fixed';\n  }\n\n  Object.entries(css).forEach(_ref => {\n    let [prop, value] = _ref;\n    return modalImg.style[prop] = value;\n  });\n  return true;\n  /**\n   * Get the outer width of an element\n   * @param {HTMLElement} el element to get the outerwidth for\n   * @param {boolean} includeMargin include margin in the calculation. defaults to false\n   */\n\n  function getOuterWidth(el) {\n    let includeMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let width = el.offsetWidth;\n\n    if (includeMargin) {\n      const style = getComputedStyle(el);\n      width += parseInt(style.marginLeft) + parseInt(style.marginRight);\n    }\n\n    return width;\n  }\n}\n/**\n * removes the loading modal that geopointeAjaxStart creates\n */\n\n\nfunction geopointeAjaxEnd() {\n  document.querySelectorAll('.geopointeAjaxStatus').forEach(div => div.parentNode.removeChild(div));\n  document.querySelectorAll('.geopointeAjaxModal').forEach(div => div.parentNode.removeChild(div));\n  return true;\n}\n/**\n * Updates the loading message in the loading modal\n * @param {string} val new title to update the loading message to\n */\n\n\nfunction geopointeAjaxUpdateTitle(val) {\n  const elm = document.querySelector('.geopointeAjaxTitle');\n\n  if (elm) {\n    elm.textContent = gp_DOMPurify ? gp_DOMPurify.sanitize(val) : val;\n  }\n}\n\nfunction gp_updateDataSearchesObject(jsAction) {\n  //Only proceed if there is a poiCollection\n  if (jsAction.poiCollections.length > 0) {\n    var removeAllShapes = false;\n\n    for (var i = 0; i < jsAction.poiCollections.length; i++) {\n      if (jsAction.poiCollections[i].removeAllShapes == true) {\n        removeAllShapes = true;\n      }\n    } //If clear existing box is checked wipe out the gp_dataSetSearches object\n\n\n    if (removeAllShapes == true) {\n      //Clear out the data set searches\n      for (const key in gp_dataSetSearches) {\n        gp_dataSetSearches[key].markerClusterer.clearMarkers();\n      }\n\n      gp_dataSetSearches = {};\n    }\n\n    for (var i = 0; i < jsAction.poiCollections.length; i++) {\n      var poic = jsAction.poiCollections[i]; //Only create layer if there was more than one POI\n\n      if (poic.searchContext && poic.searchContext.options && poic.searchContext.options.isAutoRefresh || poic.POIs && poic.POIs.length > 0) {\n        //Add a record to the gp_dataSetSearches with key as collection name\n        const dataSetSearch = {\n          dsId: jsAction.dsId,\n          objectName: poic.sfdcObject,\n          searchType: poic.searchType,\n          searchRadius: poic.searchNearbyRange,\n          units: poic.distanceUnits,\n          nearbySearchUnits: jsAction.nearbySearchUnits,\n          nearbySearchDistanceUnits: jsAction.nearbySearchDistanceUnits,\n          nearbySearchTime: jsAction.nearbySearchTime,\n          numOfRecords: poic.POIs ? poic.POIs.length : 0,\n          markerType: 'marker',\n          isGroup: poic.searchContext ? poic.searchContext.isGroup : poic.groupLoad,\n          currentMarkerMetaData: null,\n          originalMarkerMetaData: null,\n          layerSettings: {}\n        };\n\n        if (poic.searchContext) {\n          if (poic.searchContext.options) {\n            dataSetSearch.radialCenterLat = poic.searchContext.options.radialCenterLat;\n            dataSetSearch.radialCenterLng = poic.searchContext.options.radialCenterLng;\n            dataSetSearch.refreshInterval = poic.searchContext.options.refreshInterval;\n            dataSetSearch.refreshId = poic.searchContext.options.refreshId;\n\n            if (poic.searchContext.options.layerSettings) {\n              dataSetSearch.layerSettings = poic.searchContext.options.layerSettings;\n            }\n          }\n        }\n\n        dataSetSearch.name = poic.ds ? poic.ds['name'] : poic.dataSetName; //Initiate a marker cluser object for this data set search\n\n        dataSetSearch.markerClusterer = new MarkerClusterer(gp_map, null, {\n          zoomOnClick: false,\n          imagePath: markerClustererPlusIcons\n        }); //Add click even listener when a cluster icon is clicked\n\n        google.maps.event.addListener(dataSetSearch.markerClusterer, 'click', function (c) {\n          gp_closeInfoWindow(false);\n          angular.element('.legendController').scope().buildClusterInfoWindowHtml(c.getMarkers(), c.getCenter().lat(), c.getCenter().lng());\n        });\n        if (poic.columnLabels) dataSetSearch.columnLabels = _.cloneDeep(poic.columnLabels);\n\n        if (poic.qo) {\n          dataSetSearch.qo = poic.qo;\n        }\n\n        if (poic.dataSetObject && poic.dataSetObject.markerMetaData) {\n          dataSetSearch.originalMarkerMetaData = _.cloneDeep(poic.dataSetObject.markerMetaData);\n          dataSetSearch.currentMarkerMetaData = _.cloneDeep(poic.dataSetObject.markerMetaData);\n        }\n\n        dataSetSearch.icon = poic.mapIconURL;\n\n        if (poic.ds) {\n          if (poic.ds['markerType'] == 'dynamic') {\n            dataSetSearch.icon = 'multi';\n          }\n\n          if (poic.ds.searchContext) {\n            dataSetSearch.searchContext = poic.ds.searchContext;\n          }\n\n          if (poic.ds.labelByField && poic.ds.labelByField.field) dataSetSearch.labelMarkersByField = poic.ds.labelByField;\n        }\n\n        gp_dataSetSearches[poic.collectionName] = dataSetSearch;\n      }\n    }\n  }\n}\n\nfunction gp_getTablesToProcess(args) {\n  var disableAlerts = args && args.disableAlerts;\n  var applyAllTables = args && args.applyAllTables; //Based on the apply action to select list (selected tab or all tabs) return correct jQuery selection\n  //First make sure there are tabs displayed\n\n  const $tabs = document.querySelector('.dataSetResultTableTab');\n\n  if (!applyAllTables && !$tabs) {\n    if (!disableAlerts) {\n      toastr.error('Please perform a Data Set search before applying this action');\n    }\n\n    return []; //Return empty array\n  } else if (applyAllTables || jQuery('#applyActionTo').val() == 'allTabs' || jQuery('#applyActionTo').val() == 'selectedRecords') {\n    //Return all the tables that the user has not removed from the map\n    var tables = []; //Loop through all of the tabs and check to see it it has been removed from the map\n\n    jQuery('.dataSetResultTableTab').each(function () {\n      var collectionName = jQuery(this).attr('data-collectionName'); //If tab is not hidden from the map add the table to list of those that should be returned\n\n      if (applyAllTables || jQuery(this).find('.poiCollectionTabLabel').hasClass('tabDataHidden') == false) {\n        tables.push(jQuery('#' + collectionName));\n      }\n    }); //If there where no visible tabs, show an alert\n\n    if (tables.length == 0) {\n      if (!disableAlerts) {\n        alert(gp_DOMPurify.sanitize(gp_translations.There_must_be_Data_Sets_visible_on_the_map + '\\n\\n' + gp_translations.Select_the_Show_Data_Set_button));\n      }\n\n      return tables;\n    } else {\n      return tables;\n    }\n  } else {\n    //Find the current tab that has it's content displayed and visible\n    var selectedDataSetResultTable = jQuery('.dataSetResultTableTabContent:visible').find('table.gp_dataTable:visible');\n\n    if (selectedDataSetResultTable.length == 0) {\n      if (!disableAlerts) {\n        alert(gp_DOMPurify.sanitize(gp_translations.This_action_could_not_be_applied_to_the_selected_tab + '\\n\\n' + gp_translations.If_this_is_a_Data_Set_search_tab_please_ensure));\n      }\n\n      return []; //Return empty array\n    } else {\n      return [selectedDataSetResultTable];\n    }\n  }\n}\n\nfunction gp_getRowDataFromTables() {\n  const tables = gp_getTablesToProcess();\n  let rowData = [];\n  tables.forEach(table => {\n    //Use the column info object attached to the data table as each table could have different number of columns\n    const gp_ColumnInfo = jQuery(table).data('columnInfo'); // Get the Table Data\n\n    const aoData = jQuery(table).dataTable().fnGetData(); // Loop through the rows and populate list of recordIds, and object that store recordId to objectname\n\n    rowData = rowData.concat(aoData.map(rowData => {\n      const recordId = rowData[gp_ColumnInfo.recordId];\n      const uniqueId = rowData[gp_ColumnInfo.uniqueId];\n      return {\n        recordId,\n        uniqueId\n      };\n    }));\n  });\n  return rowData;\n}\n\nfunction gp_getMarkersFromTables(shapeId) {\n  let ids = [];\n\n  if (shapeId) {\n    ids = extractIdsInShape(shapeId);\n  }\n\n  const applyTo = jQuery('#applyActionTo').val();\n  return gp_getRowDataFromTables().filter(_ref2 => {\n    let {\n      uniqueId\n    } = _ref2;\n    const marker = gp_markers[uniqueId];\n    if (!marker) return false; // If marker is hidden by the legend skip it\n\n    if (marker.hiddenByLegend == true) {\n      return false;\n    } // If from csv layer filter them out\n\n\n    const {\n      searchType\n    } = gp_dataSetSearches[marker.collectionName] || {};\n\n    if (searchType && searchType === window.gpCsv) {\n      return false;\n    } // if we are removing items from a shape, filter those not in out\n\n\n    if (shapeId) {\n      if (!ids.includes(marker.recordId)) {\n        return false;\n      }\n    } else {\n      // only remove the selected records, filter them out\n      if (applyTo === 'selectedRecords') {\n        if (!gp_selectedRecords[uniqueId]) return false;\n      }\n    }\n\n    return true;\n  }).map(_ref3 => {\n    let {\n      uniqueId\n    } = _ref3;\n    return gp_markers[uniqueId];\n  });\n} //PageMessage is a class in Mapping.cls\n// SECURITY: Returns sanitized html string\n\n\nfunction buildMessageHTML(pageMessages) {\n  //Build object of severity to array of messages\n  var messagesByType = {};\n\n  for (var i = 0; i < pageMessages.length; i++) {\n    messagesByType[pageMessages[i].severity] = new Array();\n  }\n\n  for (var i = 0; i < pageMessages.length; i++) {\n    messagesByType[pageMessages[i].severity].push(pageMessages[i].message);\n  }\n\n  var html = '';\n\n  for (var key in messagesByType) {\n    //Determine the type of error message\n    var type = key;\n    if (type.toLowerCase() == 'fatal') type = 'error'; //Build out the message HTML\n\n    var message = '';\n\n    if (messagesByType[key].length == 1) {\n      message = messagesByType[key][0];\n    } else {\n      message = '<ul style=\"padding-left:10px;padding-top:0px;margin:0px\">';\n\n      for (var i = 0; i < messagesByType[key].length; i++) {\n        message += '<li style=\"padding-top:5px\">' + messagesByType[key][i] + '</li>';\n      }\n\n      message += '</ul>';\n    }\n\n    var messageHTML = '' + '<div class=\"message ' + gp_DOMPurify.sanitize(type.toLowerCase()) + 'M3\">' + '<button class=\"hideErrorMessage\" type=\"button\" onclick=\"updatePageMessages([]);\">Ã—</button>' + '<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"messageTable\" style=\"padding:0px;margin:0px;\">' + '<tbody>' + '<tr valign=\"top\">' + '<td><img alt=\"INFO\" class=\"msgIcon\" src=\"/s.gif\" title=\"INFO\" /></td>' + '<td class=\"messageCell\">' + '<div class=\"messageText\">' + gp_DOMPurify.sanitize(message) + '</div>' + '</td>' + '</tr>' + '<tr>' + '<td></td>' + '<td>' + '</td>' + '</tr>' + '</tbody>' + '</table>' + '</div>';\n    html += messageHTML;\n  } // SECURITY: html sanitized during construction above\n\n\n  return html;\n} //http://stackoverflow.com/questions/901115/how-can-i-get-query-string-values, answer: http://stackoverflow.com/a/2880929/965897\n\n\nfunction getURLparams(queryOverride) {\n  var urlParams;\n\n  var match,\n      pl = /\\+/g,\n      // Regex for replacing addition symbol with a space\n  search = /([^&=]+)=?([^&]*)/g,\n      decode = function decode(s) {\n    return decodeURIComponent(s.replace(pl, ' '));\n  },\n      query = window.location.search.substring(1);\n\n  if (typeof queryOverride != 'undefined') {\n    query = queryOverride;\n  }\n\n  urlParams = {};\n\n  while (match = search.exec(query)) {\n    urlParams[decode(match[1])] = decode(match[2]);\n    urlParams[decode(match[1]).toLowerCase()] = decode(match[2]);\n  }\n\n  return urlParams;\n} //http://stackoverflow.com/questions/18251399/why-doesnt-encodeuricomponent-encode-sinlge-quotes-apostrophes\n\n\nfunction gp_urlEncode(str) {\n  return encodeURIComponent(str).replace(/[!'()*]/g, escape);\n}\n\nfunction gp_loadGoogScript(callback) {\n  var script = document.createElement('script');\n  script.type = 'text/javascript';\n  script.src = googJSsrc + '&callback=' + callback;\n  document.body.appendChild(script);\n}\n\nfunction gp_doPlaceSearch() {\n  var plcCtr = angular.element('.placesSearchController').scope();\n\n  if (plcCtr && plcCtr.doSearch) {\n    plcCtr.doSearch();\n  }\n} // Combines color, icon and text strings into a marker URL\n// SECURITY: Returns sanitized string\n\n\nfunction gp_composeMarkerUrl(markerColor, markerIcon, markerText) {\n  var markerUrl;\n\n  if (markerIcon && markerIcon.startsWith('http') && !markerIcon.startsWith(GEOPOINTE_API)) {\n    // custom icon URL - no further decoration\n    markerUrl = markerIcon;\n  } else {\n    markerUrl = GEOPOINTE_API + '/v1/markers/pin-l';\n\n    if (markerIcon) {\n      markerUrl += '-' + markerIcon;\n    }\n\n    if (markerColor) {\n      markerUrl += '+' + markerColor;\n    } else {\n      markerUrl += '+a0a0a0';\n    }\n\n    markerUrl += '.png';\n\n    if (markerText) {\n      markerUrl += '?text=' + encodeURIComponent(markerText);\n    }\n  }\n\n  return gp_DOMPurify.sanitize(markerUrl).replace(/amp;/g, '');\n} // Select dataset for use with route-based shape search vs\n// turf.buffer() polygon from route's polyline entity.\n// pLineId: key value in polygonObjects[key] of the route line being searched\n\n\nfunction gp_openRouteSearchPanel(pLineId, showRoute) {\n  var flScope = angular.element('#shapeSearchDataSetSelectorWrapper #search-folder-list').scope(); // var useShape = gp_routes.routes[gp_routes.activeRouteId].polyline;\n\n  var useShape = polygonObjects[pLineId];\n  if (!useShape || !useShape.gpProperties || useShape.gpProperties.gpType !== 'polyline') return;\n  flScope.searchShapeIsPolyline = true;\n  var useRange = useShape.gpProperties.range;\n  var useUnits = useShape.gpProperties.nearbySearchDistanceUnits;\n\n  if (!useRange || !useUnits) {\n    useRange = flScope.lineSearchRange || 0.5;\n    useUnits = 'activeRoute' === pLineId ? gp_routes.routes[gp_routes.activeRouteId].units : gp_userDistanceUnit;\n  }\n\n  flScope.lineSearchRange = Number(useRange);\n  flScope.lineSearchUnits = _.includes(['m', 'mi', 'miles'], useUnits) ? 'mi' : 'km';\n  angular.element('#ShapeSearchDataSetSelectorController').scope().options = {\n    overlayId: pLineId,\n    showRoute: showRoute\n  };\n  jQuery('#ShapeSearchDataSetSelectorController').dialog({\n    height: 500,\n    width: 394,\n    modal: true,\n    title: 'Select Data Set For Search',\n    resizable: false,\n    draggable: false,\n    dialogClass: 'gp-modal',\n    open: function open(event, ui) {\n      //Set height of modal content\n      setGPmodalContentHeight(jQuery(this));\n      var ssc = angular.element('#shapeSearchDataSetSelectorWrapper #search-folder-list').scope();\n      ssc.lineSearchRange = Number(flScope.lineSearchRange);\n      ssc.lineSearchUnits = flScope.lineSearchUnits;\n      ssc.searchShapeIsPolyline = flScope.searchShapeIsPolyline;\n      setTimeout(function () {\n        if (ssc.searchShapeIsPolyline) {\n          jQuery('#polylineRange').show();\n          jQuery('#shapeSearchDataSetSelectorWrapper input.lineSearchRange').val(gp_DOMPurify.sanitize(ssc.lineSearchRange));\n          jQuery('#shapeSearchDataSetSelectorWrapper select.lineSearchUnits').val(gp_DOMPurify.sanitize(ssc.lineSearchUnits));\n        } else {\n          jQuery('#polylineRange').hide();\n        }\n\n        ssc.$apply();\n      }, 100);\n    }\n  });\n}\n\nfunction gp_setCloseBarProperties(opts) {\n  if (opts.visibility == 'hidden') {\n    jQuery('#actionIframeDialogWrapper .gp-modal-footer').hide();\n  } else if (opts.visibility == 'visible') {\n    jQuery('#actionIframeDialogWrapper .gp-modal-footer').show();\n  }\n\n  setGPmodalContentHeight(jQuery('#actionIframeDialogWrapper'));\n\n  if (opts.label) {\n    jQuery('#actionIframeDialogWrapper .modalButtonRight').val(gp_escapeHtml(opts.label));\n  }\n}\n\nfunction gp_updateSavedLocations() {\n  var dsController = angular.element('.dataSetController').scope();\n\n  if (dsController && dsController.locationsService) {\n    setTimeout(function () {\n      dsController.locationsService.getLocations().then(function (locs) {\n        dsController.locations = locs;\n        dsController.$digest();\n      });\n    }, 1000);\n  }\n}\n\nfunction gp_copyImageToClipBoard(blob) {\n  const item = new ClipboardItem({\n    'image/png': blob\n  }); //Returns a promise\n\n  return navigator.clipboard.write([item]);\n}\n/**\n * Opens the new angular field selector with a type limit\n * @param {string} fieldType Type of field the parent code is looking for.\n * @param {string} inputSelector Parent css class. Used to locate the input fields for the callback. ex: '.selector'.\n * @param {string} selectedObject Name of object to start from ex: 'account'.\n */\n\n\nfunction gp_openFieldSelector(fieldType, inputSelector, selectedObject) {\n  const typeLimitMap = {\n    datetime: ['DATETIME'],\n    number: ['DOUBLE'],\n    latlng: ['DOUBLE', 'STRING'],\n    location: ['LOCATION'],\n    picklist: ['PICKLIST'],\n    string: ['STRING', 'TEXTAREA', 'COMBOBOX'],\n    addressField: ['STRING', 'TEXTAREA', 'PICKLIST'],\n    ownerField: ['STRING', 'REFERENCE (ID)'],\n    referenceName: ['STRING', 'REFERENCE']\n  };\n  const payload = {\n    action: 'openFieldSelectorModal',\n    data: {\n      selectedEntity: selectedObject,\n      callback: field => {\n        //Update the hidden input field for field name\n        const valueInputs = document.querySelector(inputSelector + ' > .CSObjectValue');\n\n        if (valueInputs) {\n          valueInputs.value = field.fullAPIName.toLowerCase();\n        } //Update the hidden input field for the object name of the selected field\n\n\n        const pathInputs = document.querySelector(inputSelector + ' >  .CSObjectPathValue');\n\n        if (pathInputs) {\n          pathInputs.value = field.objectName.toLowerCase();\n        } //Update the displayed label\n\n\n        const fieldNameInputs = document.querySelector(inputSelector + ' > .selectedFieldNameOutput');\n\n        if (fieldNameInputs) {\n          fieldNameInputs.innerHTML = gp_DOMPurify.sanitize(field.fullAPIName.toLowerCase());\n        }\n      },\n      isMultiSelect: false,\n      validTypes: typeLimitMap[fieldType]\n    }\n  };\n  gp_events.emit('FieldSelectorService', payload);\n}"}]);
//# sourceMappingURL=GeopointeJS.js.map